"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google";
exports.ids = ["vendor-chunks/@google"];
exports.modules = {

/***/ "(rsc)/./node_modules/@google/genai/dist/node/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@google/genai/dist/node/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityHandling: () => (/* binding */ ActivityHandling),\n/* harmony export */   AdapterSize: () => (/* binding */ AdapterSize),\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   ApiSpec: () => (/* binding */ ApiSpec),\n/* harmony export */   AuthType: () => (/* binding */ AuthType),\n/* harmony export */   Batches: () => (/* binding */ Batches),\n/* harmony export */   Behavior: () => (/* binding */ Behavior),\n/* harmony export */   BlockedReason: () => (/* binding */ BlockedReason),\n/* harmony export */   Caches: () => (/* binding */ Caches),\n/* harmony export */   CancelTuningJobResponse: () => (/* binding */ CancelTuningJobResponse),\n/* harmony export */   Chat: () => (/* binding */ Chat),\n/* harmony export */   Chats: () => (/* binding */ Chats),\n/* harmony export */   ComputeTokensResponse: () => (/* binding */ ComputeTokensResponse),\n/* harmony export */   ContentReferenceImage: () => (/* binding */ ContentReferenceImage),\n/* harmony export */   ControlReferenceImage: () => (/* binding */ ControlReferenceImage),\n/* harmony export */   ControlReferenceType: () => (/* binding */ ControlReferenceType),\n/* harmony export */   CountTokensResponse: () => (/* binding */ CountTokensResponse),\n/* harmony export */   CreateFileResponse: () => (/* binding */ CreateFileResponse),\n/* harmony export */   DeleteCachedContentResponse: () => (/* binding */ DeleteCachedContentResponse),\n/* harmony export */   DeleteFileResponse: () => (/* binding */ DeleteFileResponse),\n/* harmony export */   DeleteModelResponse: () => (/* binding */ DeleteModelResponse),\n/* harmony export */   DocumentState: () => (/* binding */ DocumentState),\n/* harmony export */   DynamicRetrievalConfigMode: () => (/* binding */ DynamicRetrievalConfigMode),\n/* harmony export */   EditImageResponse: () => (/* binding */ EditImageResponse),\n/* harmony export */   EditMode: () => (/* binding */ EditMode),\n/* harmony export */   EmbedContentResponse: () => (/* binding */ EmbedContentResponse),\n/* harmony export */   EndSensitivity: () => (/* binding */ EndSensitivity),\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   FeatureSelectionPreference: () => (/* binding */ FeatureSelectionPreference),\n/* harmony export */   FileSource: () => (/* binding */ FileSource),\n/* harmony export */   FileState: () => (/* binding */ FileState),\n/* harmony export */   Files: () => (/* binding */ Files),\n/* harmony export */   FinishReason: () => (/* binding */ FinishReason),\n/* harmony export */   FunctionCallingConfigMode: () => (/* binding */ FunctionCallingConfigMode),\n/* harmony export */   FunctionResponse: () => (/* binding */ FunctionResponse),\n/* harmony export */   FunctionResponseBlob: () => (/* binding */ FunctionResponseBlob),\n/* harmony export */   FunctionResponseFileData: () => (/* binding */ FunctionResponseFileData),\n/* harmony export */   FunctionResponsePart: () => (/* binding */ FunctionResponsePart),\n/* harmony export */   FunctionResponseScheduling: () => (/* binding */ FunctionResponseScheduling),\n/* harmony export */   GenerateContentResponse: () => (/* binding */ GenerateContentResponse),\n/* harmony export */   GenerateContentResponsePromptFeedback: () => (/* binding */ GenerateContentResponsePromptFeedback),\n/* harmony export */   GenerateContentResponseUsageMetadata: () => (/* binding */ GenerateContentResponseUsageMetadata),\n/* harmony export */   GenerateImagesResponse: () => (/* binding */ GenerateImagesResponse),\n/* harmony export */   GenerateVideosOperation: () => (/* binding */ GenerateVideosOperation),\n/* harmony export */   GenerateVideosResponse: () => (/* binding */ GenerateVideosResponse),\n/* harmony export */   GoogleGenAI: () => (/* binding */ GoogleGenAI),\n/* harmony export */   HarmBlockMethod: () => (/* binding */ HarmBlockMethod),\n/* harmony export */   HarmBlockThreshold: () => (/* binding */ HarmBlockThreshold),\n/* harmony export */   HarmCategory: () => (/* binding */ HarmCategory),\n/* harmony export */   HarmProbability: () => (/* binding */ HarmProbability),\n/* harmony export */   HarmSeverity: () => (/* binding */ HarmSeverity),\n/* harmony export */   HttpElementLocation: () => (/* binding */ HttpElementLocation),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse),\n/* harmony export */   ImagePromptLanguage: () => (/* binding */ ImagePromptLanguage),\n/* harmony export */   ImportFileOperation: () => (/* binding */ ImportFileOperation),\n/* harmony export */   ImportFileResponse: () => (/* binding */ ImportFileResponse),\n/* harmony export */   InlinedEmbedContentResponse: () => (/* binding */ InlinedEmbedContentResponse),\n/* harmony export */   InlinedResponse: () => (/* binding */ InlinedResponse),\n/* harmony export */   JobState: () => (/* binding */ JobState),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   ListBatchJobsResponse: () => (/* binding */ ListBatchJobsResponse),\n/* harmony export */   ListCachedContentsResponse: () => (/* binding */ ListCachedContentsResponse),\n/* harmony export */   ListDocumentsResponse: () => (/* binding */ ListDocumentsResponse),\n/* harmony export */   ListFileSearchStoresResponse: () => (/* binding */ ListFileSearchStoresResponse),\n/* harmony export */   ListFilesResponse: () => (/* binding */ ListFilesResponse),\n/* harmony export */   ListModelsResponse: () => (/* binding */ ListModelsResponse),\n/* harmony export */   ListTuningJobsResponse: () => (/* binding */ ListTuningJobsResponse),\n/* harmony export */   Live: () => (/* binding */ Live),\n/* harmony export */   LiveClientToolResponse: () => (/* binding */ LiveClientToolResponse),\n/* harmony export */   LiveMusicPlaybackControl: () => (/* binding */ LiveMusicPlaybackControl),\n/* harmony export */   LiveMusicServerMessage: () => (/* binding */ LiveMusicServerMessage),\n/* harmony export */   LiveSendToolResponseParameters: () => (/* binding */ LiveSendToolResponseParameters),\n/* harmony export */   LiveServerMessage: () => (/* binding */ LiveServerMessage),\n/* harmony export */   MaskReferenceImage: () => (/* binding */ MaskReferenceImage),\n/* harmony export */   MaskReferenceMode: () => (/* binding */ MaskReferenceMode),\n/* harmony export */   MediaModality: () => (/* binding */ MediaModality),\n/* harmony export */   MediaResolution: () => (/* binding */ MediaResolution),\n/* harmony export */   Modality: () => (/* binding */ Modality),\n/* harmony export */   Models: () => (/* binding */ Models),\n/* harmony export */   MusicGenerationMode: () => (/* binding */ MusicGenerationMode),\n/* harmony export */   Operations: () => (/* binding */ Operations),\n/* harmony export */   Outcome: () => (/* binding */ Outcome),\n/* harmony export */   PagedItem: () => (/* binding */ PagedItem),\n/* harmony export */   Pager: () => (/* binding */ Pager),\n/* harmony export */   PartMediaResolutionLevel: () => (/* binding */ PartMediaResolutionLevel),\n/* harmony export */   PersonGeneration: () => (/* binding */ PersonGeneration),\n/* harmony export */   PhishBlockThreshold: () => (/* binding */ PhishBlockThreshold),\n/* harmony export */   RawReferenceImage: () => (/* binding */ RawReferenceImage),\n/* harmony export */   RecontextImageResponse: () => (/* binding */ RecontextImageResponse),\n/* harmony export */   ReplayResponse: () => (/* binding */ ReplayResponse),\n/* harmony export */   SafetyFilterLevel: () => (/* binding */ SafetyFilterLevel),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   SegmentImageResponse: () => (/* binding */ SegmentImageResponse),\n/* harmony export */   SegmentMode: () => (/* binding */ SegmentMode),\n/* harmony export */   Session: () => (/* binding */ Session),\n/* harmony export */   SingleEmbedContentResponse: () => (/* binding */ SingleEmbedContentResponse),\n/* harmony export */   StartSensitivity: () => (/* binding */ StartSensitivity),\n/* harmony export */   StyleReferenceImage: () => (/* binding */ StyleReferenceImage),\n/* harmony export */   SubjectReferenceImage: () => (/* binding */ SubjectReferenceImage),\n/* harmony export */   SubjectReferenceType: () => (/* binding */ SubjectReferenceType),\n/* harmony export */   ThinkingLevel: () => (/* binding */ ThinkingLevel),\n/* harmony export */   Tokens: () => (/* binding */ Tokens),\n/* harmony export */   TrafficType: () => (/* binding */ TrafficType),\n/* harmony export */   TuningMethod: () => (/* binding */ TuningMethod),\n/* harmony export */   TuningMode: () => (/* binding */ TuningMode),\n/* harmony export */   TuningTask: () => (/* binding */ TuningTask),\n/* harmony export */   TurnCompleteReason: () => (/* binding */ TurnCompleteReason),\n/* harmony export */   TurnCoverage: () => (/* binding */ TurnCoverage),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   UploadToFileSearchStoreOperation: () => (/* binding */ UploadToFileSearchStoreOperation),\n/* harmony export */   UploadToFileSearchStoreResponse: () => (/* binding */ UploadToFileSearchStoreResponse),\n/* harmony export */   UploadToFileSearchStoreResumableResponse: () => (/* binding */ UploadToFileSearchStoreResumableResponse),\n/* harmony export */   UpscaleImageResponse: () => (/* binding */ UpscaleImageResponse),\n/* harmony export */   UrlRetrievalStatus: () => (/* binding */ UrlRetrievalStatus),\n/* harmony export */   VadSignalType: () => (/* binding */ VadSignalType),\n/* harmony export */   VideoCompressionQuality: () => (/* binding */ VideoCompressionQuality),\n/* harmony export */   VideoGenerationMaskMode: () => (/* binding */ VideoGenerationMaskMode),\n/* harmony export */   VideoGenerationReferenceType: () => (/* binding */ VideoGenerationReferenceType),\n/* harmony export */   createFunctionResponsePartFromBase64: () => (/* binding */ createFunctionResponsePartFromBase64),\n/* harmony export */   createFunctionResponsePartFromUri: () => (/* binding */ createFunctionResponsePartFromUri),\n/* harmony export */   createModelContent: () => (/* binding */ createModelContent),\n/* harmony export */   createPartFromBase64: () => (/* binding */ createPartFromBase64),\n/* harmony export */   createPartFromCodeExecutionResult: () => (/* binding */ createPartFromCodeExecutionResult),\n/* harmony export */   createPartFromExecutableCode: () => (/* binding */ createPartFromExecutableCode),\n/* harmony export */   createPartFromFunctionCall: () => (/* binding */ createPartFromFunctionCall),\n/* harmony export */   createPartFromFunctionResponse: () => (/* binding */ createPartFromFunctionResponse),\n/* harmony export */   createPartFromText: () => (/* binding */ createPartFromText),\n/* harmony export */   createPartFromUri: () => (/* binding */ createPartFromUri),\n/* harmony export */   createUserContent: () => (/* binding */ createUserContent),\n/* harmony export */   mcpToTool: () => (/* binding */ mcpToTool),\n/* harmony export */   setDefaultBaseUrls: () => (/* binding */ setDefaultBaseUrls)\n/* harmony export */ });\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var node_stream_promises__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:stream/promises */ \"node:stream/promises\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! path */ \"path\");\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ let _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */ function setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */ function getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */ function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b;\n    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (vertexai) {\n            return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;\n        } else {\n            return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;\n        }\n    }\n    return httpOptions.baseUrl;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key)=>{\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : \"\";\n        } else {\n            // Handle missing keys\n            throw new Error(`Key '${key}' not found in valueMap.`);\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for(let i = 0; i < keys.length - 1; i++){\n        const key = keys[i];\n        if (key.endsWith(\"[]\")) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({\n                        length: value.length\n                    }, ()=>({}));\n                } else {\n                    throw new Error(`Value must be a list given an array path ${key}`);\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for(let j = 0; j < arrayData.length; j++){\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                } else {\n                    for (const d of arrayData){\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        } else if (key.endsWith(\"[0]\")) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [\n                    {}\n                ];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== \"object\") {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value || typeof value === \"object\" && Object.keys(value).length === 0) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === \"object\" && typeof value === \"object\" && existingData !== null && value !== null) {\n            Object.assign(existingData, value);\n        } else {\n            throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);\n        }\n    } else {\n        if (keyToSet === \"_self\" && typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n            const valueAsRecord = value;\n            Object.assign(data, valueAsRecord);\n        } else {\n            data[keyToSet] = value;\n        }\n    }\n}\nfunction getValueByPath(data, keys, defaultValue = undefined) {\n    try {\n        if (keys.length === 1 && keys[0] === \"_self\") {\n            return data;\n        }\n        for(let i = 0; i < keys.length; i++){\n            if (typeof data !== \"object\" || data === null) {\n                return defaultValue;\n            }\n            const key = keys[i];\n            if (key.endsWith(\"[]\")) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return defaultValue;\n                    }\n                    return arrayData.map((d)=>getValueByPath(d, keys.slice(i + 1), defaultValue));\n                } else {\n                    return defaultValue;\n                }\n            } else {\n                data = data[key];\n            }\n        }\n        return data;\n    } catch (error) {\n        if (error instanceof TypeError) {\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n/**\n * Moves values from source paths to destination paths.\n *\n * Examples:\n *   moveValueByPath(\n *     {'requests': [{'content': v1}, {'content': v2}]},\n *     {'requests[].*': 'requests[].request.*'}\n *   )\n *     -> {'requests': [{'request': {'content': v1}}, {'request': {'content': v2}}]}\n */ function moveValueByPath(data, paths) {\n    for (const [sourcePath, destPath] of Object.entries(paths)){\n        const sourceKeys = sourcePath.split(\".\");\n        const destKeys = destPath.split(\".\");\n        // Determine keys to exclude from wildcard to avoid cyclic references\n        const excludeKeys = new Set();\n        let wildcardIdx = -1;\n        for(let i = 0; i < sourceKeys.length; i++){\n            if (sourceKeys[i] === \"*\") {\n                wildcardIdx = i;\n                break;\n            }\n        }\n        if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {\n            // Extract the intermediate key between source and dest paths\n            // Example: source=['requests[]', '*'], dest=['requests[]', 'request', '*']\n            // We want to exclude 'request'\n            for(let i = wildcardIdx; i < destKeys.length; i++){\n                const key = destKeys[i];\n                if (key !== \"*\" && !key.endsWith(\"[]\") && !key.endsWith(\"[0]\")) {\n                    excludeKeys.add(key);\n                }\n            }\n        }\n        _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);\n    }\n}\n/**\n * Recursively moves values from source path to destination path.\n */ function _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {\n    if (keyIdx >= sourceKeys.length) {\n        return;\n    }\n    if (typeof data !== \"object\" || data === null) {\n        return;\n    }\n    const key = sourceKeys[keyIdx];\n    if (key.endsWith(\"[]\")) {\n        const keyName = key.slice(0, -2);\n        const dataRecord = data;\n        if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {\n            for (const item of dataRecord[keyName]){\n                _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n            }\n        }\n    } else if (key === \"*\") {\n        // wildcard - move all fields\n        if (typeof data === \"object\" && data !== null && !Array.isArray(data)) {\n            const dataRecord = data;\n            const keysToMove = Object.keys(dataRecord).filter((k)=>!k.startsWith(\"_\") && !excludeKeys.has(k));\n            const valuesToMove = {};\n            for (const k of keysToMove){\n                valuesToMove[k] = dataRecord[k];\n            }\n            // Set values at destination\n            for (const [k, v] of Object.entries(valuesToMove)){\n                const newDestKeys = [];\n                for (const dk of destKeys.slice(keyIdx)){\n                    if (dk === \"*\") {\n                        newDestKeys.push(k);\n                    } else {\n                        newDestKeys.push(dk);\n                    }\n                }\n                setValueByPath(dataRecord, newDestKeys, v);\n            }\n            for (const k of keysToMove){\n                delete dataRecord[k];\n            }\n        }\n    } else {\n        // Navigate to next level\n        const dataRecord = data;\n        if (key in dataRecord) {\n            _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tBytes$1(fromBytes) {\n    if (typeof fromBytes !== \"string\") {\n        throw new Error(\"fromImageBytes must be a string\");\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromBytes;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction fetchPredictOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, [\n        \"resourceName\"\n    ]);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"resourceName\"\n        ], fromResourceName);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev$1(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex$1(fromVideo));\n    }\n    return toObject;\n}\nfunction getOperationParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    return toObject;\n}\nfunction importFileOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], importFileResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction importFileResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"parent\"\n        ], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, [\n        \"documentName\"\n    ]);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, [\n            \"documentName\"\n        ], fromDocumentName);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], uploadToFileSearchStoreResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"parent\"\n        ], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, [\n        \"documentName\"\n    ]);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, [\n            \"documentName\"\n        ], fromDocumentName);\n    }\n    return toObject;\n}\nfunction videoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /** Outcome of the code execution. */ var Outcome;\n(function(Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */ Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    /**\n     * Code execution completed successfully.\n     */ Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the reason.\n     */ Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not be a partial output present.\n     */ Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(Outcome || (Outcome = {}));\n/** Programming language of the `code`. */ var Language;\n(function(Language) {\n    /**\n     * Unspecified language. This value should not be used.\n     */ Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    /**\n     * Python >= 3.10, with numpy and simpy available.\n     */ Language[\"PYTHON\"] = \"PYTHON\";\n})(Language || (Language = {}));\n/** Specifies how the response should be scheduled in the conversation. */ var FunctionResponseScheduling;\n(function(FunctionResponseScheduling) {\n    /**\n     * This value is unused.\n     */ FunctionResponseScheduling[\"SCHEDULING_UNSPECIFIED\"] = \"SCHEDULING_UNSPECIFIED\";\n    /**\n     * Only add the result to the conversation context, do not interrupt or trigger generation.\n     */ FunctionResponseScheduling[\"SILENT\"] = \"SILENT\";\n    /**\n     * Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.\n     */ FunctionResponseScheduling[\"WHEN_IDLE\"] = \"WHEN_IDLE\";\n    /**\n     * Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.\n     */ FunctionResponseScheduling[\"INTERRUPT\"] = \"INTERRUPT\";\n})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));\n/** The type of the data. */ var Type;\n(function(Type) {\n    /**\n     * Not specified, should not be used.\n     */ Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * OpenAPI string type\n     */ Type[\"STRING\"] = \"STRING\";\n    /**\n     * OpenAPI number type\n     */ Type[\"NUMBER\"] = \"NUMBER\";\n    /**\n     * OpenAPI integer type\n     */ Type[\"INTEGER\"] = \"INTEGER\";\n    /**\n     * OpenAPI boolean type\n     */ Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    /**\n     * OpenAPI array type\n     */ Type[\"ARRAY\"] = \"ARRAY\";\n    /**\n     * OpenAPI object type\n     */ Type[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Null type\n     */ Type[\"NULL\"] = \"NULL\";\n})(Type || (Type = {}));\n/** The API spec that the external API implements. This enum is not supported in Gemini API. */ var ApiSpec;\n(function(ApiSpec) {\n    /**\n     * Unspecified API spec. This value should not be used.\n     */ ApiSpec[\"API_SPEC_UNSPECIFIED\"] = \"API_SPEC_UNSPECIFIED\";\n    /**\n     * Simple search API spec.\n     */ ApiSpec[\"SIMPLE_SEARCH\"] = \"SIMPLE_SEARCH\";\n    /**\n     * Elastic search API spec.\n     */ ApiSpec[\"ELASTIC_SEARCH\"] = \"ELASTIC_SEARCH\";\n})(ApiSpec || (ApiSpec = {}));\n/** Type of auth scheme. This enum is not supported in Gemini API. */ var AuthType;\n(function(AuthType) {\n    AuthType[\"AUTH_TYPE_UNSPECIFIED\"] = \"AUTH_TYPE_UNSPECIFIED\";\n    /**\n     * No Auth.\n     */ AuthType[\"NO_AUTH\"] = \"NO_AUTH\";\n    /**\n     * API Key Auth.\n     */ AuthType[\"API_KEY_AUTH\"] = \"API_KEY_AUTH\";\n    /**\n     * HTTP Basic Auth.\n     */ AuthType[\"HTTP_BASIC_AUTH\"] = \"HTTP_BASIC_AUTH\";\n    /**\n     * Google Service Account Auth.\n     */ AuthType[\"GOOGLE_SERVICE_ACCOUNT_AUTH\"] = \"GOOGLE_SERVICE_ACCOUNT_AUTH\";\n    /**\n     * OAuth auth.\n     */ AuthType[\"OAUTH\"] = \"OAUTH\";\n    /**\n     * OpenID Connect (OIDC) Auth.\n     */ AuthType[\"OIDC_AUTH\"] = \"OIDC_AUTH\";\n})(AuthType || (AuthType = {}));\n/** The location of the API key. This enum is not supported in Gemini API. */ var HttpElementLocation;\n(function(HttpElementLocation) {\n    HttpElementLocation[\"HTTP_IN_UNSPECIFIED\"] = \"HTTP_IN_UNSPECIFIED\";\n    /**\n     * Element is in the HTTP request query.\n     */ HttpElementLocation[\"HTTP_IN_QUERY\"] = \"HTTP_IN_QUERY\";\n    /**\n     * Element is in the HTTP request header.\n     */ HttpElementLocation[\"HTTP_IN_HEADER\"] = \"HTTP_IN_HEADER\";\n    /**\n     * Element is in the HTTP request path.\n     */ HttpElementLocation[\"HTTP_IN_PATH\"] = \"HTTP_IN_PATH\";\n    /**\n     * Element is in the HTTP request body.\n     */ HttpElementLocation[\"HTTP_IN_BODY\"] = \"HTTP_IN_BODY\";\n    /**\n     * Element is in the HTTP request cookie.\n     */ HttpElementLocation[\"HTTP_IN_COOKIE\"] = \"HTTP_IN_COOKIE\";\n})(HttpElementLocation || (HttpElementLocation = {}));\n/** Sites with confidence level chosen & above this value will be blocked from the search results. This enum is not supported in Gemini API. */ var PhishBlockThreshold;\n(function(PhishBlockThreshold) {\n    /**\n     * Defaults to unspecified.\n     */ PhishBlockThreshold[\"PHISH_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"PHISH_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Blocks Low and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Blocks Medium and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Blocks High and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_HIGH_AND_ABOVE\"] = \"BLOCK_HIGH_AND_ABOVE\";\n    /**\n     * Blocks Higher and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_HIGHER_AND_ABOVE\"] = \"BLOCK_HIGHER_AND_ABOVE\";\n    /**\n     * Blocks Very high and above confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_VERY_HIGH_AND_ABOVE\"] = \"BLOCK_VERY_HIGH_AND_ABOVE\";\n    /**\n     * Blocks Extremely high confidence URL that is risky.\n     */ PhishBlockThreshold[\"BLOCK_ONLY_EXTREMELY_HIGH\"] = \"BLOCK_ONLY_EXTREMELY_HIGH\";\n})(PhishBlockThreshold || (PhishBlockThreshold = {}));\n/** Specifies the function Behavior. Currently only supported by the BidiGenerateContent method. This enum is not supported in Vertex AI. */ var Behavior;\n(function(Behavior) {\n    /**\n     * This value is unused.\n     */ Behavior[\"UNSPECIFIED\"] = \"UNSPECIFIED\";\n    /**\n     * If set, the system will wait to receive the function response before continuing the conversation.\n     */ Behavior[\"BLOCKING\"] = \"BLOCKING\";\n    /**\n     * If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.\n     */ Behavior[\"NON_BLOCKING\"] = \"NON_BLOCKING\";\n})(Behavior || (Behavior = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */ var DynamicRetrievalConfigMode;\n(function(DynamicRetrievalConfigMode) {\n    /**\n     * Always trigger retrieval.\n     */ DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));\n/** Function calling mode. */ var FunctionCallingConfigMode;\n(function(FunctionCallingConfigMode) {\n    /**\n     * Unspecified function calling mode. This value should not be used.\n     */ FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Default model behavior, model decides to predict either function calls or natural language response.\n     */ FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    /**\n     * Model is constrained to always predicting function calls only. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */ FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    /**\n     * Model will not predict any function calls. Model behavior is same as when not passing any function declarations.\n     */ FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n    /**\n     * Model is constrained to predict either function calls or natural language response. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */ FunctionCallingConfigMode[\"VALIDATED\"] = \"VALIDATED\";\n})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));\n/** The number of thoughts tokens that the model should generate. */ var ThinkingLevel;\n(function(ThinkingLevel) {\n    /**\n     * Unspecified thinking level.\n     */ ThinkingLevel[\"THINKING_LEVEL_UNSPECIFIED\"] = \"THINKING_LEVEL_UNSPECIFIED\";\n    /**\n     * Low thinking level.\n     */ ThinkingLevel[\"LOW\"] = \"LOW\";\n    /**\n     * Medium thinking level.\n     */ ThinkingLevel[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High thinking level.\n     */ ThinkingLevel[\"HIGH\"] = \"HIGH\";\n    /**\n     * MINIMAL thinking level.\n     */ ThinkingLevel[\"MINIMAL\"] = \"MINIMAL\";\n})(ThinkingLevel || (ThinkingLevel = {}));\n/** Harm category. */ var HarmCategory;\n(function(HarmCategory) {\n    /**\n     * The harm category is unspecified.\n     */ HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    /**\n     * The harm category is harassment.\n     */ HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    /**\n     * The harm category is hate speech.\n     */ HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    /**\n     * The harm category is sexually explicit content.\n     */ HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is dangerous content.\n     */ HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    /**\n     * Deprecated: Election filter is not longer supported. The harm category is civic integrity.\n     */ HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n    /**\n     * The harm category is image hate. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_HATE\"] = \"HARM_CATEGORY_IMAGE_HATE\";\n    /**\n     * The harm category is image dangerous content. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is image harassment. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_HARASSMENT\"] = \"HARM_CATEGORY_IMAGE_HARASSMENT\";\n    /**\n     * The harm category is image sexually explicit content. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is for jailbreak prompts. This enum value is not supported in Gemini API.\n     */ HarmCategory[\"HARM_CATEGORY_JAILBREAK\"] = \"HARM_CATEGORY_JAILBREAK\";\n})(HarmCategory || (HarmCategory = {}));\n/** Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. This enum is not supported in Gemini API. */ var HarmBlockMethod;\n(function(HarmBlockMethod) {\n    /**\n     * The harm block method is unspecified.\n     */ HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    /**\n     * The harm block method uses both probability and severity scores.\n     */ HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    /**\n     * The harm block method uses the probability score.\n     */ HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(HarmBlockMethod || (HarmBlockMethod = {}));\n/** The harm block threshold. */ var HarmBlockThreshold;\n(function(HarmBlockThreshold) {\n    /**\n     * Unspecified harm block threshold.\n     */ HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Block low threshold and above (i.e. block more).\n     */ HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Block medium threshold and above.\n     */ HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Block only high threshold (i.e. block less).\n     */ HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /**\n     * Block none.\n     */ HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    /**\n     * Turn off the safety filter.\n     */ HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\nIf empty, the model has not stopped generating the tokens. */ var FinishReason;\n(function(FinishReason) {\n    /**\n     * The finish reason is unspecified.\n     */ FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    /**\n     * Token generation reached a natural stopping point or a configured stop sequence.\n     */ FinishReason[\"STOP\"] = \"STOP\";\n    /**\n     * Token generation reached the configured maximum output tokens.\n     */ FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    /**\n     * Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.\n     */ FinishReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The token generation stopped because of potential recitation.\n     */ FinishReason[\"RECITATION\"] = \"RECITATION\";\n    /**\n     * The token generation stopped because of using an unsupported language.\n     */ FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    /**\n     * All other reasons that stopped the token generation.\n     */ FinishReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Token generation stopped because the content contains forbidden terms.\n     */ FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Token generation stopped for potentially containing prohibited content.\n     */ FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n     */ FinishReason[\"SPII\"] = \"SPII\";\n    /**\n     * The function call generated by the model is invalid.\n     */ FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * Token generation stopped because generated images have safety violations.\n     */ FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The tool call generated by the model is invalid.\n     */ FinishReason[\"UNEXPECTED_TOOL_CALL\"] = \"UNEXPECTED_TOOL_CALL\";\n    /**\n     * Image generation stopped because the generated images have prohibited content.\n     */ FinishReason[\"IMAGE_PROHIBITED_CONTENT\"] = \"IMAGE_PROHIBITED_CONTENT\";\n    /**\n     * The model was expected to generate an image, but none was generated.\n     */ FinishReason[\"NO_IMAGE\"] = \"NO_IMAGE\";\n    /**\n     * Image generation stopped because the generated image may be a recitation from a source.\n     */ FinishReason[\"IMAGE_RECITATION\"] = \"IMAGE_RECITATION\";\n    /**\n     * Image generation stopped for a reason not otherwise specified.\n     */ FinishReason[\"IMAGE_OTHER\"] = \"IMAGE_OTHER\";\n})(FinishReason || (FinishReason = {}));\n/** Output only. Harm probability levels in the content. */ var HarmProbability;\n(function(HarmProbability) {\n    /**\n     * Harm probability unspecified.\n     */ HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm.\n     */ HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /**\n     * Low level of harm.\n     */ HarmProbability[\"LOW\"] = \"LOW\";\n    /**\n     * Medium level of harm.\n     */ HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High level of harm.\n     */ HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/** Output only. Harm severity levels in the content. This enum is not supported in Gemini API. */ var HarmSeverity;\n(function(HarmSeverity) {\n    /**\n     * Harm severity unspecified.\n     */ HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    /**\n     * Low level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    /**\n     * Medium level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    /**\n     * High level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(HarmSeverity || (HarmSeverity = {}));\n/** Status of the url retrieval. */ var UrlRetrievalStatus;\n(function(UrlRetrievalStatus) {\n    /**\n     * Default value. This value is unused.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSPECIFIED\"] = \"URL_RETRIEVAL_STATUS_UNSPECIFIED\";\n    /**\n     * Url retrieval is successful.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_SUCCESS\"] = \"URL_RETRIEVAL_STATUS_SUCCESS\";\n    /**\n     * Url retrieval is failed due to error.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_ERROR\"] = \"URL_RETRIEVAL_STATUS_ERROR\";\n    /**\n     * Url retrieval is failed because the content is behind paywall. This enum value is not supported in Vertex AI.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_PAYWALL\"] = \"URL_RETRIEVAL_STATUS_PAYWALL\";\n    /**\n     * Url retrieval is failed because the content is unsafe. This enum value is not supported in Vertex AI.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSAFE\"] = \"URL_RETRIEVAL_STATUS_UNSAFE\";\n})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));\n/** Output only. The reason why the prompt was blocked. */ var BlockedReason;\n(function(BlockedReason) {\n    /**\n     * The blocked reason is unspecified.\n     */ BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    /**\n     * The prompt was blocked for safety reasons.\n     */ BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The prompt was blocked for other reasons. For example, it may be due to the prompt's language, or because it contains other harmful content.\n     */ BlockedReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * The prompt was blocked because it contains a term from the terminology blocklist.\n     */ BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * The prompt was blocked because it contains prohibited content.\n     */ BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * The prompt was blocked because it contains content that is unsafe for image generation.\n     */ BlockedReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The prompt was blocked by Model Armor. This enum value is not supported in Gemini API.\n     */ BlockedReason[\"MODEL_ARMOR\"] = \"MODEL_ARMOR\";\n    /**\n     * The prompt was blocked as a jailbreak attempt. This enum value is not supported in Gemini API.\n     */ BlockedReason[\"JAILBREAK\"] = \"JAILBREAK\";\n})(BlockedReason || (BlockedReason = {}));\n/** Output only. The traffic type for this request. This enum is not supported in Gemini API. */ var TrafficType;\n(function(TrafficType) {\n    /**\n     * Unspecified request traffic type.\n     */ TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    /**\n     * The request was processed using Pay-As-You-Go quota.\n     */ TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    /**\n     * Type for Provisioned Throughput traffic.\n     */ TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(TrafficType || (TrafficType = {}));\n/** Server content modalities. */ var Modality;\n(function(Modality) {\n    /**\n     * The modality is unspecified.\n     */ Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Indicates the model should return text\n     */ Modality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Indicates the model should return images.\n     */ Modality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Indicates the model should return audio.\n     */ Modality[\"AUDIO\"] = \"AUDIO\";\n})(Modality || (Modality = {}));\n/** The media resolution to use. */ var MediaResolution;\n(function(MediaResolution) {\n    /**\n     * Media resolution has not been set\n     */ MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low (64 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium (256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high (zoomed reframing with 256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(MediaResolution || (MediaResolution = {}));\n/** Tuning mode. This enum is not supported in Gemini API. */ var TuningMode;\n(function(TuningMode) {\n    /**\n     * Tuning mode is unspecified.\n     */ TuningMode[\"TUNING_MODE_UNSPECIFIED\"] = \"TUNING_MODE_UNSPECIFIED\";\n    /**\n     * Full fine-tuning mode.\n     */ TuningMode[\"TUNING_MODE_FULL\"] = \"TUNING_MODE_FULL\";\n    /**\n     * PEFT adapter tuning mode.\n     */ TuningMode[\"TUNING_MODE_PEFT_ADAPTER\"] = \"TUNING_MODE_PEFT_ADAPTER\";\n})(TuningMode || (TuningMode = {}));\n/** Adapter size for tuning. This enum is not supported in Gemini API. */ var AdapterSize;\n(function(AdapterSize) {\n    /**\n     * Adapter size is unspecified.\n     */ AdapterSize[\"ADAPTER_SIZE_UNSPECIFIED\"] = \"ADAPTER_SIZE_UNSPECIFIED\";\n    /**\n     * Adapter size 1.\n     */ AdapterSize[\"ADAPTER_SIZE_ONE\"] = \"ADAPTER_SIZE_ONE\";\n    /**\n     * Adapter size 2.\n     */ AdapterSize[\"ADAPTER_SIZE_TWO\"] = \"ADAPTER_SIZE_TWO\";\n    /**\n     * Adapter size 4.\n     */ AdapterSize[\"ADAPTER_SIZE_FOUR\"] = \"ADAPTER_SIZE_FOUR\";\n    /**\n     * Adapter size 8.\n     */ AdapterSize[\"ADAPTER_SIZE_EIGHT\"] = \"ADAPTER_SIZE_EIGHT\";\n    /**\n     * Adapter size 16.\n     */ AdapterSize[\"ADAPTER_SIZE_SIXTEEN\"] = \"ADAPTER_SIZE_SIXTEEN\";\n    /**\n     * Adapter size 32.\n     */ AdapterSize[\"ADAPTER_SIZE_THIRTY_TWO\"] = \"ADAPTER_SIZE_THIRTY_TWO\";\n})(AdapterSize || (AdapterSize = {}));\n/** Job state. */ var JobState;\n(function(JobState) {\n    /**\n     * The job state is unspecified.\n     */ JobState[\"JOB_STATE_UNSPECIFIED\"] = \"JOB_STATE_UNSPECIFIED\";\n    /**\n     * The job has been just created or resumed and processing has not yet begun.\n     */ JobState[\"JOB_STATE_QUEUED\"] = \"JOB_STATE_QUEUED\";\n    /**\n     * The service is preparing to run the job.\n     */ JobState[\"JOB_STATE_PENDING\"] = \"JOB_STATE_PENDING\";\n    /**\n     * The job is in progress.\n     */ JobState[\"JOB_STATE_RUNNING\"] = \"JOB_STATE_RUNNING\";\n    /**\n     * The job completed successfully.\n     */ JobState[\"JOB_STATE_SUCCEEDED\"] = \"JOB_STATE_SUCCEEDED\";\n    /**\n     * The job failed.\n     */ JobState[\"JOB_STATE_FAILED\"] = \"JOB_STATE_FAILED\";\n    /**\n     * The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.\n     */ JobState[\"JOB_STATE_CANCELLING\"] = \"JOB_STATE_CANCELLING\";\n    /**\n     * The job has been cancelled.\n     */ JobState[\"JOB_STATE_CANCELLED\"] = \"JOB_STATE_CANCELLED\";\n    /**\n     * The job has been stopped, and can be resumed.\n     */ JobState[\"JOB_STATE_PAUSED\"] = \"JOB_STATE_PAUSED\";\n    /**\n     * The job has expired.\n     */ JobState[\"JOB_STATE_EXPIRED\"] = \"JOB_STATE_EXPIRED\";\n    /**\n     * The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.\n     */ JobState[\"JOB_STATE_UPDATING\"] = \"JOB_STATE_UPDATING\";\n    /**\n     * The job is partially succeeded, some results may be missing due to errors.\n     */ JobState[\"JOB_STATE_PARTIALLY_SUCCEEDED\"] = \"JOB_STATE_PARTIALLY_SUCCEEDED\";\n})(JobState || (JobState = {}));\n/** The tuning task. Either I2V or T2V. This enum is not supported in Gemini API. */ var TuningTask;\n(function(TuningTask) {\n    /**\n     * Default value. This value is unused.\n     */ TuningTask[\"TUNING_TASK_UNSPECIFIED\"] = \"TUNING_TASK_UNSPECIFIED\";\n    /**\n     * Tuning task for image to video.\n     */ TuningTask[\"TUNING_TASK_I2V\"] = \"TUNING_TASK_I2V\";\n    /**\n     * Tuning task for text to video.\n     */ TuningTask[\"TUNING_TASK_T2V\"] = \"TUNING_TASK_T2V\";\n    /**\n     * Tuning task for reference to video.\n     */ TuningTask[\"TUNING_TASK_R2V\"] = \"TUNING_TASK_R2V\";\n})(TuningTask || (TuningTask = {}));\n/** The tokenization quality used for given media. */ var PartMediaResolutionLevel;\n(function(PartMediaResolutionLevel) {\n    /**\n     * Media resolution has not been set.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n    /**\n     * Media resolution set to ultra high.\n     */ PartMediaResolutionLevel[\"MEDIA_RESOLUTION_ULTRA_HIGH\"] = \"MEDIA_RESOLUTION_ULTRA_HIGH\";\n})(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));\n/** Options for feature selection preference. */ var FeatureSelectionPreference;\n(function(FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));\n/** The environment being operated. */ var Environment;\n(function(Environment) {\n    /**\n     * Defaults to browser.\n     */ Environment[\"ENVIRONMENT_UNSPECIFIED\"] = \"ENVIRONMENT_UNSPECIFIED\";\n    /**\n     * Operates in a web browser.\n     */ Environment[\"ENVIRONMENT_BROWSER\"] = \"ENVIRONMENT_BROWSER\";\n})(Environment || (Environment = {}));\n/** Enum that controls the safety filter level for objectionable content. */ var SafetyFilterLevel;\n(function(SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(SafetyFilterLevel || (SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */ var PersonGeneration;\n(function(PersonGeneration) {\n    /**\n     * Block generation of images of people.\n     */ PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    /**\n     * Generate images of adults, but not children.\n     */ PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    /**\n     * Generate images that include adults and children.\n     */ PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(PersonGeneration || (PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */ var ImagePromptLanguage;\n(function(ImagePromptLanguage) {\n    /**\n     * Auto-detect the language.\n     */ ImagePromptLanguage[\"auto\"] = \"auto\";\n    /**\n     * English\n     */ ImagePromptLanguage[\"en\"] = \"en\";\n    /**\n     * Japanese\n     */ ImagePromptLanguage[\"ja\"] = \"ja\";\n    /**\n     * Korean\n     */ ImagePromptLanguage[\"ko\"] = \"ko\";\n    /**\n     * Hindi\n     */ ImagePromptLanguage[\"hi\"] = \"hi\";\n    /**\n     * Chinese\n     */ ImagePromptLanguage[\"zh\"] = \"zh\";\n    /**\n     * Portuguese\n     */ ImagePromptLanguage[\"pt\"] = \"pt\";\n    /**\n     * Spanish\n     */ ImagePromptLanguage[\"es\"] = \"es\";\n})(ImagePromptLanguage || (ImagePromptLanguage = {}));\n/** Enum representing the mask mode of a mask reference image. */ var MaskReferenceMode;\n(function(MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(MaskReferenceMode || (MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */ var ControlReferenceType;\n(function(ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(ControlReferenceType || (ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */ var SubjectReferenceType;\n(function(SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(SubjectReferenceType || (SubjectReferenceType = {}));\n/** Enum representing the editing mode. */ var EditMode;\n(function(EditMode) {\n    EditMode[\"EDIT_MODE_DEFAULT\"] = \"EDIT_MODE_DEFAULT\";\n    EditMode[\"EDIT_MODE_INPAINT_REMOVAL\"] = \"EDIT_MODE_INPAINT_REMOVAL\";\n    EditMode[\"EDIT_MODE_INPAINT_INSERTION\"] = \"EDIT_MODE_INPAINT_INSERTION\";\n    EditMode[\"EDIT_MODE_OUTPAINT\"] = \"EDIT_MODE_OUTPAINT\";\n    EditMode[\"EDIT_MODE_CONTROLLED_EDITING\"] = \"EDIT_MODE_CONTROLLED_EDITING\";\n    EditMode[\"EDIT_MODE_STYLE\"] = \"EDIT_MODE_STYLE\";\n    EditMode[\"EDIT_MODE_BGSWAP\"] = \"EDIT_MODE_BGSWAP\";\n    EditMode[\"EDIT_MODE_PRODUCT_IMAGE\"] = \"EDIT_MODE_PRODUCT_IMAGE\";\n})(EditMode || (EditMode = {}));\n/** Enum that represents the segmentation mode. */ var SegmentMode;\n(function(SegmentMode) {\n    SegmentMode[\"FOREGROUND\"] = \"FOREGROUND\";\n    SegmentMode[\"BACKGROUND\"] = \"BACKGROUND\";\n    SegmentMode[\"PROMPT\"] = \"PROMPT\";\n    SegmentMode[\"SEMANTIC\"] = \"SEMANTIC\";\n    SegmentMode[\"INTERACTIVE\"] = \"INTERACTIVE\";\n})(SegmentMode || (SegmentMode = {}));\n/** Enum for the reference type of a video generation reference image. */ var VideoGenerationReferenceType;\n(function(VideoGenerationReferenceType) {\n    /**\n     * A reference image that provides assets to the generated video,\n        such as the scene, an object, a character, etc.\n     */ VideoGenerationReferenceType[\"ASSET\"] = \"ASSET\";\n    /**\n     * A reference image that provides aesthetics including colors,\n        lighting, texture, etc., to be used as the style of the generated video,\n        such as 'anime', 'photography', 'origami', etc.\n     */ VideoGenerationReferenceType[\"STYLE\"] = \"STYLE\";\n})(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));\n/** Enum for the mask mode of a video generation mask. */ var VideoGenerationMaskMode;\n(function(VideoGenerationMaskMode) {\n    /**\n     * The image mask contains a masked rectangular region which is\n        applied on the first frame of the input video. The object described in\n        the prompt is inserted into this region and will appear in subsequent\n        frames.\n     */ VideoGenerationMaskMode[\"INSERT\"] = \"INSERT\";\n    /**\n     * The image mask is used to determine an object in the\n        first video frame to track. This object is removed from the video.\n     */ VideoGenerationMaskMode[\"REMOVE\"] = \"REMOVE\";\n    /**\n     * The image mask is used to determine a region in the\n        video. Objects in this region will be removed.\n     */ VideoGenerationMaskMode[\"REMOVE_STATIC\"] = \"REMOVE_STATIC\";\n    /**\n     * The image mask contains a masked rectangular region where\n        the input video will go. The remaining area will be generated. Video\n        masks are not supported.\n     */ VideoGenerationMaskMode[\"OUTPAINT\"] = \"OUTPAINT\";\n})(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));\n/** Enum that controls the compression quality of the generated videos. */ var VideoCompressionQuality;\n(function(VideoCompressionQuality) {\n    /**\n     * Optimized video compression quality. This will produce videos\n        with a compressed, smaller file size.\n     */ VideoCompressionQuality[\"OPTIMIZED\"] = \"OPTIMIZED\";\n    /**\n     * Lossless video compression quality. This will produce videos\n        with a larger file size.\n     */ VideoCompressionQuality[\"LOSSLESS\"] = \"LOSSLESS\";\n})(VideoCompressionQuality || (VideoCompressionQuality = {}));\n/** Enum representing the tuning method. */ var TuningMethod;\n(function(TuningMethod) {\n    /**\n     * Supervised fine tuning.\n     */ TuningMethod[\"SUPERVISED_FINE_TUNING\"] = \"SUPERVISED_FINE_TUNING\";\n    /**\n     * Preference optimization tuning.\n     */ TuningMethod[\"PREFERENCE_TUNING\"] = \"PREFERENCE_TUNING\";\n})(TuningMethod || (TuningMethod = {}));\n/** State for the lifecycle of a Document. */ var DocumentState;\n(function(DocumentState) {\n    DocumentState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    DocumentState[\"STATE_PENDING\"] = \"STATE_PENDING\";\n    DocumentState[\"STATE_ACTIVE\"] = \"STATE_ACTIVE\";\n    DocumentState[\"STATE_FAILED\"] = \"STATE_FAILED\";\n})(DocumentState || (DocumentState = {}));\n/** State for the lifecycle of a File. */ var FileState;\n(function(FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n/** Source of the File. */ var FileSource;\n(function(FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n    FileSource[\"REGISTERED\"] = \"REGISTERED\";\n})(FileSource || (FileSource = {}));\n/** The reason why the turn is complete. */ var TurnCompleteReason;\n(function(TurnCompleteReason) {\n    /**\n     * Default value. Reason is unspecified.\n     */ TurnCompleteReason[\"TURN_COMPLETE_REASON_UNSPECIFIED\"] = \"TURN_COMPLETE_REASON_UNSPECIFIED\";\n    /**\n     * The function call generated by the model is invalid.\n     */ TurnCompleteReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * The response is rejected by the model.\n     */ TurnCompleteReason[\"RESPONSE_REJECTED\"] = \"RESPONSE_REJECTED\";\n    /**\n     * Needs more input from the user.\n     */ TurnCompleteReason[\"NEED_MORE_INPUT\"] = \"NEED_MORE_INPUT\";\n})(TurnCompleteReason || (TurnCompleteReason = {}));\n/** Server content modalities. */ var MediaModality;\n(function(MediaModality) {\n    /**\n     * The modality is unspecified.\n     */ MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Plain text.\n     */ MediaModality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Images.\n     */ MediaModality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Video.\n     */ MediaModality[\"VIDEO\"] = \"VIDEO\";\n    /**\n     * Audio.\n     */ MediaModality[\"AUDIO\"] = \"AUDIO\";\n    /**\n     * Document, e.g. PDF.\n     */ MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(MediaModality || (MediaModality = {}));\n/** The type of the VAD signal. */ var VadSignalType;\n(function(VadSignalType) {\n    /**\n     * The default is VAD_SIGNAL_TYPE_UNSPECIFIED.\n     */ VadSignalType[\"VAD_SIGNAL_TYPE_UNSPECIFIED\"] = \"VAD_SIGNAL_TYPE_UNSPECIFIED\";\n    /**\n     * Start of sentence signal.\n     */ VadSignalType[\"VAD_SIGNAL_TYPE_SOS\"] = \"VAD_SIGNAL_TYPE_SOS\";\n    /**\n     * End of sentence signal.\n     */ VadSignalType[\"VAD_SIGNAL_TYPE_EOS\"] = \"VAD_SIGNAL_TYPE_EOS\";\n})(VadSignalType || (VadSignalType = {}));\n/** Start of speech sensitivity. */ var StartSensitivity;\n(function(StartSensitivity) {\n    /**\n     * The default is START_SENSITIVITY_LOW.\n     */ StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection will detect the start of speech more often.\n     */ StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection will detect the start of speech less often.\n     */ StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(StartSensitivity || (StartSensitivity = {}));\n/** End of speech sensitivity. */ var EndSensitivity;\n(function(EndSensitivity) {\n    /**\n     * The default is END_SENSITIVITY_LOW.\n     */ EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection ends speech more often.\n     */ EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection ends speech less often.\n     */ EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(EndSensitivity || (EndSensitivity = {}));\n/** The different ways of handling user activity. */ var ActivityHandling;\n(function(ActivityHandling) {\n    /**\n     * If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.\n     */ ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    /**\n     * If true, start of activity will interrupt the model's response (also called \"barge in\"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.\n     */ ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    /**\n     * The model's response will not be interrupted.\n     */ ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(ActivityHandling || (ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */ var TurnCoverage;\n(function(TurnCoverage) {\n    /**\n     * If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.\n     */ TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    /**\n     * The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.\n     */ TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    /**\n     * The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).\n     */ TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(TurnCoverage || (TurnCoverage = {}));\n/** Scale of the generated music. */ var Scale;\n(function(Scale) {\n    /**\n     * Default value. This value is unused.\n     */ Scale[\"SCALE_UNSPECIFIED\"] = \"SCALE_UNSPECIFIED\";\n    /**\n     * C major or A minor.\n     */ Scale[\"C_MAJOR_A_MINOR\"] = \"C_MAJOR_A_MINOR\";\n    /**\n     * Db major or Bb minor.\n     */ Scale[\"D_FLAT_MAJOR_B_FLAT_MINOR\"] = \"D_FLAT_MAJOR_B_FLAT_MINOR\";\n    /**\n     * D major or B minor.\n     */ Scale[\"D_MAJOR_B_MINOR\"] = \"D_MAJOR_B_MINOR\";\n    /**\n     * Eb major or C minor\n     */ Scale[\"E_FLAT_MAJOR_C_MINOR\"] = \"E_FLAT_MAJOR_C_MINOR\";\n    /**\n     * E major or Db minor.\n     */ Scale[\"E_MAJOR_D_FLAT_MINOR\"] = \"E_MAJOR_D_FLAT_MINOR\";\n    /**\n     * F major or D minor.\n     */ Scale[\"F_MAJOR_D_MINOR\"] = \"F_MAJOR_D_MINOR\";\n    /**\n     * Gb major or Eb minor.\n     */ Scale[\"G_FLAT_MAJOR_E_FLAT_MINOR\"] = \"G_FLAT_MAJOR_E_FLAT_MINOR\";\n    /**\n     * G major or E minor.\n     */ Scale[\"G_MAJOR_E_MINOR\"] = \"G_MAJOR_E_MINOR\";\n    /**\n     * Ab major or F minor.\n     */ Scale[\"A_FLAT_MAJOR_F_MINOR\"] = \"A_FLAT_MAJOR_F_MINOR\";\n    /**\n     * A major or Gb minor.\n     */ Scale[\"A_MAJOR_G_FLAT_MINOR\"] = \"A_MAJOR_G_FLAT_MINOR\";\n    /**\n     * Bb major or G minor.\n     */ Scale[\"B_FLAT_MAJOR_G_MINOR\"] = \"B_FLAT_MAJOR_G_MINOR\";\n    /**\n     * B major or Ab minor.\n     */ Scale[\"B_MAJOR_A_FLAT_MINOR\"] = \"B_MAJOR_A_FLAT_MINOR\";\n})(Scale || (Scale = {}));\n/** The mode of music generation. */ var MusicGenerationMode;\n(function(MusicGenerationMode) {\n    /**\n     * Rely on the server default generation mode.\n     */ MusicGenerationMode[\"MUSIC_GENERATION_MODE_UNSPECIFIED\"] = \"MUSIC_GENERATION_MODE_UNSPECIFIED\";\n    /**\n     * Steer text prompts to regions of latent space with higher quality\n        music.\n     */ MusicGenerationMode[\"QUALITY\"] = \"QUALITY\";\n    /**\n     * Steer text prompts to regions of latent space with a larger\n        diversity of music.\n     */ MusicGenerationMode[\"DIVERSITY\"] = \"DIVERSITY\";\n    /**\n     * Steer text prompts to regions of latent space more likely to\n        generate music with vocals.\n     */ MusicGenerationMode[\"VOCALIZATION\"] = \"VOCALIZATION\";\n})(MusicGenerationMode || (MusicGenerationMode = {}));\n/** The playback control signal to apply to the music generation. */ var LiveMusicPlaybackControl;\n(function(LiveMusicPlaybackControl) {\n    /**\n     * This value is unused.\n     */ LiveMusicPlaybackControl[\"PLAYBACK_CONTROL_UNSPECIFIED\"] = \"PLAYBACK_CONTROL_UNSPECIFIED\";\n    /**\n     * Start generating the music.\n     */ LiveMusicPlaybackControl[\"PLAY\"] = \"PLAY\";\n    /**\n     * Hold the music generation. Use PLAY to resume from the current position.\n     */ LiveMusicPlaybackControl[\"PAUSE\"] = \"PAUSE\";\n    /**\n     * Stop the music generation and reset the context (prompts retained).\n        Use PLAY to restart the music generation.\n     */ LiveMusicPlaybackControl[\"STOP\"] = \"STOP\";\n    /**\n     * Reset the context of the music generation without stopping it.\n        Retains the current prompts and config.\n     */ LiveMusicPlaybackControl[\"RESET_CONTEXT\"] = \"RESET_CONTEXT\";\n})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));\n/** Raw media bytes for function response.\n\nText should not be sent as raw bytes, use the FunctionResponse.response\nfield. */ class FunctionResponseBlob {\n}\n/** URI based data for function response. */ class FunctionResponseFileData {\n}\n/** A datatype containing media that is part of a `FunctionResponse` message.\n\nA `FunctionResponsePart` consists of data which has an associated datatype. A\n`FunctionResponsePart` can only contain one of the accepted types in\n`FunctionResponsePart.data`.\n\nA `FunctionResponsePart` must have a fixed IANA MIME type identifying the\ntype and subtype of the media if the `inline_data` field is filled with raw\nbytes. */ class FunctionResponsePart {\n}\n/**\n * Creates a `FunctionResponsePart` object from a `base64` encoded `string`.\n */ function createFunctionResponsePartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `FunctionResponsePart` object from a `URI` string.\n */ function createFunctionResponsePartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType\n        }\n    };\n}\n/** A function response. */ class FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */ function createPartFromUri(uri, mimeType, mediaResolution) {\n    return Object.assign({\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType\n        }\n    }, mediaResolution && {\n        mediaResolution: {\n            level: mediaResolution\n        }\n    });\n}\n/**\n * Creates a `Part` object from a `text` string.\n */ function createPartFromText(text) {\n    return {\n        text: text\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */ function createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */ function createPartFromFunctionResponse(id, name, response, parts = []) {\n    return {\n        functionResponse: Object.assign({\n            id: id,\n            name: name,\n            response: response\n        }, parts.length > 0 && {\n            parts\n        })\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */ function createPartFromBase64(data, mimeType, mediaResolution) {\n    return Object.assign({\n        inlineData: {\n            data: data,\n            mimeType: mimeType\n        }\n    }, mediaResolution && {\n        mediaResolution: {\n            level: mediaResolution\n        }\n    });\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */ function createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */ function createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language\n        }\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        return \"fileData\" in obj || \"text\" in obj || \"functionCall\" in obj || \"functionResponse\" in obj || \"inlineData\" in obj || \"videoMetadata\" in obj || \"codeExecutionResult\" in obj || \"executableCode\" in obj;\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === \"string\") {\n        parts.push(createPartFromText(partOrString));\n    } else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    } else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error(\"partOrString cannot be an empty array\");\n        }\n        for (const part of partOrString){\n            if (typeof part === \"string\") {\n                parts.push(createPartFromText(part));\n            } else if (_isPart(part)) {\n                parts.push(part);\n            } else {\n                throw new Error(\"element in PartUnion must be a Part object or string\");\n            }\n        }\n    } else {\n        throw new Error(\"partOrString must be a Part object, string, or array\");\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */ function createUserContent(partOrString) {\n    return {\n        role: \"user\",\n        parts: _toParts(partOrString)\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */ function createModelContent(partOrString) {\n    return {\n        role: \"model\",\n        parts: _toParts(partOrString)\n    };\n}\n/** A wrapper class for the http response. */ class HttpResponse {\n    constructor(response){\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()){\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n    json() {\n        return this.responseInternal.json();\n    }\n}\n/** Content filter results for a prompt sent in the request. Note: This is sent only in the first stream chunk and only if no candidates were generated due to content violations. */ class GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about the content generation request and response. This message provides a detailed breakdown of token usage and other relevant metrics. This data type is not supported in Gemini API. */ class GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */ class GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */ get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning text from the first one.\");\n        }\n        let text = \"\";\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && fieldName !== \"thoughtSignature\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning data from the first one.\");\n        }\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */ get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning function calls from the first one.\");\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.functionCall).map((part)=>part.functionCall).filter((functionCall)=>functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */ get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning executable code from the first one.\");\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.executableCode).map((part)=>part.executableCode).filter((executableCode)=>executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */ get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning code execution result from the first one.\");\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.codeExecutionResult).map((part)=>part.codeExecutionResult).filter((codeExecutionResult)=>codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */ class EmbedContentResponse {\n}\n/** The output images response. */ class GenerateImagesResponse {\n}\n/** Response for the request to edit an image. */ class EditImageResponse {\n}\nclass UpscaleImageResponse {\n}\n/** The output images response. */ class RecontextImageResponse {\n}\n/** The output images response. */ class SegmentImageResponse {\n}\nclass ListModelsResponse {\n}\nclass DeleteModelResponse {\n}\n/** Response for counting tokens. */ class CountTokensResponse {\n}\n/** Response for computing tokens. */ class ComputeTokensResponse {\n}\n/** Response with generated videos. */ class GenerateVideosResponse {\n}\n/** A video generation operation. */ class GenerateVideosOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse({ apiResponse, _isVertexAI }) {\n        const operation = new GenerateVideosOperation();\n        let response;\n        const op = apiResponse;\n        if (_isVertexAI) {\n            response = generateVideosOperationFromVertex$1(op);\n        } else {\n            response = generateVideosOperationFromMldev$1(op);\n        }\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list tuning jobs method. */ class ListTuningJobsResponse {\n}\n/** Empty response for tunings.cancel method. */ class CancelTuningJobResponse {\n}\n/** Empty response for caches.delete method. */ class DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Config for documents.list return value. */ class ListDocumentsResponse {\n}\n/** Config for file_search_stores.list return value. */ class ListFileSearchStoresResponse {\n}\n/** Response for the resumable upload method. */ class UploadToFileSearchStoreResumableResponse {\n}\n/** Response for ImportFile to import a File API file with a file search store. */ class ImportFileResponse {\n}\n/** Long-running operation for importing a file to a FileSearchStore. */ class ImportFileOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse({ apiResponse, _isVertexAI }) {\n        const operation = new ImportFileOperation();\n        const op = apiResponse;\n        const response = importFileOperationFromMldev$1(op);\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list files method. */ class ListFilesResponse {\n}\n/** Response for the create file method. */ class CreateFileResponse {\n}\n/** Response for the delete file method. */ class DeleteFileResponse {\n}\n/** Config for `inlined_responses` parameter. */ class InlinedResponse {\n}\n/** Config for `response` parameter. */ class SingleEmbedContentResponse {\n}\n/** Config for `inlined_embedding_responses` parameter. */ class InlinedEmbedContentResponse {\n}\n/** Config for batches.list return value. */ class ListBatchJobsResponse {\n}\n/** Represents a single response in a replay. */ class ReplayResponse {\n}\n/** A raw reference image.\n\nA raw reference image represents the base image to edit, provided by the user.\nIt can optionally be provided in addition to a mask reference image or\na style reference image. */ class RawReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_RAW\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId\n        };\n        return referenceImageAPI;\n    }\n}\n/** A mask reference image.\n\nThis encapsulates either a mask image provided by the user and configs for\nthe user provided mask, or only config parameters for the model to generate\na mask.\n\nA mask image is an image whose non-zero values indicate where to edit the base\nimage. If the user provides a mask image, the mask must be in the same\ndimensions as the raw image. */ class MaskReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_MASK\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            maskImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A control reference image.\n\nThe image of the control reference image is either a control image provided\nby the user, or a regular image which the backend will use to generate a\ncontrol image of. In the case of the latter, the\nenable_control_image_computation field in the config should be set to True.\n\nA control image is an image that represents a sketch image of areas for the\nmodel to fill in based on the prompt. */ class ControlReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_CONTROL\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            controlImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A style reference image.\n\nThis encapsulates a style reference image provided by the user, and\nadditionally optional config parameters for the style reference image.\n\nA raw reference image can also be provided as a destination for the style to\nbe applied to. */ class StyleReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_STYLE\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            styleImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A subject reference image.\n\nThis encapsulates a subject reference image provided by the user, and\nadditionally optional config parameters for the subject reference image.\n\nA raw reference image can also be provided as a destination for the subject to\nbe applied to. */ class SubjectReferenceImage {\n    /* Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_SUBJECT\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            subjectImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A content reference image.\n\nA content reference image represents a subject to reference (ex. person,\nproduct, animal) provided by the user. It can optionally be provided in\naddition to a style reference image (ex. background, style reference). */ class ContentReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_CONTENT\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId\n        };\n        return referenceImageAPI;\n    }\n}\n/** Response message for API call. */ class LiveServerMessage {\n    /**\n     * Returns the concatenation of all text parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     */ get text() {\n        var _a, _b, _c;\n        let text = \"\";\n        let anyTextPartFound = false;\n        const nonTextParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && fieldValue !== null) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartFound = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartFound ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c;\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && fieldValue !== null) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n}\n/** Client generated response to a `ToolCall` received from the server.\n\nIndividual `FunctionResponse` objects are matched to the respective\n`FunctionCall` objects by the `id` field.\n\nNote that in the unary and server-streaming GenerateContent APIs function\ncalling happens by exchanging the `Content` parts, while in the bidi\nGenerateContent APIs function calling happens over this dedicated set of\nmessages. */ class LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */ class LiveSendToolResponseParameters {\n    constructor(){\n        /** Tool responses to send to the session. */ this.functionResponses = [];\n    }\n}\n/** Response message for the LiveMusicClientMessage call. */ class LiveMusicServerMessage {\n    /**\n     * Returns the first audio chunk from the server content, if present.\n     *\n     * @remarks\n     * If there are no audio chunks in the response, undefined will be returned.\n     */ get audioChunk() {\n        if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {\n            return this.serverContent.audioChunks[0];\n        }\n        return undefined;\n    }\n}\n/** The response when long-running operation for uploading a file to a FileSearchStore complete. */ class UploadToFileSearchStoreResponse {\n}\n/** Long-running operation for uploading a file to a FileSearchStore. */ class UploadToFileSearchStoreOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse({ apiResponse, _isVertexAI }) {\n        const operation = new UploadToFileSearchStoreOperation();\n        const op = apiResponse;\n        const response = uploadToFileSearchStoreOperationFromMldev(op);\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tModel(apiClient, model) {\n    if (!model || typeof model !== \"string\") {\n        throw new Error(\"model is required and must be a string\");\n    }\n    if (model.includes(\"..\") || model.includes(\"?\") || model.includes(\"&\")) {\n        throw new Error(\"invalid model parameter\");\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith(\"publishers/\") || model.startsWith(\"projects/\") || model.startsWith(\"models/\")) {\n            return model;\n        } else if (model.indexOf(\"/\") >= 0) {\n            const parts = model.split(\"/\", 2);\n            return `publishers/${parts[0]}/models/${parts[1]}`;\n        } else {\n            return `publishers/google/models/${model}`;\n        }\n    } else {\n        if (model.startsWith(\"models/\") || model.startsWith(\"tunedModels/\")) {\n            return model;\n        } else {\n            return `models/${model}`;\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return \"\";\n    }\n    if (transformedModel.startsWith(\"publishers/\") && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;\n    } else if (transformedModel.startsWith(\"models/\") && apiClient.isVertexAI()) {\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;\n    } else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob)=>tBlob(blob));\n    } else {\n        return [\n            tBlob(blobs)\n        ];\n    }\n}\nfunction tBlob(blob) {\n    if (typeof blob === \"object\" && blob !== null) {\n        return blob;\n    }\n    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);\n}\nfunction tImageBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"image/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tAudioBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"audio/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tPart(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"PartUnion is required\");\n    }\n    if (typeof origin === \"object\") {\n        return origin;\n    }\n    if (typeof origin === \"string\") {\n        return {\n            text: origin\n        };\n    }\n    throw new Error(`Unsupported part type: ${typeof origin}`);\n}\nfunction tParts(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"PartListUnion is required\");\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tPart(item));\n    }\n    return [\n        tPart(origin)\n    ];\n}\nfunction _isContent(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"parts\" in origin && Array.isArray(origin.parts);\n}\nfunction _isFunctionCallPart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionCall\" in origin;\n}\nfunction _isFunctionResponsePart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionResponse\" in origin;\n}\nfunction tContent(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"ContentUnion is required\");\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: \"user\",\n        parts: tParts(origin)\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item)=>{\n            const content = tContent(item);\n            if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n                return [\n                    content.parts[0].text\n                ];\n            }\n            return [];\n        });\n    } else if (apiClient.isVertexAI()) {\n        const content = tContent(origin);\n        if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n            return [\n                content.parts[0].text\n            ];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tContent(item));\n    }\n    return [\n        tContent(origin)\n    ];\n}\nfunction tContents(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"contents are required\");\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them\");\n        }\n        return [\n            tContent(origin)\n        ];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin){\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error(\"Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them\");\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them\");\n        } else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({\n            role: \"user\",\n            parts: tParts(accumulatedParts)\n        });\n    }\n    return result;\n}\n/*\nTransform the type field from an array of types to an array of anyOf fields.\nExample:\n  {type: ['STRING', 'NUMBER']}\nwill be transformed to\n  {anyOf: [{type: 'STRING'}, {type: 'NUMBER'}]}\n*/ function flattenTypeArrayToAnyOf(typeList, resultingSchema) {\n    if (typeList.includes(\"null\")) {\n        resultingSchema[\"nullable\"] = true;\n    }\n    const listWithoutNull = typeList.filter((type)=>type !== \"null\");\n    if (listWithoutNull.length === 1) {\n        resultingSchema[\"type\"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;\n    } else {\n        resultingSchema[\"anyOf\"] = [];\n        for (const i of listWithoutNull){\n            resultingSchema[\"anyOf\"].push({\n                \"type\": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED\n            });\n        }\n    }\n}\nfunction processJsonSchema(_jsonSchema) {\n    const genAISchema = {};\n    const schemaFieldNames = [\n        \"items\"\n    ];\n    const listSchemaFieldNames = [\n        \"anyOf\"\n    ];\n    const dictSchemaFieldNames = [\n        \"properties\"\n    ];\n    if (_jsonSchema[\"type\"] && _jsonSchema[\"anyOf\"]) {\n        throw new Error(\"type and anyOf cannot be both populated.\");\n    }\n    /*\n    This is to handle the nullable array or object. The _jsonSchema will\n    be in the format of {anyOf: [{type: 'null'}, {type: 'object'}]}. The\n    logic is to check if anyOf has 2 elements and one of the element is null,\n    if so, the anyOf field is unnecessary, so we need to get rid of the anyOf\n    field and make the schema nullable. Then use the other element as the new\n    _jsonSchema for processing. This is because the backend doesn't have a null\n    type.\n    This has to be checked before we process any other fields.\n    For example:\n      const objectNullable = z.object({\n        nullableArray: z.array(z.string()).nullable(),\n      });\n    Will have the raw _jsonSchema as:\n    {\n      type: 'OBJECT',\n      properties: {\n          nullableArray: {\n             anyOf: [\n                {type: 'null'},\n                {\n                  type: 'array',\n                  items: {type: 'string'},\n                },\n              ],\n          }\n      },\n      required: [ 'nullableArray' ],\n    }\n    Will result in following schema compatible with Gemini API:\n      {\n        type: 'OBJECT',\n        properties: {\n           nullableArray: {\n              nullable: true,\n              type: 'ARRAY',\n              items: {type: 'string'},\n           }\n        },\n        required: [ 'nullableArray' ],\n      }\n    */ const incomingAnyOf = _jsonSchema[\"anyOf\"];\n    if (incomingAnyOf != null && incomingAnyOf.length == 2) {\n        if (incomingAnyOf[0][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[1];\n        } else if (incomingAnyOf[1][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[0];\n        }\n    }\n    if (_jsonSchema[\"type\"] instanceof Array) {\n        flattenTypeArrayToAnyOf(_jsonSchema[\"type\"], genAISchema);\n    }\n    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)){\n        // Skip if the fieldvalue is undefined or null.\n        if (fieldValue == null) {\n            continue;\n        }\n        if (fieldName == \"type\") {\n            if (fieldValue === \"null\") {\n                throw new Error(\"type: null can not be the only possible type for the field.\");\n            }\n            if (fieldValue instanceof Array) {\n                continue;\n            }\n            genAISchema[\"type\"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;\n        } else if (schemaFieldNames.includes(fieldName)) {\n            genAISchema[fieldName] = processJsonSchema(fieldValue);\n        } else if (listSchemaFieldNames.includes(fieldName)) {\n            const listSchemaFieldValue = [];\n            for (const item of fieldValue){\n                if (item[\"type\"] == \"null\") {\n                    genAISchema[\"nullable\"] = true;\n                    continue;\n                }\n                listSchemaFieldValue.push(processJsonSchema(item));\n            }\n            genAISchema[fieldName] = listSchemaFieldValue;\n        } else if (dictSchemaFieldNames.includes(fieldName)) {\n            const dictSchemaFieldValue = {};\n            for (const [key, value] of Object.entries(fieldValue)){\n                dictSchemaFieldValue[key] = processJsonSchema(value);\n            }\n            genAISchema[fieldName] = dictSchemaFieldValue;\n        } else {\n            // additionalProperties is not included in JSONSchema, skipping it.\n            if (fieldName === \"additionalProperties\") {\n                continue;\n            }\n            genAISchema[fieldName] = fieldValue;\n        }\n    }\n    return genAISchema;\n}\n// we take the unknown in the schema field because we want enable user to pass\n// the output of major schema declaration tools without casting. Tools such as\n// zodToJsonSchema, typebox, zodToJsonSchema function can return JsonSchema7Type\n// or object, see details in\n// https://github.com/StefanTerdell/zod-to-json-schema/blob/70525efe555cd226691e093d171370a3b10921d1/src/zodToJsonSchema.ts#L7\n// typebox can return unknown, see details in\n// https://github.com/sinclairzx81/typebox/blob/5a5431439f7d5ca6b494d0d18fbfd7b1a356d67c/src/type/create/type.ts#L35\n// Note: proper json schemas with the $schema field set never arrive to this\n// transformer. Schemas with $schema are routed to the equivalent API json\n// schema field.\nfunction tSchema(schema) {\n    return processJsonSchema(schema);\n}\nfunction tSpeechConfig(speechConfig) {\n    if (typeof speechConfig === \"object\") {\n        return speechConfig;\n    } else if (typeof speechConfig === \"string\") {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig\n                }\n            }\n        };\n    } else {\n        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);\n    }\n}\nfunction tLiveSpeechConfig(speechConfig) {\n    if (\"multiSpeakerVoiceConfig\" in speechConfig) {\n        throw new Error(\"multiSpeakerVoiceConfig is not supported in the live API.\");\n    }\n    return speechConfig;\n}\nfunction tTool(tool) {\n    if (tool.functionDeclarations) {\n        for (const functionDeclaration of tool.functionDeclarations){\n            if (functionDeclaration.parameters) {\n                if (!Object.keys(functionDeclaration.parameters).includes(\"$schema\")) {\n                    functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);\n                } else {\n                    if (!functionDeclaration.parametersJsonSchema) {\n                        functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;\n                        delete functionDeclaration.parameters;\n                    }\n                }\n            }\n            if (functionDeclaration.response) {\n                if (!Object.keys(functionDeclaration.response).includes(\"$schema\")) {\n                    functionDeclaration.response = processJsonSchema(functionDeclaration.response);\n                } else {\n                    if (!functionDeclaration.responseJsonSchema) {\n                        functionDeclaration.responseJsonSchema = functionDeclaration.response;\n                        delete functionDeclaration.response;\n                    }\n                }\n            }\n        }\n    }\n    return tool;\n}\nfunction tTools(tools) {\n    // Check if the incoming type is defined.\n    if (tools === undefined || tools === null) {\n        throw new Error(\"tools is required\");\n    }\n    if (!Array.isArray(tools)) {\n        throw new Error(\"tools is required and must be an array of Tools\");\n    }\n    const result = [];\n    for (const tool of tools){\n        result.push(tool);\n    }\n    return result;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */ function resourceName(client, resourceName, resourcePrefix, splitsAfterPrefix = 1) {\n    const shouldAppendPrefix = !resourceName.startsWith(`${resourcePrefix}/`) && resourceName.split(\"/\").length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith(\"projects/\")) {\n            return resourceName;\n        } else if (resourceName.startsWith(\"locations/\")) {\n            return `projects/${client.getProject()}/${resourceName}`;\n        } else if (resourceName.startsWith(`${resourcePrefix}/`)) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName}`;\n        } else if (shouldAppendPrefix) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName}`;\n        } else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return `${resourcePrefix}/${resourceName}`;\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== \"string\") {\n        throw new Error(\"name must be a string\");\n    }\n    return resourceName(apiClient, name, \"cachedContents\");\n}\nfunction tTuningJobStatus(status) {\n    switch(status){\n        case \"STATE_UNSPECIFIED\":\n            return \"JOB_STATE_UNSPECIFIED\";\n        case \"CREATING\":\n            return \"JOB_STATE_RUNNING\";\n        case \"ACTIVE\":\n            return \"JOB_STATE_SUCCEEDED\";\n        case \"FAILED\":\n            return \"JOB_STATE_FAILED\";\n        default:\n            return status;\n    }\n}\nfunction tBytes(fromImageBytes) {\n    return tBytes$1(fromImageBytes);\n}\nfunction _isFile(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"name\" in origin;\n}\nfunction isGeneratedVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"video\" in origin;\n}\nfunction isVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"uri\" in origin;\n}\nfunction tFileName(fromName) {\n    var _a;\n    let name;\n    if (_isFile(fromName)) {\n        name = fromName.name;\n    }\n    if (isVideo(fromName)) {\n        name = fromName.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (isGeneratedVideo(fromName)) {\n        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (typeof fromName === \"string\") {\n        name = fromName;\n    }\n    if (name === undefined) {\n        throw new Error(\"Could not extract file name from the provided input.\");\n    }\n    if (name.startsWith(\"https://\")) {\n        const suffix = name.split(\"files/\")[1];\n        const match = suffix.match(/[a-z0-9]+/);\n        if (match === null) {\n            throw new Error(`Could not extract file name from URI ${name}`);\n        }\n        name = match[0];\n    } else if (name.startsWith(\"files/\")) {\n        name = name.split(\"files/\")[1];\n    }\n    return name;\n}\nfunction tModelsUrl(apiClient, baseModels) {\n    let res;\n    if (apiClient.isVertexAI()) {\n        res = baseModels ? \"publishers/google/models\" : \"models\";\n    } else {\n        res = baseModels ? \"models\" : \"tunedModels\";\n    }\n    return res;\n}\nfunction tExtractModels(response) {\n    for (const key of [\n        \"models\",\n        \"tunedModels\",\n        \"publisherModels\"\n    ]){\n        if (hasField(response, key)) {\n            return response[key];\n        }\n    }\n    return [];\n}\nfunction hasField(data, fieldName) {\n    return data !== null && typeof data === \"object\" && fieldName in data;\n}\nfunction mcpToGeminiTool(mcpTool, config = {}) {\n    const mcpToolSchema = mcpTool;\n    const functionDeclaration = {\n        name: mcpToolSchema[\"name\"],\n        description: mcpToolSchema[\"description\"],\n        parametersJsonSchema: mcpToolSchema[\"inputSchema\"]\n    };\n    if (mcpToolSchema[\"outputSchema\"]) {\n        functionDeclaration[\"responseJsonSchema\"] = mcpToolSchema[\"outputSchema\"];\n    }\n    if (config.behavior) {\n        functionDeclaration[\"behavior\"] = config.behavior;\n    }\n    const geminiTool = {\n        functionDeclarations: [\n            functionDeclaration\n        ]\n    };\n    return geminiTool;\n}\n/**\n * Converts a list of MCP tools to a single Gemini tool with a list of function\n * declarations.\n */ function mcpToolsToGeminiTool(mcpTools, config = {}) {\n    const functionDeclarations = [];\n    const toolNames = new Set();\n    for (const mcpTool of mcpTools){\n        const mcpToolName = mcpTool.name;\n        if (toolNames.has(mcpToolName)) {\n            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n        }\n        toolNames.add(mcpToolName);\n        const geminiTool = mcpToGeminiTool(mcpTool, config);\n        if (geminiTool.functionDeclarations) {\n            functionDeclarations.push(...geminiTool.functionDeclarations);\n        }\n    }\n    return {\n        functionDeclarations: functionDeclarations\n    };\n}\n// Transforms a source input into a BatchJobSource object with validation.\nfunction tBatchJobSource(client, src) {\n    let sourceObj;\n    if (typeof src === \"string\") {\n        if (client.isVertexAI()) {\n            if (src.startsWith(\"gs://\")) {\n                sourceObj = {\n                    format: \"jsonl\",\n                    gcsUri: [\n                        src\n                    ]\n                };\n            } else if (src.startsWith(\"bq://\")) {\n                sourceObj = {\n                    format: \"bigquery\",\n                    bigqueryUri: src\n                };\n            } else {\n                throw new Error(`Unsupported string source for Vertex AI: ${src}`);\n            }\n        } else {\n            // MLDEV\n            if (src.startsWith(\"files/\")) {\n                sourceObj = {\n                    fileName: src\n                }; // Default to fileName for string input\n            } else {\n                throw new Error(`Unsupported string source for Gemini API: ${src}`);\n            }\n        }\n    } else if (Array.isArray(src)) {\n        if (client.isVertexAI()) {\n            throw new Error(\"InlinedRequest[] is not supported in Vertex AI.\");\n        }\n        sourceObj = {\n            inlinedRequests: src\n        };\n    } else {\n        // It's already a BatchJobSource object\n        sourceObj = src;\n    }\n    // Validation logic\n    const vertexSourcesCount = [\n        sourceObj.gcsUri,\n        sourceObj.bigqueryUri\n    ].filter(Boolean).length;\n    const mldevSourcesCount = [\n        sourceObj.inlinedRequests,\n        sourceObj.fileName\n    ].filter(Boolean).length;\n    if (client.isVertexAI()) {\n        if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {\n            throw new Error(\"Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.\");\n        }\n    } else {\n        // MLDEV\n        if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {\n            throw new Error(\"Exactly one of `inlinedRequests`, `fileName`, \" + \"must be set for Gemini API.\");\n        }\n    }\n    return sourceObj;\n}\nfunction tBatchJobDestination(dest) {\n    if (typeof dest !== \"string\") {\n        return dest;\n    }\n    const destString = dest;\n    if (destString.startsWith(\"gs://\")) {\n        return {\n            format: \"jsonl\",\n            gcsUri: destString\n        };\n    } else if (destString.startsWith(\"bq://\")) {\n        return {\n            format: \"bigquery\",\n            bigqueryUri: destString\n        };\n    } else {\n        throw new Error(`Unsupported destination: ${destString}`);\n    }\n}\nfunction tRecvBatchJobDestination(dest) {\n    // Ensure dest is a non-null object before proceeding.\n    if (typeof dest !== \"object\" || dest === null) {\n        // If the input is not an object, it cannot be a valid BatchJobDestination\n        // based on the operations performed. Return it cast, or handle as an error.\n        // Casting an empty object might be a safe default.\n        return {};\n    }\n    // Cast to Record<string, unknown> to allow string property access.\n    const obj = dest;\n    // Safely access nested properties.\n    const inlineResponsesVal = obj[\"inlinedResponses\"];\n    if (typeof inlineResponsesVal !== \"object\" || inlineResponsesVal === null) {\n        return dest;\n    }\n    const inlineResponsesObj = inlineResponsesVal;\n    const responsesArray = inlineResponsesObj[\"inlinedResponses\"];\n    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {\n        return dest;\n    }\n    // Check if any response has the 'embedding' property.\n    let hasEmbedding = false;\n    for (const responseItem of responsesArray){\n        if (typeof responseItem !== \"object\" || responseItem === null) {\n            continue;\n        }\n        const responseItemObj = responseItem;\n        const responseVal = responseItemObj[\"response\"];\n        if (typeof responseVal !== \"object\" || responseVal === null) {\n            continue;\n        }\n        const responseObj = responseVal;\n        // Check for the existence of the 'embedding' key.\n        if (responseObj[\"embedding\"] !== undefined) {\n            hasEmbedding = true;\n            break;\n        }\n    }\n    // Perform the transformation if an embedding was found.\n    if (hasEmbedding) {\n        obj[\"inlinedEmbedContentResponses\"] = obj[\"inlinedResponses\"];\n        delete obj[\"inlinedResponses\"];\n    }\n    // Cast the (potentially) modified object to the target type.\n    return dest;\n}\nfunction tBatchJobName(apiClient, name) {\n    const nameString = name;\n    if (!apiClient.isVertexAI()) {\n        const mldevPattern = /batches\\/[^/]+$/;\n        if (mldevPattern.test(nameString)) {\n            return nameString.split(\"/\").pop();\n        } else {\n            throw new Error(`Invalid batch job name: ${nameString}.`);\n        }\n    }\n    const vertexPattern = /^projects\\/[^/]+\\/locations\\/[^/]+\\/batchPredictionJobs\\/[^/]+$/;\n    if (vertexPattern.test(nameString)) {\n        return nameString.split(\"/\").pop();\n    } else if (/^\\d+$/.test(nameString)) {\n        return nameString;\n    } else {\n        throw new Error(`Invalid batch job name: ${nameString}.`);\n    }\n}\nfunction tJobState(state) {\n    const stateString = state;\n    if (stateString === \"BATCH_STATE_UNSPECIFIED\") {\n        return \"JOB_STATE_UNSPECIFIED\";\n    } else if (stateString === \"BATCH_STATE_PENDING\") {\n        return \"JOB_STATE_PENDING\";\n    } else if (stateString === \"BATCH_STATE_RUNNING\") {\n        return \"JOB_STATE_RUNNING\";\n    } else if (stateString === \"BATCH_STATE_SUCCEEDED\") {\n        return \"JOB_STATE_SUCCEEDED\";\n    } else if (stateString === \"BATCH_STATE_FAILED\") {\n        return \"JOB_STATE_FAILED\";\n    } else if (stateString === \"BATCH_STATE_CANCELLED\") {\n        return \"JOB_STATE_CANCELLED\";\n    } else if (stateString === \"BATCH_STATE_EXPIRED\") {\n        return \"JOB_STATE_EXPIRED\";\n    } else {\n        return stateString;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function batchJobDestinationFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, [\n        \"responsesFile\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedResponses = getValueByPath(fromObject, [\n        \"inlinedResponses\",\n        \"inlinedResponses\"\n    ]);\n    if (fromInlinedResponses != null) {\n        let transformedList = fromInlinedResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"inlinedResponses\"\n        ], transformedList);\n    }\n    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [\n        \"inlinedEmbedContentResponses\",\n        \"inlinedResponses\"\n    ]);\n    if (fromInlinedEmbedContentResponses != null) {\n        let transformedList = fromInlinedEmbedContentResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"inlinedEmbedContentResponses\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"predictionsFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsDestination\",\n        \"outputUriPrefix\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryDestination\",\n        \"outputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobDestinationToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"predictionsFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsDestination\",\n            \"outputUriPrefix\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryDestination\",\n            \"outputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedResponses\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedResponses parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedEmbedContentResponses\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedEmbedContentResponses parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction batchJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"metadata\",\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"metadata\",\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"metadata\",\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"metadata\",\n        \"output\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"inputConfig\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"src\"\n        ], batchJobSourceFromVertex(fromSrc));\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"outputConfig\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));\n    }\n    const fromCompletionStats = getValueByPath(fromObject, [\n        \"completionStats\"\n    ]);\n    if (fromCompletionStats != null) {\n        setValueByPath(toObject, [\n            \"completionStats\"\n        ], fromCompletionStats);\n    }\n    return toObject;\n}\nfunction batchJobSourceFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"instancesFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsSource\",\n        \"uris\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigquerySource\",\n        \"inputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"format\"\n    ]) !== undefined) {\n        throw new Error(\"format parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]) !== undefined) {\n        throw new Error(\"bigqueryUri parameter is not supported in Gemini API.\");\n    }\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]);\n    if (fromInlinedRequests != null) {\n        let transformedList = fromInlinedRequests;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedRequestToMldev(apiClient, item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests\",\n            \"requests\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobSourceToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"instancesFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsSource\",\n            \"uris\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigquerySource\",\n            \"inputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedRequests parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction blobToMldev$4(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction candidateFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev$1(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"citations\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction contentToMldev$4(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"batch\",\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"dest\"\n    ]) !== undefined) {\n        throw new Error(\"dest parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"dest\"\n    ]);\n    if (parentObject !== undefined && fromDest != null) {\n        setValueByPath(parentObject, [\n            \"outputConfig\"\n        ], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"batch\",\n            \"inputConfig\"\n        ], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"inputConfig\"\n        ], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createBatchJobConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"batch\",\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"batch\",\n            \"inputConfig\"\n        ], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction embedContentBatchToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"request\",\n            \"content\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"_self\"\n        ], embedContentConfigToMldev$1(fromConfig, toObject));\n        moveValueByPath(toObject, {\n            \"requests[].*\": \"requests[].request.*\"\n        });\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embeddingsBatchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"file_name\"\n        ], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]);\n    if (fromInlinedRequests != null) {\n        setValueByPath(toObject, [\n            \"requests\"\n        ], embedContentBatchToMldev(apiClient, fromInlinedRequests));\n    }\n    return toObject;\n}\nfunction fileDataToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$4(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    if (getValueByPath(fromObject, [\n        \"streamFunctionCallArguments\"\n    ]) !== undefined) {\n        throw new Error(\"streamFunctionCallArguments parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$4(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev$1(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$4(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$2(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToMldev$1(fromImageConfig));\n    }\n    const fromEnableEnhancedCivicAnswers = getValueByPath(fromObject, [\n        \"enableEnhancedCivicAnswers\"\n    ]);\n    if (fromEnableEnhancedCivicAnswers != null) {\n        setValueByPath(toObject, [\n            \"enableEnhancedCivicAnswers\"\n        ], fromEnableEnhancedCivicAnswers);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, [\n            \"imageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]) !== undefined) {\n        throw new Error(\"personGeneration parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]) !== undefined) {\n        throw new Error(\"outputMimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"outputCompressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction inlinedRequestToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"request\",\n            \"contents\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"generationConfig\"\n        ], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, [\n            \"request\"\n        ], {})));\n    }\n    return toObject;\n}\nfunction inlinedResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateContentResponseFromMldev$1(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    if (getValueByPath(fromObject, [\n        \"filter\"\n    ]) !== undefined) {\n        throw new Error(\"filter parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listBatchJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listBatchJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"operations\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"batchPredictionJobs\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$4(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$4(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$4(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$4(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev$1(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], fromRetrievalConfig);\n    }\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$2(fromFunctionCallingConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$4(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$4(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ var PagedItem;\n(function(PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n    PagedItem[\"PAGED_ITEM_FILE_SEARCH_STORES\"] = \"fileSearchStores\";\n    PagedItem[\"PAGED_ITEM_DOCUMENTS\"] = \"documents\";\n})(PagedItem || (PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */ class Pager {\n    constructor(name, request, response, params){\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;\n        this.idxInternal = 0;\n        let requestParams = {\n            config: {}\n        };\n        if (!params || Object.keys(params).length === 0) {\n            requestParams = {\n                config: {}\n            };\n        } else if (typeof params === \"object\") {\n            requestParams = Object.assign({}, params);\n        } else {\n            requestParams = params;\n        }\n        if (requestParams[\"config\"]) {\n            requestParams[\"config\"][\"pageToken\"] = response[\"nextPageToken\"];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize = (_b = (_a = requestParams[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageSize\"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */ get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */ get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */ get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the headers of the API response.\n     */ get sdkHttpResponse() {\n        return this.sdkHttpResponseInternal;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */ get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */ get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */ getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */ [Symbol.asyncIterator]() {\n        return {\n            next: async ()=>{\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    } else {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return {\n                    value: item,\n                    done: false\n                };\n            },\n            return: async ()=>{\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */ async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error(\"No more pages to fetch.\");\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */ hasNextPage() {\n        var _a;\n        if (((_a = this.params[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageToken\"]) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Batches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists batch jobs.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of batch jobs.\n         *\n         * @example\n         * ```ts\n         * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});\n         * for await (const batchJob of batchJobs) {\n         *   console.log(batchJob);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Create batch job.\n         *\n         * @param params - The parameters for create batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.create({\n         *   model: 'gemini-2.0-flash',\n         *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},\n         *   config: {\n         *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.create = async (params)=>{\n            if (this.apiClient.isVertexAI()) {\n                // Format destination if not provided\n                // Cast params.src as Vertex AI path does not handle InlinedRequest[]\n                params.config = this.formatDestination(params.src, params.config);\n            }\n            return this.createInternal(params);\n        };\n        /**\n         * **Experimental** Creates an embedding batch job.\n         *\n         * @param params - The parameters for create embedding batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.createEmbeddings({\n         *   model: 'text-embedding-004',\n         *   src: {fileName: 'files/my_embedding_input'},\n         * });\n         * console.log(response);\n         * ```\n         */ this.createEmbeddings = async (params)=>{\n            console.warn(\"batches.createEmbeddings() is experimental and may change without notice.\");\n            if (this.apiClient.isVertexAI()) {\n                throw new Error(\"Vertex AI does not support batches.createEmbeddings.\");\n            }\n            return this.createEmbeddingsInternal(params);\n        };\n    }\n    // Helper function to handle inlined generate content requests\n    createInlinedGenerateContentRequest(params) {\n        const body = createBatchJobParametersToMldev(this.apiClient, params);\n        const urlParams = body[\"_url\"];\n        const path = formatMap(\"{model}:batchGenerateContent\", urlParams);\n        const batch = body[\"batch\"];\n        const inputConfig = batch[\"inputConfig\"];\n        const requestsWrapper = inputConfig[\"requests\"];\n        const requests = requestsWrapper[\"requests\"];\n        const newRequests = [];\n        for (const request of requests){\n            const requestDict = Object.assign({}, request); // Clone\n            if (requestDict[\"systemInstruction\"]) {\n                const systemInstructionValue = requestDict[\"systemInstruction\"];\n                delete requestDict[\"systemInstruction\"];\n                const requestContent = requestDict[\"request\"];\n                requestContent[\"systemInstruction\"] = systemInstructionValue;\n                requestDict[\"request\"] = requestContent;\n            }\n            newRequests.push(requestDict);\n        }\n        requestsWrapper[\"requests\"] = newRequests;\n        delete body[\"config\"];\n        delete body[\"_url\"];\n        delete body[\"_query\"];\n        return {\n            path,\n            body\n        };\n    }\n    // Helper function to get the first GCS URI\n    getGcsUri(src) {\n        if (typeof src === \"string\") {\n            return src.startsWith(\"gs://\") ? src : undefined;\n        }\n        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {\n            return src.gcsUri[0];\n        }\n        return undefined;\n    }\n    // Helper function to get the BigQuery URI\n    getBigqueryUri(src) {\n        if (typeof src === \"string\") {\n            return src.startsWith(\"bq://\") ? src : undefined;\n        }\n        if (!Array.isArray(src)) {\n            return src.bigqueryUri;\n        }\n        return undefined;\n    }\n    // Function to format the destination configuration for Vertex AI\n    formatDestination(src, config) {\n        const newConfig = config ? Object.assign({}, config) : {};\n        const timestampStr = Date.now().toString();\n        if (!newConfig.displayName) {\n            newConfig.displayName = `genaiBatchJob_${timestampStr}`;\n        }\n        if (newConfig.dest === undefined) {\n            const gcsUri = this.getGcsUri(src);\n            const bigqueryUri = this.getBigqueryUri(src);\n            if (gcsUri) {\n                if (gcsUri.endsWith(\".jsonl\")) {\n                    // For .jsonl files, remove suffix and add /dest\n                    newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;\n                } else {\n                    // Fallback for other GCS URIs\n                    newConfig.dest = `${gcsUri}_dest_${timestampStr}`;\n                }\n            } else if (bigqueryUri) {\n                newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;\n            } else {\n                throw new Error(\"Unsupported source for Vertex AI: No GCS or BigQuery URI found.\");\n            }\n        }\n        return newConfig;\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */ async createInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = createBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchGenerateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */ async createEmbeddingsInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:asyncBatchEmbedContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets batch job configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The batch job.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Cancels a batch job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        } else {\n            const body = cancelBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listBatchJobsParametersToVertex(params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listBatchJobsParametersToMldev(params);\n            path = formatMap(\"batches\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Deletes a batch job.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteResourceJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = deleteBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteResourceJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev$3(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$3(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$3(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$1(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]) !== undefined) {\n        throw new Error(\"kmsKeyName parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], fromToolConfig);\n    }\n    const fromKmsKeyName = getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]);\n    if (parentObject !== undefined && fromKmsKeyName != null) {\n        setValueByPath(parentObject, [\n            \"encryption_spec\",\n            \"kmsKeyName\"\n        ], fromKmsKeyName);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$3(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    if (getValueByPath(fromObject, [\n        \"streamFunctionCallArguments\"\n    ]) !== undefined) {\n        throw new Error(\"streamFunctionCallArguments parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listCachedContentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listCachedContentsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$3(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$3(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$3(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$3(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], fromRetrievalConfig);\n    }\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$1(fromFunctionCallingConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$3(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$3(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$2(fromObject) {\n    const toObject = {};\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]) !== undefined) {\n        throw new Error(\"fileSearch parameter is not supported in Vertex AI.\");\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], fromEnterpriseWebSearch);\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], fromGoogleSearch);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Caches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists cached contents.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for await (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-2.0-flash-001',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */ async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        } else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        } else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteCachedContentResponseFromVertex(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteCachedContentResponseFromMldev(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: '...',  // The server-generated resource name.\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        } else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromVertex(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listCachedContentsParametersToMldev(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromMldev(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns true if the response is valid, false otherwise.\n */ function isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts){\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */ function validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    for (const content of history){\n        if (content.role !== \"user\" && content.role !== \"model\") {\n            throw new Error(`Role must be user or model, but got ${content.role}.`);\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */ function extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    while(i < length){\n        if (comprehensiveHistory[i].role === \"user\") {\n            curatedHistory.push(comprehensiveHistory[i]);\n            i++;\n        } else {\n            const modelOutput = [];\n            let isValid = true;\n            while(i < length && comprehensiveHistory[i].role === \"model\"){\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(...modelOutput);\n            } else {\n                // Remove the last user input when model content is invalid.\n                curatedHistory.pop();\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */ class Chats {\n    constructor(modelsModule, apiClient){\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */ create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        structuredClone(params.history));\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */ class Chat {\n    constructor(apiClient, modelsModule, model, config = {}, history = []){\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */ async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        this.sendPromise = (async ()=>{\n            var _a, _b, _c;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            // Because the AFC input contains the entire curated chat history in\n            // addition to the new user input, we need to truncate the AFC history\n            // to deduplicate the existing chat history.\n            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;\n            const index = this.getHistory(true).length;\n            let automaticFunctionCallingHistory = [];\n            if (fullAutomaticFunctionCallingHistory != null) {\n                automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];\n            }\n            const modelOutput = outputContent ? [\n                outputContent\n            ] : [];\n            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);\n            return;\n        })();\n        await this.sendPromise.catch(()=>{\n            // Resets sendPromise to avoid subsequent calls failing\n            this.sendPromise = Promise.resolve();\n        });\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */ async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        // Resolve the internal tracking of send completion promise - `sendPromise`\n        // for both success and failure response. The actual failure is still\n        // propagated by the `await streamResponse`.\n        this.sendPromise = streamResponse.then(()=>undefined).catch(()=>undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */ getHistory(curated = false) {\n        const history = curated ? extractCuratedHistory(this.history) : this.history;\n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        return structuredClone(history);\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _a, e_1, _b, _c;\n            var _d, _e;\n            const outputContent = [];\n            try {\n                for(var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _a = streamResponse_1_1.done, !_a; _f = true){\n                    _c = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _c;\n                    if (isValidResponse(chunk)) {\n                        const content = (_e = (_d = chunk.candidates) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_f && !_a && (_b = streamResponse_1.return)) yield __await(_b.call(streamResponse_1));\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {\n        let outputContents = [];\n        if (modelOutput.length > 0 && modelOutput.every((content)=>content.role !== undefined)) {\n            outputContents = modelOutput;\n        } else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: \"model\",\n                parts: []\n            });\n        }\n        if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {\n            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));\n        } else {\n            this.history.push(userInput);\n        }\n        this.history.push(...outputContents);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * API errors raised by the GenAI API.\n */ class ApiError extends Error {\n    constructor(options){\n        super(options.message);\n        this.name = \"ApiError\";\n        this.status = options.status;\n        Object.setPrototypeOf(this, ApiError.prototype);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, [\n        \"file\"\n    ]);\n    if (fromFile != null) {\n        setValueByPath(toObject, [\n            \"file\"\n        ], fromFile);\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction deleteFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction listFilesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listFilesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, [\n        \"files\"\n    ]);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"files\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Files extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists files.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of files.\n         *\n         * @example\n         * ```ts\n         * const files = await ai.files.list({config: {'pageSize': 2}});\n         * for await (const file of files) {\n         *   console.log(file);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_FILES, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */ async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Vertex AI does not support uploading files. You can share files through a GCS bucket.\");\n        }\n        return this.apiClient.uploadFile(params.file, params.config).then((resp)=>{\n            return resp;\n        });\n    }\n    /**\n     * Downloads a remotely stored file asynchronously to a location specified in\n     * the `params` object. This method only works on Node environment, to\n     * download files in the browser, use a browser compliant method like an <a>\n     * tag.\n     *\n     * @param params - The parameters for the download request.\n     *\n     * @example\n     * The following code downloads an example file named \"files/mehozpxf877d\" as\n     * \"file.txt\".\n     *\n     * ```ts\n     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});\n     * ```\n     */ async download(params) {\n        await this.apiClient.downloadFile(params);\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listFilesParametersToMldev(params);\n            path = formatMap(\"files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listFilesResponseFromMldev(apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createFileParametersToMldev(params);\n            path = formatMap(\"upload/v1beta/files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = createFileResponseFromMldev(apiResponse);\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */ async delete(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteFileResponseFromMldev(apiResponse);\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev$2(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction generationConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], fromModelSelectionConfig);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, [\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], fromSpeechConfig);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    if (getValueByPath(fromObject, [\n        \"enableEnhancedCivicAnswers\"\n    ]) !== undefined) {\n        throw new Error(\"enableEnhancedCivicAnswers parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$2(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev$1(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], fromProactivity);\n    }\n    if (getValueByPath(fromObject, [\n        \"explicitVadSignal\"\n    ]) !== undefined) {\n        throw new Error(\"explicitVadSignal parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], generationConfigToVertex$1(fromGenerationConfig));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], fromSessionResumption);\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], fromProactivity);\n    }\n    const fromExplicitVadSignal = getValueByPath(fromObject, [\n        \"explicitVadSignal\"\n    ]);\n    if (parentObject !== undefined && fromExplicitVadSignal != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"explicitVadSignal\"\n        ], fromExplicitVadSignal);\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveMusicSetConfigParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], fromMusicGenerationConfig);\n    }\n    return toObject;\n}\nfunction liveMusicSetWeightedPromptsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return blobToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], blobToMldev$2(tAudioBlob(fromAudio)));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], blobToMldev$2(tImageBlob(fromVideo)));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], fromSetupComplete);\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], fromServerContent);\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], fromToolCall);\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], fromToolCallCancellation);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromVertex(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], fromGoAway);\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], fromSessionResumptionUpdate);\n    }\n    const fromVoiceActivityDetectionSignal = getValueByPath(fromObject, [\n        \"voiceActivityDetectionSignal\"\n    ]);\n    if (fromVoiceActivityDetectionSignal != null) {\n        setValueByPath(toObject, [\n            \"voiceActivityDetectionSignal\"\n        ], fromVoiceActivityDetectionSignal);\n    }\n    return toObject;\n}\nfunction partToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$2(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$2(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$2(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction toolToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$2(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$2(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(fromObject) {\n    const toObject = {};\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]) !== undefined) {\n        throw new Error(\"fileSearch parameter is not supported in Vertex AI.\");\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], fromEnterpriseWebSearch);\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], fromGoogleSearch);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"candidatesTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"promptTokensDetails\"\n        ], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"cacheTokensDetails\"\n        ], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"candidatesTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"responseTokensDetails\"\n        ], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"toolUsePromptTokensDetails\"\n        ], transformedList);\n    }\n    const fromTrafficType = getValueByPath(fromObject, [\n        \"trafficType\"\n    ]);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, [\n            \"trafficType\"\n        ], fromTrafficType);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev$1(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"citations\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTokensInfo = getValueByPath(fromObject, [\n        \"tokensInfo\"\n    ]);\n    if (fromTokensInfo != null) {\n        let transformedList = fromTokensInfo;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"tokensInfo\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, [\n        \"statistics\"\n    ]);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, [\n            \"statistics\"\n        ], contentEmbeddingStatisticsFromVertex(fromStatistics));\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(fromObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, [\n        \"truncated\"\n    ]);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, [\n            \"truncated\"\n        ], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"token_count\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction controlReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromControlType = getValueByPath(fromObject, [\n        \"controlType\"\n    ]);\n    if (fromControlType != null) {\n        setValueByPath(toObject, [\n            \"controlType\"\n        ], fromControlType);\n    }\n    const fromEnableControlImageComputation = getValueByPath(fromObject, [\n        \"enableControlImageComputation\"\n    ]);\n    if (fromEnableControlImageComputation != null) {\n        setValueByPath(toObject, [\n            \"computeControl\"\n        ], fromEnableControlImageComputation);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]) !== undefined) {\n        throw new Error(\"systemInstruction parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"tools\"\n    ]) !== undefined) {\n        throw new Error(\"tools parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]) !== undefined) {\n        throw new Error(\"generationConfig parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"generationConfig\"\n        ], generationConfigToVertex(fromGenerationConfig));\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        countTokensConfigToMldev(fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        countTokensConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction deleteModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction editImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromEditMode = getValueByPath(fromObject, [\n        \"editMode\"\n    ]);\n    if (parentObject !== undefined && fromEditMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editMode\"\n        ], fromEditMode);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editConfig\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    return toObject;\n}\nfunction editImageParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return referenceImageAPIInternalToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        editImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction editImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"task_type\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"autoTruncate\"\n        ], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"content\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        embedContentConfigToMldev(fromConfig, toObject);\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"model\"\n        ], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"instances[]\",\n            \"content\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        embedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"predictions[]\",\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentEmbeddingFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    return toObject;\n}\nfunction endpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        \"deployedModelId\"\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, [\n            \"deployedModelId\"\n        ], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    if (getValueByPath(fromObject, [\n        \"streamFunctionCallArguments\"\n    ]) !== undefined) {\n        throw new Error(\"streamFunctionCallArguments parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(fromObject) {\n    const toObject = {};\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$1(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToMldev(fromImageConfig));\n    }\n    const fromEnableEnhancedCivicAnswers = getValueByPath(fromObject, [\n        \"enableEnhancedCivicAnswers\"\n    ]);\n    if (fromEnableEnhancedCivicAnswers != null) {\n        setValueByPath(toObject, [\n            \"enableEnhancedCivicAnswers\"\n        ], fromEnableEnhancedCivicAnswers);\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], tContent(fromSystemInstruction));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], fromModelSelectionConfig);\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], fromToolConfig);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], tSpeechConfig(fromSpeechConfig));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, [\n        \"imageConfig\"\n    ]);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, [\n            \"imageConfig\"\n        ], imageConfigToVertex(fromImageConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"enableEnhancedCivicAnswers\"\n    ]) !== undefined) {\n        throw new Error(\"enableEnhancedCivicAnswers parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"negativePrompt parameter is not supported in Gemini API.\");\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]) !== undefined) {\n        throw new Error(\"addWatermark parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleImageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"enhancePrompt parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleImageSize\"\n        ], fromImageSize);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateImagesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateImagesConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"fps\"\n    ]) !== undefined) {\n        throw new Error(\"fps parameter is not supported in Gemini API.\");\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]) !== undefined) {\n        throw new Error(\"pubsubTopic parameter is not supported in Gemini API.\");\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    if (getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]) !== undefined) {\n        throw new Error(\"generateAudio parameter is not supported in Gemini API.\");\n    }\n    const fromLastFrame = getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"lastFrame\"\n        ], imageToMldev(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return videoGenerationReferenceImageToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"mask\"\n    ]) !== undefined) {\n        throw new Error(\"mask parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"compressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"fps\"\n        ], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"pubsubTopic\"\n        ], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    const fromGenerateAudio = getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]);\n    if (parentObject !== undefined && fromGenerateAudio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"generateAudio\"\n        ], fromGenerateAudio);\n    }\n    const fromLastFrame = getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"lastFrame\"\n        ], imageToVertex(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return videoGenerationReferenceImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromMask = getValueByPath(fromObject, [\n        \"mask\"\n    ]);\n    if (parentObject !== undefined && fromMask != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"mask\"\n        ], videoGenerationMaskToVertex(fromMask));\n    }\n    const fromCompressionQuality = getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"compressionQuality\"\n        ], fromCompressionQuality);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToMldev(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        generateVideosSourceToMldev(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateVideosConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToVertex(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        generateVideosSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        generateVideosConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosSourceToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromMldev(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromMldev(fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromVertex(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromVertex(fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, [\n            \"enhancedPrompt\"\n        ], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generatedImageMaskFromVertex(fromObject) {\n    const toObject = {};\n    const fromMask = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromMask != null) {\n        setValueByPath(toObject, [\n            \"mask\"\n        ], imageFromVertex(fromMask));\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        let transformedList = fromLabels;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"labels\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generationConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], fromModelSelectionConfig);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, [\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], fromSpeechConfig);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    if (getValueByPath(fromObject, [\n        \"enableEnhancedCivicAnswers\"\n    ]) !== undefined) {\n        throw new Error(\"enableEnhancedCivicAnswers parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, [\n            \"imageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]) !== undefined) {\n        throw new Error(\"personGeneration parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]) !== undefined) {\n        throw new Error(\"outputMimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"outputCompressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction imageConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, [\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, [\n            \"imageSize\"\n        ], fromImageSize);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (fromPersonGeneration != null) {\n        setValueByPath(toObject, [\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (fromOutputMimeType != null) {\n        setValueByPath(toObject, [\n            \"imageOutputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (fromOutputCompressionQuality != null) {\n        setValueByPath(toObject, [\n            \"imageOutputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    return toObject;\n}\nfunction imageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageFromVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction listModelsConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listModelsConfigToMldev(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listModelsConfigToVertex(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction maskReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMaskMode = getValueByPath(fromObject, [\n        \"maskMode\"\n    ]);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, [\n            \"maskMode\"\n        ], fromMaskMode);\n    }\n    const fromSegmentationClasses = getValueByPath(fromObject, [\n        \"segmentationClasses\"\n    ]);\n    if (fromSegmentationClasses != null) {\n        setValueByPath(toObject, [\n            \"maskClasses\"\n        ], fromSegmentationClasses);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (fromMaskDilation != null) {\n        setValueByPath(toObject, [\n            \"dilation\"\n        ], fromMaskDilation);\n    }\n    return toObject;\n}\nfunction modelFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"version\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromMldev(fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        \"inputTokenLimit\"\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"inputTokenLimit\"\n        ], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        \"outputTokenLimit\"\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"outputTokenLimit\"\n        ], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        \"supportedGenerationMethods\"\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, [\n            \"supportedActions\"\n        ], fromSupportedActions);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromMaxTemperature = getValueByPath(fromObject, [\n        \"maxTemperature\"\n    ]);\n    if (fromMaxTemperature != null) {\n        setValueByPath(toObject, [\n            \"maxTemperature\"\n        ], fromMaxTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromThinking = getValueByPath(fromObject, [\n        \"thinking\"\n    ]);\n    if (fromThinking != null) {\n        setValueByPath(toObject, [\n            \"thinking\"\n        ], fromThinking);\n    }\n    return toObject;\n}\nfunction modelFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"versionId\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, [\n        \"deployedModels\"\n    ]);\n    if (fromEndpoints != null) {\n        let transformedList = fromEndpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return endpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"endpoints\"\n        ], transformedList);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromVertex(fromTunedModelInfo));\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (fromDefaultCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, [\n        \"checkpoints\"\n    ]);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"checkpoints\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$1(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev$1(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$1(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction productImageToVertex(fromObject) {\n    const toObject = {};\n    const fromProductImage = getValueByPath(fromObject, [\n        \"productImage\"\n    ]);\n    if (fromProductImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromProductImage));\n    }\n    return toObject;\n}\nfunction recontextImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    return toObject;\n}\nfunction recontextImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        recontextImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        recontextImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction recontextImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction recontextImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromPersonImage = getValueByPath(fromObject, [\n        \"personImage\"\n    ]);\n    if (parentObject !== undefined && fromPersonImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"personImage\",\n            \"image\"\n        ], imageToVertex(fromPersonImage));\n    }\n    const fromProductImages = getValueByPath(fromObject, [\n        \"productImages\"\n    ]);\n    if (parentObject !== undefined && fromProductImages != null) {\n        let transformedList = fromProductImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return productImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"productImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction referenceImageAPIInternalToVertex(fromObject) {\n    const toObject = {};\n    const fromReferenceImage = getValueByPath(fromObject, [\n        \"referenceImage\"\n    ]);\n    if (fromReferenceImage != null) {\n        setValueByPath(toObject, [\n            \"referenceImage\"\n        ], imageToVertex(fromReferenceImage));\n    }\n    const fromReferenceId = getValueByPath(fromObject, [\n        \"referenceId\"\n    ]);\n    if (fromReferenceId != null) {\n        setValueByPath(toObject, [\n            \"referenceId\"\n        ], fromReferenceId);\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    const fromMaskImageConfig = getValueByPath(fromObject, [\n        \"maskImageConfig\"\n    ]);\n    if (fromMaskImageConfig != null) {\n        setValueByPath(toObject, [\n            \"maskImageConfig\"\n        ], maskReferenceConfigToVertex(fromMaskImageConfig));\n    }\n    const fromControlImageConfig = getValueByPath(fromObject, [\n        \"controlImageConfig\"\n    ]);\n    if (fromControlImageConfig != null) {\n        setValueByPath(toObject, [\n            \"controlImageConfig\"\n        ], controlReferenceConfigToVertex(fromControlImageConfig));\n    }\n    const fromStyleImageConfig = getValueByPath(fromObject, [\n        \"styleImageConfig\"\n    ]);\n    if (fromStyleImageConfig != null) {\n        setValueByPath(toObject, [\n            \"styleImageConfig\"\n        ], fromStyleImageConfig);\n    }\n    const fromSubjectImageConfig = getValueByPath(fromObject, [\n        \"subjectImageConfig\"\n    ]);\n    if (fromSubjectImageConfig != null) {\n        setValueByPath(toObject, [\n            \"subjectImageConfig\"\n        ], fromSubjectImageConfig);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction scribbleImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    return toObject;\n}\nfunction segmentImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    const fromMaxPredictions = getValueByPath(fromObject, [\n        \"maxPredictions\"\n    ]);\n    if (parentObject !== undefined && fromMaxPredictions != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"maxPredictions\"\n        ], fromMaxPredictions);\n    }\n    const fromConfidenceThreshold = getValueByPath(fromObject, [\n        \"confidenceThreshold\"\n    ]);\n    if (parentObject !== undefined && fromConfidenceThreshold != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"confidenceThreshold\"\n        ], fromConfidenceThreshold);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (parentObject !== undefined && fromMaskDilation != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"maskDilation\"\n        ], fromMaskDilation);\n    }\n    const fromBinaryColorThreshold = getValueByPath(fromObject, [\n        \"binaryColorThreshold\"\n    ]);\n    if (parentObject !== undefined && fromBinaryColorThreshold != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"binaryColorThreshold\"\n        ], fromBinaryColorThreshold);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    return toObject;\n}\nfunction segmentImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        segmentImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        segmentImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction segmentImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedMasks = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedMasks != null) {\n        let transformedList = fromGeneratedMasks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageMaskFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedMasks\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction segmentImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromScribbleImage = getValueByPath(fromObject, [\n        \"scribbleImage\"\n    ]);\n    if (parentObject !== undefined && fromScribbleImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"scribble\"\n        ], scribbleImageToVertex(fromScribbleImage));\n    }\n    return toObject;\n}\nfunction toolConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], fromRetrievalConfig);\n    }\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev(fromFunctionCallingConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev$1(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$1(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex(fromObject) {\n    const toObject = {};\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]) !== undefined) {\n        throw new Error(\"fileSearch parameter is not supported in Vertex AI.\");\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], fromEnterpriseWebSearch);\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], fromGoogleSearch);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"labels\",\n        \"google-vertex-llm-tuning-base-model-id\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction updateModelConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateModelConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        updateModelConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhanceInputImage = getValueByPath(fromObject, [\n        \"enhanceInputImage\"\n    ]);\n    if (parentObject !== undefined && fromEnhanceInputImage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"enhanceInputImage\"\n        ], fromEnhanceInputImage);\n    }\n    const fromImagePreservationFactor = getValueByPath(fromObject, [\n        \"imagePreservationFactor\"\n    ]);\n    if (parentObject !== undefined && fromImagePreservationFactor != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"imagePreservationFactor\"\n        ], fromImagePreservationFactor);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromUpscaleFactor = getValueByPath(fromObject, [\n        \"upscaleFactor\"\n    ]);\n    if (fromUpscaleFactor != null) {\n        setValueByPath(toObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"upscaleFactor\"\n        ], fromUpscaleFactor);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction videoFromMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoGenerationMaskToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"_self\"\n        ], imageToVertex(fromImage));\n    }\n    const fromMaskMode = getValueByPath(fromObject, [\n        \"maskMode\"\n    ]);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, [\n            \"maskMode\"\n        ], fromMaskMode);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoToMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"videoBytes\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"encodedVideo\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"encoding\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoToVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"videoBytes\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromForce = getValueByPath(fromObject, [\n        \"force\"\n    ]);\n    if (parentObject !== undefined && fromForce != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"force\"\n        ], fromForce);\n    }\n    return toObject;\n}\nfunction deleteFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        deleteFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction importFileConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromCustomMetadata = getValueByPath(fromObject, [\n        \"customMetadata\"\n    ]);\n    if (parentObject !== undefined && fromCustomMetadata != null) {\n        let transformedList = fromCustomMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"customMetadata\"\n        ], transformedList);\n    }\n    const fromChunkingConfig = getValueByPath(fromObject, [\n        \"chunkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromChunkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"chunkingConfig\"\n        ], fromChunkingConfig);\n    }\n    return toObject;\n}\nfunction importFileOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], importFileResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction importFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFileSearchStoreName = getValueByPath(fromObject, [\n        \"fileSearchStoreName\"\n    ]);\n    if (fromFileSearchStoreName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file_search_store_name\"\n        ], fromFileSearchStoreName);\n    }\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        importFileConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction importFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"parent\"\n        ], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, [\n        \"documentName\"\n    ]);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, [\n            \"documentName\"\n        ], fromDocumentName);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listFileSearchStoresConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromFileSearchStores = getValueByPath(fromObject, [\n        \"fileSearchStores\"\n    ]);\n    if (fromFileSearchStores != null) {\n        let transformedList = fromFileSearchStores;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"fileSearchStores\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromCustomMetadata = getValueByPath(fromObject, [\n        \"customMetadata\"\n    ]);\n    if (parentObject !== undefined && fromCustomMetadata != null) {\n        let transformedList = fromCustomMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(parentObject, [\n            \"customMetadata\"\n        ], transformedList);\n    }\n    const fromChunkingConfig = getValueByPath(fromObject, [\n        \"chunkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromChunkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"chunkingConfig\"\n        ], fromChunkingConfig);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFileSearchStoreName = getValueByPath(fromObject, [\n        \"fileSearchStoreName\"\n    ]);\n    if (fromFileSearchStoreName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file_search_store_name\"\n        ], fromFileSearchStoreName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const CONTENT_TYPE_HEADER = \"Content-Type\";\nconst SERVER_TIMEOUT_HEADER = \"X-Server-Timeout\";\nconst USER_AGENT_HEADER = \"User-Agent\";\nconst GOOGLE_API_CLIENT_HEADER = \"x-goog-api-client\";\nconst SDK_VERSION = \"1.35.0\"; // x-release-please-version\nconst LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;\nconst VERTEX_AI_API_DEFAULT_VERSION = \"v1beta1\";\nconst GOOGLE_AI_API_DEFAULT_VERSION = \"v1beta\";\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */ class ApiClient {\n    constructor(opts){\n        var _a, _b;\n        this.clientOptions = Object.assign(Object.assign({}, opts), {\n            project: opts.project,\n            location: opts.location,\n            apiKey: opts.apiKey,\n            vertexai: opts.vertexai\n        });\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();\n            this.normalizeAuthParameters();\n        } else {\n            // Gemini API\n            initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n    /**\n     * Determines the base URL for Vertex AI based on project and location.\n     * Uses the global endpoint if location is 'global' or if project/location\n     * are not specified (implying API key usage).\n     * @private\n     */ baseUrlFromProjectLocation() {\n        if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== \"global\") {\n            // Regional endpoint\n            return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;\n        }\n        // Global endpoint (covers 'global' location and API key usage)\n        return `https://aiplatform.googleapis.com/`;\n    }\n    /**\n     * Normalizes authentication parameters for Vertex AI.\n     * If project and location are provided, API key is cleared.\n     * If project and location are not provided (implying API key usage),\n     * project and location are cleared.\n     * @private\n     */ normalizeAuthParameters() {\n        if (this.clientOptions.project && this.clientOptions.location) {\n            // Using project/location for auth, clear potential API key\n            this.clientOptions.apiKey = undefined;\n            return;\n        }\n        // Using API key for auth (or no auth provided yet), clear project/location\n        this.clientOptions.project = undefined;\n        this.clientOptions.location = undefined;\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    async getAuthHeaders() {\n        const headers = new Headers();\n        await this.clientOptions.auth.addAuthHeaders(headers);\n        return headers;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error(\"API version is not set.\");\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error(\"Base URL is not set.\");\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        } else {\n            throw new Error(\"Headers are not set.\");\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions || httpOptions.baseUrl === undefined || httpOptions.apiVersion === undefined) {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith(\"/\") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;\n        const urlElement = [\n            baseUrl\n        ];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== \"\") {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join(\"/\");\n    }\n    getBaseResourcePath() {\n        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == \"http:\" ? \"ws\" : \"wss\";\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        } else {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [\n            this.getRequestUrlInternal(httpOptions)\n        ];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== \"\") {\n            urlElement.push(path);\n        }\n        const url = new URL(`${urlElement.join(\"/\")}`);\n        return url;\n    }\n    shouldPrependVertexProjectPath(request) {\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith(\"projects/\")) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === \"GET\" && request.path.startsWith(\"publishers/google/models\")) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)){\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === \"GET\") {\n            if (request.body && request.body !== \"{}\") {\n                throw new Error(\"Request body should be empty for GET request, but got non empty request body\");\n            }\n        } else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)){\n            // Records compile to objects.\n            if (typeof value === \"object\") {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            } else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has(\"alt\") || url.searchParams.get(\"alt\") !== \"sse\") {\n            url.searchParams.set(\"alt\", \"sse\");\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {\n        if (httpOptions && httpOptions.timeout || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                const timeoutHandle = setTimeout(()=>abortController.abort(), httpOptions.timeout);\n                if (timeoutHandle && typeof timeoutHandle.unref === \"function\") {\n                    // call unref to prevent nodejs process from hanging, see\n                    // https://nodejs.org/api/timers.html#timeoutunref\n                    timeoutHandle.unref();\n                }\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener(\"abort\", ()=>{\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        if (httpOptions && httpOptions.extraBody !== null) {\n            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions, url);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _a;\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder(\"utf-8\");\n            if (!reader) {\n                throw new Error(\"Response body is empty\");\n            }\n            try {\n                let buffer = \"\";\n                const dataPrefix = \"data:\";\n                const delimiters = [\n                    \"\\n\\n\",\n                    \"\\r\\r\",\n                    \"\\r\\n\\r\\n\"\n                ];\n                while(true){\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error(\"Incomplete JSON segment at the end\");\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value, {\n                        stream: true\n                    });\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if (\"error\" in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson[\"error\"]));\n                            const status = errorJson[\"status\"];\n                            const code = errorJson[\"code\"];\n                            const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;\n                            if (code >= 400 && code < 600) {\n                                const apiError = new ApiError({\n                                    message: errorMessage,\n                                    status: code\n                                });\n                                throw apiError;\n                            }\n                        }\n                    } catch (e) {\n                        const error = e;\n                        if (error.name === \"ApiError\") {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let delimiterIndex = -1;\n                    let delimiterLength = 0;\n                    while(true){\n                        delimiterIndex = -1;\n                        delimiterLength = 0;\n                        for (const delimiter of delimiters){\n                            const index = buffer.indexOf(delimiter);\n                            if (index !== -1 && (delimiterIndex === -1 || index < delimiterIndex)) {\n                                delimiterIndex = index;\n                                delimiterLength = delimiter.length;\n                            }\n                        }\n                        if (delimiterIndex === -1) {\n                            break; // No complete event in buffer\n                        }\n                        const eventString = buffer.substring(0, delimiterIndex);\n                        buffer = buffer.substring(delimiterIndex + delimiterLength);\n                        const trimmedEvent = eventString.trim();\n                        if (trimmedEvent.startsWith(dataPrefix)) {\n                            const processedChunkString = trimmedEvent.substring(dataPrefix.length).trim();\n                            try {\n                                const partialResponse = new Response(processedChunkString, {\n                                    headers: response === null || response === void 0 ? void 0 : response.headers,\n                                    status: response === null || response === void 0 ? void 0 : response.status,\n                                    statusText: response === null || response === void 0 ? void 0 : response.statusText\n                                });\n                                yield yield __await(new HttpResponse(partialResponse));\n                            } catch (e) {\n                                throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);\n                            }\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e)=>{\n            throw new Error(`exception ${e} sending request`);\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + \" \" + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = \"application/json\";\n        return headers;\n    }\n    async getHeadersInternal(httpOptions, url) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)){\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers, url);\n        return headers;\n    }\n    getFileName(file) {\n        var _a;\n        let fileName = \"\";\n        if (typeof file === \"string\") {\n            fileName = file.replace(/[/\\\\]+$/, \"\");\n            fileName = (_a = fileName.split(/[/\\\\]/).pop()) !== null && _a !== void 0 ? _a : \"\";\n        }\n        return fileName;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link types.UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */ async uploadFile(file, config) {\n        var _a;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith(\"files/\")) {\n            fileToUpload.name = `files/${fileToUpload.name}`;\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === \"\") {\n            throw new Error(\"Can not determine mimeType. Please provide mimeType in the config.\");\n        }\n        fileToUpload.mimeType = mimeType;\n        const body = {\n            file: fileToUpload\n        };\n        const fileName = this.getFileName(file);\n        const path = formatMap(\"upload/v1beta/files\", body[\"_url\"]);\n        const uploadUrl = await this.fetchUploadUrl(path, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    /**\n     * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param fileSearchStoreName The name of the file search store to upload the file to.\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */ async uploadFileToFileSearchStore(fileSearchStoreName, file, config) {\n        var _a;\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        const sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === \"\") {\n            throw new Error(\"Can not determine mimeType. Please provide mimeType in the config.\");\n        }\n        const path = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;\n        const fileName = this.getFileName(file);\n        const body = {};\n        if (config != null) {\n            uploadToFileSearchStoreConfigToMldev(config, body);\n        }\n        const uploadUrl = await this.fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);\n        return uploader.uploadToFileSearchStore(file, uploadUrl, this);\n    }\n    /**\n     * Downloads a file asynchronously to the specified path.\n     *\n     * @params params - The parameters for the download request, see {@link\n     * types.DownloadFileParameters}\n     */ async downloadFile(params) {\n        const downloader = this.clientOptions.downloader;\n        await downloader.download(params, this);\n    }\n    async fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, configHttpOptions) {\n        var _a;\n        let httpOptions = {};\n        if (configHttpOptions) {\n            httpOptions = configHttpOptions;\n        } else {\n            httpOptions = {\n                apiVersion: \"\",\n                headers: Object.assign({\n                    \"Content-Type\": \"application/json\",\n                    \"X-Goog-Upload-Protocol\": \"resumable\",\n                    \"X-Goog-Upload-Command\": \"start\",\n                    \"X-Goog-Upload-Header-Content-Length\": `${sizeBytes}`,\n                    \"X-Goog-Upload-Header-Content-Type\": `${mimeType}`\n                }, fileName ? {\n                    \"X-Goog-Upload-File-Name\": fileName\n                } : {})\n            };\n        }\n        const httpResponse = await this.request({\n            path,\n            body: JSON.stringify(body),\n            httpMethod: \"POST\",\n            httpOptions\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error(\"Server did not return an HttpResponse or the returned HttpResponse did not have headers.\");\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a[\"x-goog-upload-url\"];\n        if (uploadUrl === undefined) {\n            throw new Error(\"Failed to get upload url. Server did not return the x-google-upload-url in the headers\");\n        }\n        return uploadUrl;\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new Error(\"response is undefined\");\n    }\n    if (!response.ok) {\n        const status = response.status;\n        let errorBody;\n        if ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.includes(\"application/json\")) {\n            errorBody = await response.json();\n        } else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText\n                }\n            };\n        }\n        const errorMessage = JSON.stringify(errorBody);\n        if (status >= 400 && status < 600) {\n            const apiError = new ApiError({\n                message: errorMessage,\n                status: status\n            });\n            throw apiError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Recursively updates the `requestInit.body` with values from an `extraBody` object.\n *\n * If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.\n * The `extraBody` is then deeply merged into this parsed object.\n * If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,\n * as merging structured data into an opaque Blob is not supported.\n *\n * The function does not enforce that updated values from `extraBody` have the\n * same type as existing values in `requestInit.body`. Type mismatches during\n * the merge will result in a warning, but the value from `extraBody` will overwrite\n * the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.\n *\n * @param requestInit The RequestInit object whose body will be updated.\n * @param extraBody The object containing updates to be merged into `requestInit.body`.\n */ function includeExtraBodyToRequestInit(requestInit, extraBody) {\n    if (!extraBody || Object.keys(extraBody).length === 0) {\n        return;\n    }\n    if (requestInit.body instanceof Blob) {\n        console.warn(\"includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.\");\n        return;\n    }\n    let currentBodyObject = {};\n    // If adding new type to HttpRequest.body, please check the code below to\n    // see if we need to update the logic.\n    if (typeof requestInit.body === \"string\" && requestInit.body.length > 0) {\n        try {\n            const parsedBody = JSON.parse(requestInit.body);\n            if (typeof parsedBody === \"object\" && parsedBody !== null && !Array.isArray(parsedBody)) {\n                currentBodyObject = parsedBody;\n            } else {\n                console.warn(\"includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.\");\n                return;\n            }\n        /*  eslint-disable-next-line @typescript-eslint/no-unused-vars */ } catch (e) {\n            console.warn(\"includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.\");\n            return;\n        }\n    }\n    function deepMerge(target, source) {\n        const output = Object.assign({}, target);\n        for(const key in source){\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                const sourceValue = source[key];\n                const targetValue = output[key];\n                if (sourceValue && typeof sourceValue === \"object\" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === \"object\" && !Array.isArray(targetValue)) {\n                    output[key] = deepMerge(targetValue, sourceValue);\n                } else {\n                    if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {\n                        console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key \"${key}\". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);\n                    }\n                    output[key] = sourceValue;\n                }\n            }\n        }\n        return output;\n    }\n    const mergedBody = deepMerge(currentBodyObject, extraBody);\n    requestInit.body = JSON.stringify(mergedBody);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // TODO: b/416041229 - Determine how to retrieve the MCP package version.\nconst MCP_LABEL = \"mcp_used/unknown\";\n// Whether MCP tool usage is detected from mcpToTool. This is used for\n// telemetry.\nlet hasMcpToolUsageFromMcpToTool = false;\n// Checks whether the list of tools contains any MCP tools.\nfunction hasMcpToolUsage(tools) {\n    for (const tool of tools){\n        if (isMcpCallableTool(tool)) {\n            return true;\n        }\n        if (typeof tool === \"object\" && \"inputSchema\" in tool) {\n            return true;\n        }\n    }\n    return hasMcpToolUsageFromMcpToTool;\n}\n// Sets the MCP version label in the Google API client header.\nfunction setMcpUsageHeader(headers) {\n    var _a;\n    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : \"\";\n    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();\n}\n// Returns true if the object is a MCP CallableTool, otherwise false.\nfunction isMcpCallableTool(object) {\n    return object !== null && typeof object === \"object\" && object instanceof McpCallableTool;\n}\n// List all tools from the MCP client.\nfunction listAllTools(mcpClient_1) {\n    return __asyncGenerator(this, arguments, function* listAllTools_1(mcpClient, maxTools = 100) {\n        let cursor = undefined;\n        let numTools = 0;\n        while(numTools < maxTools){\n            const t = yield __await(mcpClient.listTools({\n                cursor\n            }));\n            for (const tool of t.tools){\n                yield yield __await(tool);\n                numTools++;\n            }\n            if (!t.nextCursor) {\n                break;\n            }\n            cursor = t.nextCursor;\n        }\n    });\n}\n/**\n * McpCallableTool can be used for model inference and invoking MCP clients with\n * given function call arguments.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ class McpCallableTool {\n    constructor(mcpClients = [], config){\n        this.mcpTools = [];\n        this.functionNameToMcpClient = {};\n        this.mcpClients = mcpClients;\n        this.config = config;\n    }\n    /**\n     * Creates a McpCallableTool.\n     */ static create(mcpClients, config) {\n        return new McpCallableTool(mcpClients, config);\n    }\n    /**\n     * Validates the function names are not duplicate and initialize the function\n     * name to MCP client mapping.\n     *\n     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool\n     *     names.\n     */ async initialize() {\n        var _a, e_1, _b, _c;\n        if (this.mcpTools.length > 0) {\n            return;\n        }\n        const functionMap = {};\n        const mcpTools = [];\n        for (const mcpClient of this.mcpClients){\n            try {\n                for(var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const mcpTool = _c;\n                    mcpTools.push(mcpTool);\n                    const mcpToolName = mcpTool.name;\n                    if (functionMap[mcpToolName]) {\n                        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n                    }\n                    functionMap[mcpToolName] = mcpClient;\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        }\n        this.mcpTools = mcpTools;\n        this.functionNameToMcpClient = functionMap;\n    }\n    async tool() {\n        await this.initialize();\n        return mcpToolsToGeminiTool(this.mcpTools, this.config);\n    }\n    async callTool(functionCalls) {\n        await this.initialize();\n        const functionCallResponseParts = [];\n        for (const functionCall of functionCalls){\n            if (functionCall.name in this.functionNameToMcpClient) {\n                const mcpClient = this.functionNameToMcpClient[functionCall.name];\n                let requestOptions = undefined;\n                // TODO: b/424238654 - Add support for finer grained timeout control.\n                if (this.config.timeout) {\n                    requestOptions = {\n                        timeout: this.config.timeout\n                    };\n                }\n                const callToolResponse = await mcpClient.callTool({\n                    name: functionCall.name,\n                    arguments: functionCall.args\n                }, // Set the result schema to undefined to allow MCP to rely on the\n                // default schema.\n                undefined, requestOptions);\n                functionCallResponseParts.push({\n                    functionResponse: {\n                        name: functionCall.name,\n                        response: callToolResponse.isError ? {\n                            error: callToolResponse\n                        } : callToolResponse\n                    }\n                });\n            }\n        }\n        return functionCallResponseParts;\n    }\n}\nfunction isMcpClient(client) {\n    return client !== null && typeof client === \"object\" && \"listTools\" in client && typeof client.listTools === \"function\";\n}\n/**\n * Creates a McpCallableTool from MCP clients and an optional config.\n *\n * The callable tool can invoke the MCP clients with given function call\n * arguments. (often for automatic function calling).\n * Use the config to modify tool parameters such as behavior.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ function mcpToTool(...args) {\n    // Set MCP usage for telemetry.\n    hasMcpToolUsageFromMcpToTool = true;\n    if (args.length === 0) {\n        throw new Error(\"No MCP clients provided\");\n    }\n    const maybeConfig = args[args.length - 1];\n    if (isMcpClient(maybeConfig)) {\n        return McpCallableTool.create(args, {});\n    }\n    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveMusicServerMessage, and then calling the onmessage callback.\n * Note that the first message which is received from the server is a\n * setupComplete message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage$1(apiClient, onmessage, event) {\n    const serverMessage = new LiveMusicServerMessage();\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    } else {\n        data = JSON.parse(event.data);\n    }\n    Object.assign(serverMessage, data);\n    onmessage(serverMessage);\n}\n/**\n   LiveMusic class encapsulates the configuration for live music\n   generation via Lyria Live models.\n\n   @experimental\n  */ class LiveMusic {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n    /**\n       Establishes a connection to the specified model and returns a\n       LiveMusicSession object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model = 'models/lyria-realtime-exp';\n       const session = await ai.live.music.connect({\n         model: model,\n         callbacks: {\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b;\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Live music is not supported for Vertex AI.\");\n        }\n        console.warn(\"Live music generation is experimental and may change in future versions.\");\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());\n        const apiKey = this.apiClient.getApiKey();\n        const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        const model = tModel(this.apiClient, params.model);\n        const setup = {\n            model\n        };\n        const clientMessage = {\n            setup\n        };\n        conn.send(JSON.stringify(clientMessage));\n        return new LiveMusicSession(conn, this.apiClient);\n    }\n}\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class LiveMusicSession {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    /**\n      Sets inputs to steer music generation. Updates the session's current\n      weighted prompts.\n  \n      @param params - Contains one property, `weightedPrompts`.\n  \n        - `weightedPrompts` to send to the model; weights are normalized to\n          sum to 1.0.\n  \n      @experimental\n     */ async setWeightedPrompts(params) {\n        if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {\n            throw new Error(\"Weighted prompts must be set and contain at least one entry.\");\n        }\n        const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);\n        this.conn.send(JSON.stringify({\n            clientContent\n        }));\n    }\n    /**\n      Sets a configuration to the model. Updates the session's current\n      music generation config.\n  \n      @param params - Contains one property, `musicGenerationConfig`.\n  \n        - `musicGenerationConfig` to set in the model. Passing an empty or\n      undefined config to the model will reset the config to defaults.\n  \n      @experimental\n     */ async setMusicGenerationConfig(params) {\n        if (!params.musicGenerationConfig) {\n            params.musicGenerationConfig = {};\n        }\n        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);\n        this.conn.send(JSON.stringify(setConfigParameters));\n    }\n    sendPlaybackControl(playbackControl) {\n        const clientMessage = {\n            playbackControl\n        };\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n     * Start the music stream.\n     *\n     * @experimental\n     */ play() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);\n    }\n    /**\n     * Temporarily halt the music stream. Use `play` to resume from the current\n     * position.\n     *\n     * @experimental\n     */ pause() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);\n    }\n    /**\n     * Stop the music stream and reset the state. Retains the current prompts\n     * and config.\n     *\n     * @experimental\n     */ stop() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);\n    }\n    /**\n     * Resets the context of the music generation without stopping it.\n     * Retains the current prompts and config.\n     *\n     * @experimental\n     */ resetContext() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap$1(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders$1(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const FUNCTION_RESPONSE_REQUIRES_ID = \"FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.\";\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage(apiClient, onmessage, event) {\n    const serverMessage = new LiveServerMessage();\n    let jsonData;\n    if (event.data instanceof Blob) {\n        jsonData = await event.data.text();\n    } else if (event.data instanceof ArrayBuffer) {\n        jsonData = new TextDecoder().decode(event.data);\n    } else {\n        jsonData = event.data;\n    }\n    const data = JSON.parse(jsonData);\n    if (apiClient.isVertexAI()) {\n        const resp = liveServerMessageFromVertex(data);\n        Object.assign(serverMessage, resp);\n    } else {\n        const resp = data;\n        Object.assign(serverMessage, resp);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */ class Live {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);\n    }\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental Built-in MCP support is an experimental feature, may change in\n       future versions.\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b, _c, _d, _e, _f;\n        // TODO: b/404946746 - Support per request HTTP options.\n        if (params.config && params.config.httpOptions) {\n            throw new Error(\"The Live module does not support httpOptions at request-level in\" + \" LiveConnectConfig yet. Please use the client-level httpOptions\" + \" configuration instead.\");\n        }\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const clientHeaders = this.apiClient.getHeaders();\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            setMcpUsageHeader(clientHeaders);\n        }\n        const headers = mapToHeaders(clientHeaders);\n        if (this.apiClient.isVertexAI()) {\n            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;\n            await this.auth.addAuthHeaders(headers, url);\n        } else {\n            const apiKey = this.apiClient.getApiKey();\n            let method = \"BidiGenerateContent\";\n            let keyName = \"key\";\n            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith(\"auth_tokens/\")) {\n                console.warn(\"Warning: Ephemeral token support is experimental and may change in future versions.\");\n                if (apiVersion !== \"v1alpha\") {\n                    console.warn(\"Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.\");\n                }\n                method = \"BidiGenerateContentConstrained\";\n                keyName = \"access_token\";\n            }\n            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;\n        }\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() && transformedModel.startsWith(\"publishers/\")) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = {\n                    responseModalities: [\n                        Modality.AUDIO\n                    ]\n                };\n            } else {\n                params.config.responseModalities = [\n                    Modality.AUDIO\n                ];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn(\"Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).\");\n        }\n        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];\n        const convertedTools = [];\n        for (const tool of inputTools){\n            if (this.isCallableTool(tool)) {\n                const callableTool = tool;\n                convertedTools.push(await callableTool.tool());\n            } else {\n                convertedTools.push(tool);\n            }\n        }\n        if (convertedTools.length > 0) {\n            params.config.tools = convertedTools;\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        } else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage[\"config\"];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n    // TODO: b/416041229 - Abstract this method to a common place.\n    isCallableTool(tool) {\n        return \"callTool\" in tool && typeof tool.callTool === \"function\";\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class Session {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(params.turns);\n                if (!apiClient.isVertexAI()) {\n                    contents = contents.map((item)=>contentToMldev$1(item));\n                }\n            } catch (_a) {\n                throw new Error(`Failed to parse client content \"turns\", type: '${typeof params.turns}'`);\n            }\n            return {\n                clientContent: {\n                    turns: contents,\n                    turnComplete: params.turnComplete\n                }\n            };\n        }\n        return {\n            clientContent: {\n                turnComplete: params.turnComplete\n            }\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [\n                params.functionResponses\n            ];\n        } else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        for (const functionResponse of functionResponses){\n            if (typeof functionResponse !== \"object\" || functionResponse === null || !(\"name\" in functionResponse) || !(\"response\" in functionResponse)) {\n                throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);\n            }\n            if (!apiClient.isVertexAI() && !(\"id\" in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: {\n                functionResponses: functionResponses\n            }\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */ sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */ sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToVertex(params)\n            };\n        } else {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToMldev(params)\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */ sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error(\"Tool response parameters are required.\");\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const DEFAULT_MAX_REMOTE_CALLS = 10;\n/** Returns whether automatic function calling is disabled. */ function shouldDisableAfc(config) {\n    var _a, _b, _c;\n    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {\n        return true;\n    }\n    let callableToolsPresent = false;\n    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []){\n        if (isCallableTool(tool)) {\n            callableToolsPresent = true;\n            break;\n        }\n    }\n    if (!callableToolsPresent) {\n        return true;\n    }\n    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;\n    if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {\n        console.warn(\"Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:\", maxCalls);\n        return true;\n    }\n    return false;\n}\nfunction isCallableTool(tool) {\n    return \"callTool\" in tool && typeof tool.callTool === \"function\";\n}\n// Checks whether the list of tools contains any CallableTools. Will return true\n// if there is at least one CallableTool.\nfunction hasCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool)=>isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n/**\n * Returns the indexes of the tools that are not compatible with AFC.\n */ function findAfcIncompatibleToolIndexes(params) {\n    var _a;\n    // Use number[] for an array of numbers in TypeScript\n    const afcIncompatibleToolIndexes = [];\n    if (!((_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.tools)) {\n        return afcIncompatibleToolIndexes;\n    }\n    params.config.tools.forEach((tool, index)=>{\n        if (isCallableTool(tool)) {\n            return;\n        }\n        const geminiTool = tool;\n        if (geminiTool.functionDeclarations && geminiTool.functionDeclarations.length > 0) {\n            afcIncompatibleToolIndexes.push(index);\n        }\n    });\n    return afcIncompatibleToolIndexes;\n}\n/**\n * Returns whether to append automatic function calling history to the\n * response.\n */ function shouldAppendAfcHistory(config) {\n    var _a;\n    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Models extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.generateContent = async (params)=>{\n            var _a, _b, _c, _d, _e;\n            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n            this.maybeMoveToResponseJsonSchem(params);\n            if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {\n                return await this.generateContentInternal(transformedParams);\n            }\n            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);\n            if (incompatibleToolIndexes.length > 0) {\n                const formattedIndexes = incompatibleToolIndexes.map((index)=>`tools[${index}]`).join(\", \");\n                throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);\n            }\n            let response;\n            let functionResponseContent;\n            const automaticFunctionCallingHistory = tContents(transformedParams.contents);\n            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n            let remoteCalls = 0;\n            while(remoteCalls < maxRemoteCalls){\n                response = await this.generateContentInternal(transformedParams);\n                if (!response.functionCalls || response.functionCalls.length === 0) {\n                    break;\n                }\n                const responseContent = response.candidates[0].content;\n                const functionResponseParts = [];\n                for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []){\n                    if (isCallableTool(tool)) {\n                        const callableTool = tool;\n                        const parts = await callableTool.callTool(response.functionCalls);\n                        functionResponseParts.push(...parts);\n                    }\n                }\n                remoteCalls++;\n                functionResponseContent = {\n                    role: \"user\",\n                    parts: functionResponseParts\n                };\n                transformedParams.contents = tContents(transformedParams.contents);\n                transformedParams.contents.push(responseContent);\n                transformedParams.contents.push(functionResponseContent);\n                if (shouldAppendAfcHistory(transformedParams.config)) {\n                    automaticFunctionCallingHistory.push(responseContent);\n                    automaticFunctionCallingHistory.push(functionResponseContent);\n                }\n            }\n            if (shouldAppendAfcHistory(transformedParams.config)) {\n                response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;\n            }\n            return response;\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */ this.generateContentStream = async (params)=>{\n            var _a, _b, _c, _d, _e;\n            this.maybeMoveToResponseJsonSchem(params);\n            if (shouldDisableAfc(params.config)) {\n                const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n                return await this.generateContentStreamInternal(transformedParams);\n            }\n            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);\n            if (incompatibleToolIndexes.length > 0) {\n                const formattedIndexes = incompatibleToolIndexes.map((index)=>`tools[${index}]`).join(\", \");\n                throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations\" is not yet supported.`);\n            }\n            // With tool compatibility confirmed, validate that the configuration are\n            // compatible with each other and raise an error if invalid.\n            const streamFunctionCall = (_c = (_b = (_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;\n            const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;\n            if (streamFunctionCall && !disableAfc) {\n                throw new Error(\"Running in streaming mode with 'streamFunctionCallArguments' enabled, \" + \"this feature is not compatible with automatic function calling (AFC). \" + \"Please set 'config.automaticFunctionCalling.disable' to true to disable AFC \" + \"or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' \" + \"to be undefined or set to false to disable streaming function call arguments feature.\");\n            }\n            return await this.processAfcStream(params);\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param params - The parameters for generating images.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-4.0-generate-001',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.generateImages = async (params)=>{\n            return await this.generateImagesInternal(params).then((apiResponse)=>{\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages){\n                        if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === \"Positive Prompt\") {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        } else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse\n                    };\n                } else {\n                    response = {\n                        generatedImages: generatedImages,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse\n                    };\n                }\n                return response;\n            });\n        };\n        this.list = async (params)=>{\n            var _a;\n            const defaultConfig = {\n                queryBase: true\n            };\n            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);\n            const actualParams = {\n                config: actualConfig\n            };\n            if (this.apiClient.isVertexAI()) {\n                if (!actualParams.config.queryBase) {\n                    if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {\n                        throw new Error(\"Filtering tuned models list for Vertex AI is not currently supported\");\n                    } else {\n                        actualParams.config.filter = \"labels.tune-type:*\";\n                    }\n                }\n            }\n            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x)=>this.listInternal(x), await this.listInternal(actualParams), actualParams);\n        };\n        /**\n         * Edits an image based on a prompt, list of reference images, and configuration.\n         *\n         * @param params - The parameters for editing an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.editImage({\n         *  model: 'imagen-3.0-capability-001',\n         *  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',\n         *  referenceImages: [subjectReferenceImage]\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.editImage = async (params)=>{\n            const paramsInternal = {\n                model: params.model,\n                prompt: params.prompt,\n                referenceImages: [],\n                config: params.config\n            };\n            if (params.referenceImages) {\n                if (params.referenceImages) {\n                    paramsInternal.referenceImages = params.referenceImages.map((img)=>img.toReferenceImageAPI());\n                }\n            }\n            return await this.editImageInternal(paramsInternal);\n        };\n        /**\n         * Upscales an image based on an image, upscale factor, and configuration.\n         * Only supported in Vertex AI currently.\n         *\n         * @param params - The parameters for upscaling an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.upscaleImage({\n         *  model: 'imagen-4.0-upscale-preview',\n         *  image: image,\n         *  upscaleFactor: 'x2',\n         *  config: {\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.upscaleImage = async (params)=>{\n            let apiConfig = {\n                numberOfImages: 1,\n                mode: \"upscale\"\n            };\n            if (params.config) {\n                apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);\n            }\n            const apiParams = {\n                model: params.model,\n                image: params.image,\n                upscaleFactor: params.upscaleFactor,\n                config: apiConfig\n            };\n            return await this.upscaleImageInternal(apiParams);\n        };\n        /**\n         *  Generates videos based on a text description and configuration.\n         *\n         * @param params - The parameters for generating videos.\n         * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n         *\n         * @example\n         * ```ts\n         * const operation = await ai.models.generateVideos({\n         *  model: 'veo-2.0-generate-001',\n         *  source: {\n         *    prompt: 'A neon hologram of a cat driving at top speed',\n         *  },\n         *  config: {\n         *    numberOfVideos: 1\n         * });\n         *\n         * while (!operation.done) {\n         *   await new Promise(resolve => setTimeout(resolve, 10000));\n         *   operation = await ai.operations.getVideosOperation({operation: operation});\n         * }\n         *\n         * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n         * ```\n         */ this.generateVideos = async (params)=>{\n            var _a, _b, _c, _d, _e, _f;\n            if ((params.prompt || params.image || params.video) && params.source) {\n                throw new Error(\"Source and prompt/image/video are mutually exclusive. Please only use source.\");\n            }\n            // Gemini API does not support video bytes.\n            if (!this.apiClient.isVertexAI()) {\n                if (((_a = params.video) === null || _a === void 0 ? void 0 : _a.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {\n                    params.video = {\n                        uri: params.video.uri,\n                        mimeType: params.video.mimeType\n                    };\n                } else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) && ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {\n                    params.source.video = {\n                        uri: params.source.video.uri,\n                        mimeType: params.source.video.mimeType\n                    };\n                }\n            }\n            return await this.generateVideosInternal(params);\n        };\n    }\n    /**\n     * This logic is needed for GenerateContentConfig only.\n     * Previously we made GenerateContentConfig.responseSchema field to accept\n     * unknown. Since v1.9.0, we switch to use backend JSON schema support.\n     * To maintain backward compatibility, we move the data that was treated as\n     * JSON schema from the responseSchema field to the responseJsonSchema field.\n     */ maybeMoveToResponseJsonSchem(params) {\n        if (params.config && params.config.responseSchema) {\n            if (!params.config.responseJsonSchema) {\n                if (Object.keys(params.config.responseSchema).includes(\"$schema\")) {\n                    params.config.responseJsonSchema = params.config.responseSchema;\n                    delete params.config.responseSchema;\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Transforms the CallableTools in the parameters to be simply Tools, it\n     * copies the params into a new object and replaces the tools, it does not\n     * modify the original params. Also sets the MCP usage header if there are\n     * MCP tools in the parameters.\n     */ async processParamsMaybeAddMcpUsage(params) {\n        var _a, _b, _c;\n        const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;\n        if (!tools) {\n            return params;\n        }\n        const transformedTools = await Promise.all(tools.map(async (tool)=>{\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                return await callableTool.tool();\n            }\n            return tool;\n        }));\n        const newParams = {\n            model: params.model,\n            contents: params.contents,\n            config: Object.assign(Object.assign({}, params.config), {\n                tools: transformedTools\n            })\n        };\n        newParams.config.tools = transformedTools;\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};\n            let newHeaders = Object.assign({}, headers);\n            if (Object.keys(newHeaders).length === 0) {\n                newHeaders = this.apiClient.getDefaultHeaders();\n            }\n            setMcpUsageHeader(newHeaders);\n            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), {\n                headers: newHeaders\n            });\n        }\n        return newParams;\n    }\n    async initAfcToolsMap(params) {\n        var _a, _b, _c;\n        const afcTools = new Map();\n        for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []){\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                const toolDeclaration = await callableTool.tool();\n                for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []){\n                    if (!declaration.name) {\n                        throw new Error(\"Function declaration name is required.\");\n                    }\n                    if (afcTools.has(declaration.name)) {\n                        throw new Error(`Duplicate tool declaration name: ${declaration.name}`);\n                    }\n                    afcTools.set(declaration.name, callableTool);\n                }\n            }\n        }\n        return afcTools;\n    }\n    async processAfcStream(params) {\n        var _a, _b, _c;\n        const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n        let wereFunctionsCalled = false;\n        let remoteCallCount = 0;\n        const afcToolsMap = await this.initAfcToolsMap(params);\n        return function(models, afcTools, params) {\n            return __asyncGenerator(this, arguments, function*() {\n                var _a, e_1, _b, _c;\n                var _d, _e;\n                while(remoteCallCount < maxRemoteCalls){\n                    if (wereFunctionsCalled) {\n                        remoteCallCount++;\n                        wereFunctionsCalled = false;\n                    }\n                    const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params));\n                    const response = yield __await(models.generateContentStreamInternal(transformedParams));\n                    const functionResponses = [];\n                    const responseContents = [];\n                    try {\n                        for(var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _a = response_1_1.done, !_a; _f = true){\n                            _c = response_1_1.value;\n                            _f = false;\n                            const chunk = _c;\n                            yield yield __await(chunk);\n                            if (chunk.candidates && ((_d = chunk.candidates[0]) === null || _d === void 0 ? void 0 : _d.content)) {\n                                responseContents.push(chunk.candidates[0].content);\n                                for (const part of (_e = chunk.candidates[0].content.parts) !== null && _e !== void 0 ? _e : []){\n                                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {\n                                        if (!part.functionCall.name) {\n                                            throw new Error(\"Function call name was not returned by the model.\");\n                                        }\n                                        if (!afcTools.has(part.functionCall.name)) {\n                                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);\n                                        } else {\n                                            const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([\n                                                part.functionCall\n                                            ]));\n                                            functionResponses.push(...responseParts);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = response_1.return)) yield __await(_b.call(response_1));\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                    if (functionResponses.length > 0) {\n                        wereFunctionsCalled = true;\n                        const typedResponseChunk = new GenerateContentResponse();\n                        typedResponseChunk.candidates = [\n                            {\n                                content: {\n                                    role: \"user\",\n                                    parts: functionResponses\n                                }\n                            }\n                        ];\n                        yield yield __await(typedResponseChunk);\n                        const newContents = [];\n                        newContents.push(...responseContents);\n                        newContents.push({\n                            role: \"user\",\n                            parts: functionResponses\n                        });\n                        const updatedContents = tContents(params.contents).concat(newContents);\n                        params.contents = updatedContents;\n                    } else {\n                        break;\n                    }\n                }\n            });\n        }(this, afcToolsMap, params);\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromVertex(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromMldev(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true){\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex((yield __await(chunk.json())));\n                            resp[\"sdkHttpResponse\"] = {\n                                headers: chunk.headers\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_2_1) {\n                        e_2 = {\n                            error: e_2_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        } finally{\n                            if (e_2) throw e_2.error;\n                        }\n                    }\n                });\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_3, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true){\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev((yield __await(chunk.json())));\n                            resp[\"sdkHttpResponse\"] = {\n                                headers: chunk.headers\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_3_1) {\n                        e_3 = {\n                            error: e_3_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        } finally{\n                            if (e_3) throw e_3.error;\n                        }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */ async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromVertex(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchEmbedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromMldev(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for generating images.\n     */ async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromVertex(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromMldev(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for editing an image.\n     */ async editImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = editImageParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = editImageResponseFromVertex(apiResponse);\n                const typedResp = new EditImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Private method for upscaling an image.\n     */ async upscaleImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = upscaleImageResponseFromVertex(apiResponse);\n                const typedResp = new UpscaleImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Recontextualizes an image.\n     *\n     * There are two types of recontextualization currently supported:\n     * 1) Imagen Product Recontext - Generate images of products in new scenes\n     *    and contexts.\n     * 2) Virtual Try-On: Generate images of persons modeling fashion products.\n     *\n     * @param params - The parameters for recontextualizing an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response1 = await ai.models.recontextImage({\n     *  model: 'imagen-product-recontext-preview-06-30',\n     *  source: {\n     *    prompt: 'In a modern kitchen setting.',\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);\n     *\n     * const response2 = await ai.models.recontextImage({\n     *  model: 'virtual-try-on-001',\n     *  source: {\n     *    personImage: personImage,\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */ async recontextImage(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = recontextImageParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = recontextImageResponseFromVertex(apiResponse);\n                const typedResp = new RecontextImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Segments an image, creating a mask of a specified area.\n     *\n     * @param params - The parameters for segmenting an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.segmentImage({\n     *  model: 'image-segmentation-001',\n     *  source: {\n     *    image: image,\n     *  },\n     *  config: {\n     *    mode: 'foreground',\n     *  },\n     * });\n     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);\n     * ```\n     */ async segmentImage(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = segmentImageParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = segmentImageResponseFromVertex(apiResponse);\n                const typedResp = new SegmentImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listModelsParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromVertex(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listModelsParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromMldev(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates a tuned model by its name.\n     *\n     * @param params - The parameters for updating the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.update({\n     *   model: 'tuned-model-name',\n     *   config: {\n     *     displayName: 'New display name',\n     *     description: 'New description',\n     *   },\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = updateModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a tuned model by its name.\n     *\n     * @param params - The parameters for deleting the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.delete({model: 'tuned-model-name'});\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteModelResponseFromVertex(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteModelResponseFromMldev(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */ async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromVertex(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromMldev(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */ async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:computeTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = computeTokensResponseFromVertex(apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Private method for generating videos.\n     */ async generateVideosInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromMldev(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Operations extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: true\n            });\n        } else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: false\n            });\n        }\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async get(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: true\n            });\n        } else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: false\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        } else {\n            const body = getOperationParametersToMldev(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(params);\n            path = formatMap(\"{resourceName}:fetchPredictOperation\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function blobToMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromNewSessionExpireTime = getValueByPath(fromObject, [\n        \"newSessionExpireTime\"\n    ]);\n    if (parentObject !== undefined && fromNewSessionExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"newSessionExpireTime\"\n        ], fromNewSessionExpireTime);\n    }\n    const fromUses = getValueByPath(fromObject, [\n        \"uses\"\n    ]);\n    if (parentObject !== undefined && fromUses != null) {\n        setValueByPath(parentObject, [\n            \"uses\"\n        ], fromUses);\n    }\n    const fromLiveConnectConstraints = getValueByPath(fromObject, [\n        \"liveConnectConstraints\"\n    ]);\n    if (parentObject !== undefined && fromLiveConnectConstraints != null) {\n        setValueByPath(parentObject, [\n            \"bidiGenerateContentSetup\"\n        ], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));\n    }\n    const fromLockAdditionalFields = getValueByPath(fromObject, [\n        \"lockAdditionalFields\"\n    ]);\n    if (parentObject !== undefined && fromLockAdditionalFields != null) {\n        setValueByPath(parentObject, [\n            \"fieldMask\"\n        ], fromLockAdditionalFields);\n    }\n    return toObject;\n}\nfunction createAuthTokenParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction fileDataToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    if (getValueByPath(fromObject, [\n        \"partialArgs\"\n    ]) !== undefined) {\n        throw new Error(\"partialArgs parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"willContinue\"\n    ]) !== undefined) {\n        throw new Error(\"willContinue parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction googleMapsToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"authConfig\"\n    ]) !== undefined) {\n        throw new Error(\"authConfig parameter is not supported in Gemini API.\");\n    }\n    const fromEnableWidget = getValueByPath(fromObject, [\n        \"enableWidget\"\n    ]);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, [\n            \"enableWidget\"\n        ], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"blockingConfidence\"\n    ]) !== undefined) {\n        throw new Error(\"blockingConfidence parameter is not supported in Gemini API.\");\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"thinkingConfig\"\n        ], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], fromProactivity);\n    }\n    if (getValueByPath(fromObject, [\n        \"explicitVadSignal\"\n    ]) !== undefined) {\n        throw new Error(\"explicitVadSignal parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction liveConnectConstraintsToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction partToMldev(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], functionCallToMldev(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction toolToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, [\n        \"fileSearch\"\n    ]);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, [\n            \"fileSearch\"\n        ], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToMldev(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], fromGoogleSearchRetrieval);\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], fromUrlContext);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns a comma-separated list of field masks from a given object.\n *\n * @param setup The object to extract field masks from.\n * @return A comma-separated list of field masks.\n */ function getFieldMasks(setup) {\n    const fields = [];\n    for(const key in setup){\n        if (Object.prototype.hasOwnProperty.call(setup, key)) {\n            const value = setup[key];\n            // 2nd layer, recursively get field masks see TODO(b/418290100)\n            if (typeof value === \"object\" && value != null && Object.keys(value).length > 0) {\n                const field = Object.keys(value).map((kk)=>`${key}.${kk}`);\n                fields.push(...field);\n            } else {\n                fields.push(key); // 1st layer\n            }\n        }\n    }\n    return fields.join(\",\");\n}\n/**\n * Converts bidiGenerateContentSetup.\n * @param requestDict - The request dictionary.\n * @param config - The configuration object.\n * @return - The modified request dictionary.\n */ function convertBidiSetupToTokenSetup(requestDict, config) {\n    // Convert bidiGenerateContentSetup from bidiGenerateContentSetup.setup.\n    let setupForMaskGeneration = null;\n    const bidiGenerateContentSetupValue = requestDict[\"bidiGenerateContentSetup\"];\n    if (typeof bidiGenerateContentSetupValue === \"object\" && bidiGenerateContentSetupValue !== null && \"setup\" in bidiGenerateContentSetupValue) {\n        // Now we know bidiGenerateContentSetupValue is an object and has a 'setup'\n        // property.\n        const innerSetup = bidiGenerateContentSetupValue.setup;\n        if (typeof innerSetup === \"object\" && innerSetup !== null) {\n            // Valid inner setup found.\n            requestDict[\"bidiGenerateContentSetup\"] = innerSetup;\n            setupForMaskGeneration = innerSetup;\n        } else {\n            // `bidiGenerateContentSetupValue.setup` is not a valid object; treat as\n            // if bidiGenerateContentSetup is invalid.\n            delete requestDict[\"bidiGenerateContentSetup\"];\n        }\n    } else if (bidiGenerateContentSetupValue !== undefined) {\n        // `bidiGenerateContentSetup` exists but not in the expected\n        // shape {setup: {...}}; treat as invalid.\n        delete requestDict[\"bidiGenerateContentSetup\"];\n    }\n    const preExistingFieldMask = requestDict[\"fieldMask\"];\n    // Handle mask generation setup.\n    if (setupForMaskGeneration) {\n        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);\n        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {\n            // Case 1: lockAdditionalFields is an empty array. Lock only fields from\n            // bidi setup.\n            if (generatedMaskFromBidi) {\n                // Only assign if mask is not empty\n                requestDict[\"fieldMask\"] = generatedMaskFromBidi;\n            } else {\n                delete requestDict[\"fieldMask\"]; // If mask is empty, effectively no\n            // specific fields locked by bidi\n            }\n        } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // Case 2: Lock fields from bidi setup + additional fields\n            // (preExistingFieldMask).\n            const generationConfigFields = [\n                \"temperature\",\n                \"topK\",\n                \"topP\",\n                \"maxOutputTokens\",\n                \"responseModalities\",\n                \"seed\",\n                \"speechConfig\"\n            ];\n            let mappedFieldsFromPreExisting = [];\n            if (preExistingFieldMask.length > 0) {\n                mappedFieldsFromPreExisting = preExistingFieldMask.map((field)=>{\n                    if (generationConfigFields.includes(field)) {\n                        return `generationConfig.${field}`;\n                    }\n                    return field; // Keep original field name if not in\n                // generationConfigFields\n                });\n            }\n            const finalMaskParts = [];\n            if (generatedMaskFromBidi) {\n                finalMaskParts.push(generatedMaskFromBidi);\n            }\n            if (mappedFieldsFromPreExisting.length > 0) {\n                finalMaskParts.push(...mappedFieldsFromPreExisting);\n            }\n            if (finalMaskParts.length > 0) {\n                requestDict[\"fieldMask\"] = finalMaskParts.join(\",\");\n            } else {\n                // If no fields from bidi and no valid additional fields from\n                // pre-existing mask.\n                delete requestDict[\"fieldMask\"];\n            }\n        } else {\n            // Case 3: \"Lock all fields\" (meaning, don't send a field_mask, let server\n            // defaults apply or all are mutable). This is hit if:\n            //  - `config.lockAdditionalFields` is undefined.\n            //  - `config.lockAdditionalFields` is non-empty, BUT\n            //  `preExistingFieldMask` is null, not a string, or an empty string.\n            delete requestDict[\"fieldMask\"];\n        }\n    } else {\n        // No valid `bidiGenerateContentSetup` was found or extracted.\n        // \"Lock additional null fields if any\".\n        if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // If there's a pre-existing field mask, it's a string, and it's not\n            // empty, then we should lock all fields.\n            requestDict[\"fieldMask\"] = preExistingFieldMask.join(\",\");\n        } else {\n            delete requestDict[\"fieldMask\"];\n        }\n    }\n    return requestDict;\n}\nclass Tokens extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates an ephemeral auth token resource.\n     *\n     * @experimental\n     *\n     * @remarks\n     * Ephemeral auth tokens is only supported in the Gemini Developer API.\n     * It can be used for the session connection to the Live constrained API.\n     * Support in v1alpha only.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created auth token.\n     *\n     * @example\n     * ```ts\n     * const ai = new GoogleGenAI({\n     *     apiKey: token.name,\n     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.\n     * });\n     *\n     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig\n     * // when using the token in Live API sessions. Each session connection can\n     * // use a different configuration.\n     * const config: CreateAuthTokenConfig = {\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 2: If LiveEphemeralParameters is set, lock all fields in\n     * // LiveConnectConfig when using the token in Live API sessions. For\n     * // example, changing `outputAudioTranscription` in the Live API\n     * // connection will be ignored by the API.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     }\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // set, lock LiveConnectConfig with set and additional fields (e.g.\n     * // responseModalities, systemInstruction, temperature in this example) when\n     * // using the token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: ['temperature'],\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // empty array, lock LiveConnectConfig with set fields (e.g.\n     * // responseModalities, systemInstruction in this example) when using the\n     * // token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: [],\n     * }\n     * const token = await ai.tokens.create(config);\n     * ```\n     */ async create(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"The client.tokens.create method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createAuthTokenParametersToMldev(this.apiClient, params);\n            path = formatMap(\"auth_tokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(transformedBody),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction deleteDocumentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromForce = getValueByPath(fromObject, [\n        \"force\"\n    ]);\n    if (parentObject !== undefined && fromForce != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"force\"\n        ], fromForce);\n    }\n    return toObject;\n}\nfunction deleteDocumentParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        deleteDocumentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getDocumentParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction listDocumentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listDocumentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromParent = getValueByPath(fromObject, [\n        \"parent\"\n    ]);\n    if (fromParent != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"parent\"\n        ], fromParent);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listDocumentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listDocumentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromDocuments = getValueByPath(fromObject, [\n        \"documents\"\n    ]);\n    if (fromDocuments != null) {\n        let transformedList = fromDocuments;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"documents\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Documents extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists documents.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of documents.\n         *\n         * @example\n         * ```ts\n         * const documents = await ai.documents.list({parent:'rag_store_name', config: {'pageSize': 2}});\n         * for await (const document of documents) {\n         *   console.log(document);\n         * }\n         * ```\n         */ this.list = async (params)=>{\n            return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x)=>this.listInternal({\n                    parent: params.parent,\n                    config: x.config\n                }), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Gets a Document.\n     *\n     * @param params - The parameters for getting a document.\n     * @return Document.\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getDocumentParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a Document.\n     *\n     * @param params - The parameters for deleting a document.\n     */ async delete(params) {\n        var _a, _b;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteDocumentParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listDocumentsParametersToMldev(params);\n            path = formatMap(\"{parent}/documents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listDocumentsResponseFromMldev(apiResponse);\n                const typedResp = new ListDocumentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class FileSearchStores extends BaseModule {\n    constructor(apiClient, documents = new Documents(apiClient)){\n        super();\n        this.apiClient = apiClient;\n        this.documents = documents;\n        /**\n         * Lists file search stores.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of file search stores.\n         *\n         * @example\n         * ```ts\n         * const fileSearchStores = await ai.fileSearchStores.list({config: {'pageSize': 2}});\n         * for await (const fileSearchStore of fileSearchStores) {\n         *   console.log(fileSearchStore);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to a given File Search Store.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadToFileSearchStoreParameters` interface.\n     *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a long running operation.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to a given file search store.\n     *\n     * ```ts\n     * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(operation.name);\n     * ```\n     */ async uploadToFileSearchStore(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Vertex AI does not support uploading files to a file search store.\");\n        }\n        return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);\n    }\n    /**\n     * Creates a File Search Store.\n     *\n     * @param params - The parameters for creating a File Search Store.\n     * @return FileSearchStore.\n     */ async create(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"fileSearchStores\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets a File Search Store.\n     *\n     * @param params - The parameters for getting a File Search Store.\n     * @return FileSearchStore.\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((resp)=>{\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a File Search Store.\n     *\n     * @param params - The parameters for deleting a File Search Store.\n     */ async delete(params) {\n        var _a, _b;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listFileSearchStoresParametersToMldev(params);\n            path = formatMap(\"fileSearchStores\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = listFileSearchStoresResponseFromMldev(apiResponse);\n                const typedResp = new ListFileSearchStoresResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async uploadToFileSearchStoreInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = uploadToFileSearchStoreParametersToMldev(params);\n            path = formatMap(\"upload/v1beta/{file_search_store_name}:uploadToFileSearchStore\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);\n                const typedResp = new UploadToFileSearchStoreResumableResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Imports a File from File Service to a FileSearchStore.\n     *\n     * This is a long-running operation, see aip.dev/151\n     *\n     * @param params - The parameters for importing a file to a file search store.\n     * @return ImportFileOperation.\n     */ async importFile(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = importFileParametersToMldev(params);\n            path = formatMap(\"{file_search_store_name}:importFile\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = importFileOperationFromMldev(apiResponse);\n                const typedResp = new ImportFileOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n/**\n * https://stackoverflow.com/a/2117523\n */ let uuid4Internal = function() {\n    const { crypto } = globalThis;\n    if (crypto === null || crypto === void 0 ? void 0 : crypto.randomUUID) {\n        uuid4Internal = crypto.randomUUID.bind(crypto);\n        return crypto.randomUUID();\n    }\n    const u8 = new Uint8Array(1);\n    const randomByte = crypto ? ()=>crypto.getRandomValues(u8)[0] : ()=>Math.random() * 0xff & 0xff;\n    return \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, (c)=>(+c ^ randomByte() & 15 >> +c / 4).toString(16));\n};\nconst uuid4 = ()=>uuid4Internal();\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nfunction isAbortError(err) {\n    return typeof err === \"object\" && err !== null && // Spec-compliant fetch implementations\n    (\"name\" in err && err.name === \"AbortError\" || // Expo fetch\n    \"message\" in err && String(err.message).includes(\"FetchRequestCanceledException\"));\n}\nconst castToError = (err)=>{\n    if (err instanceof Error) return err;\n    if (typeof err === \"object\" && err !== null) {\n        try {\n            if (Object.prototype.toString.call(err) === \"[object Error]\") {\n                // @ts-ignore - not all envs have native support for cause yet\n                const error = new Error(err.message, err.cause ? {\n                    cause: err.cause\n                } : {});\n                if (err.stack) error.stack = err.stack;\n                // @ts-ignore - not all envs have native support for cause yet\n                if (err.cause && !error.cause) error.cause = err.cause;\n                if (err.name) error.name = err.name;\n                return error;\n            }\n        } catch (_a) {}\n        try {\n            return new Error(JSON.stringify(err));\n        } catch (_b) {}\n    }\n    return new Error(err);\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nclass GeminiNextGenAPIClientError extends Error {\n}\nclass APIError extends GeminiNextGenAPIClientError {\n    constructor(status, error, message, headers){\n        super(`${APIError.makeMessage(status, error, message)}`);\n        this.status = status;\n        this.headers = headers;\n        this.error = error;\n    }\n    static makeMessage(status, error, message) {\n        const msg = (error === null || error === void 0 ? void 0 : error.message) ? typeof error.message === \"string\" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;\n        if (status && msg) {\n            return `${status} ${msg}`;\n        }\n        if (status) {\n            return `${status} status code (no body)`;\n        }\n        if (msg) {\n            return msg;\n        }\n        return \"(no status code or body)\";\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status || !headers) {\n            return new APIConnectionError({\n                message,\n                cause: castToError(errorResponse)\n            });\n        }\n        const error = errorResponse;\n        if (status === 400) {\n            return new BadRequestError(status, error, message, headers);\n        }\n        if (status === 401) {\n            return new AuthenticationError(status, error, message, headers);\n        }\n        if (status === 403) {\n            return new PermissionDeniedError(status, error, message, headers);\n        }\n        if (status === 404) {\n            return new NotFoundError(status, error, message, headers);\n        }\n        if (status === 409) {\n            return new ConflictError(status, error, message, headers);\n        }\n        if (status === 422) {\n            return new UnprocessableEntityError(status, error, message, headers);\n        }\n        if (status === 429) {\n            return new RateLimitError(status, error, message, headers);\n        }\n        if (status >= 500) {\n            return new InternalServerError(status, error, message, headers);\n        }\n        return new APIError(status, error, message, headers);\n    }\n}\nclass APIUserAbortError extends APIError {\n    constructor({ message } = {}){\n        super(undefined, undefined, message || \"Request was aborted.\", undefined);\n    }\n}\nclass APIConnectionError extends APIError {\n    constructor({ message, cause }){\n        super(undefined, undefined, message || \"Connection error.\", undefined);\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause) this.cause = cause;\n    }\n}\nclass APIConnectionTimeoutError extends APIConnectionError {\n    constructor({ message } = {}){\n        super({\n            message: message !== null && message !== void 0 ? message : \"Request timed out.\"\n        });\n    }\n}\nclass BadRequestError extends APIError {\n}\nclass AuthenticationError extends APIError {\n}\nclass PermissionDeniedError extends APIError {\n}\nclass NotFoundError extends APIError {\n}\nclass ConflictError extends APIError {\n}\nclass UnprocessableEntityError extends APIError {\n}\nclass RateLimitError extends APIError {\n}\nclass InternalServerError extends APIError {\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nconst isAbsoluteURL = (url)=>{\n    return startsWithSchemeRegexp.test(url);\n};\nlet isArrayInternal = (val)=>(isArrayInternal = Array.isArray, isArrayInternal(val));\nconst isArray = isArrayInternal;\nlet isReadonlyArrayInternal = isArray;\nconst isReadonlyArray = isReadonlyArrayInternal;\n// https://stackoverflow.com/a/34491287\nfunction isEmptyObj(obj) {\n    if (!obj) return true;\n    for(const _k in obj)return false;\n    return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nfunction hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nconst validatePositiveInteger = (name, n)=>{\n    if (typeof n !== \"number\" || !Number.isInteger(n)) {\n        throw new GeminiNextGenAPIClientError(`${name} must be an integer`);\n    }\n    if (n < 0) {\n        throw new GeminiNextGenAPIClientError(`${name} must be a positive integer`);\n    }\n    return n;\n};\nconst safeJSON = (text)=>{\n    try {\n        return JSON.parse(text);\n    } catch (err) {\n        return undefined;\n    }\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nconst sleep$1 = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const VERSION = \"0.0.1\";\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n/**\n * Note this does not detect 'browser'; for that, use getBrowserInfo().\n */ function getDetectedPlatform() {\n    if (typeof Deno !== \"undefined\" && Deno.build != null) {\n        return \"deno\";\n    }\n    if (typeof EdgeRuntime !== \"undefined\") {\n        return \"edge\";\n    }\n    if (Object.prototype.toString.call(typeof globalThis.process !== \"undefined\" ? globalThis.process : 0) === \"[object process]\") {\n        return \"node\";\n    }\n    return \"unknown\";\n}\nconst getPlatformProperties = ()=>{\n    var _a, _b, _c, _d, _e;\n    const detectedPlatform = getDetectedPlatform();\n    if (detectedPlatform === \"deno\") {\n        return {\n            \"X-Stainless-Lang\": \"js\",\n            \"X-Stainless-Package-Version\": VERSION,\n            \"X-Stainless-OS\": normalizePlatform(Deno.build.os),\n            \"X-Stainless-Arch\": normalizeArch(Deno.build.arch),\n            \"X-Stainless-Runtime\": \"deno\",\n            \"X-Stainless-Runtime-Version\": typeof Deno.version === \"string\" ? Deno.version : (_b = (_a = Deno.version) === null || _a === void 0 ? void 0 : _a.deno) !== null && _b !== void 0 ? _b : \"unknown\"\n        };\n    }\n    if (typeof EdgeRuntime !== \"undefined\") {\n        return {\n            \"X-Stainless-Lang\": \"js\",\n            \"X-Stainless-Package-Version\": VERSION,\n            \"X-Stainless-OS\": \"Unknown\",\n            \"X-Stainless-Arch\": `other:${EdgeRuntime}`,\n            \"X-Stainless-Runtime\": \"edge\",\n            \"X-Stainless-Runtime-Version\": globalThis.process.version\n        };\n    }\n    // Check if Node.js\n    if (detectedPlatform === \"node\") {\n        return {\n            \"X-Stainless-Lang\": \"js\",\n            \"X-Stainless-Package-Version\": VERSION,\n            \"X-Stainless-OS\": normalizePlatform((_c = globalThis.process.platform) !== null && _c !== void 0 ? _c : \"unknown\"),\n            \"X-Stainless-Arch\": normalizeArch((_d = globalThis.process.arch) !== null && _d !== void 0 ? _d : \"unknown\"),\n            \"X-Stainless-Runtime\": \"node\",\n            \"X-Stainless-Runtime-Version\": (_e = globalThis.process.version) !== null && _e !== void 0 ? _e : \"unknown\"\n        };\n    }\n    const browserInfo = getBrowserInfo();\n    if (browserInfo) {\n        return {\n            \"X-Stainless-Lang\": \"js\",\n            \"X-Stainless-Package-Version\": VERSION,\n            \"X-Stainless-OS\": \"Unknown\",\n            \"X-Stainless-Arch\": \"unknown\",\n            \"X-Stainless-Runtime\": `browser:${browserInfo.browser}`,\n            \"X-Stainless-Runtime-Version\": browserInfo.version\n        };\n    }\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        \"X-Stainless-Lang\": \"js\",\n        \"X-Stainless-Package-Version\": VERSION,\n        \"X-Stainless-OS\": \"Unknown\",\n        \"X-Stainless-Arch\": \"unknown\",\n        \"X-Stainless-Runtime\": \"unknown\",\n        \"X-Stainless-Runtime-Version\": \"unknown\"\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n    if (typeof navigator === \"undefined\" || !navigator) {\n        return null;\n    }\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        {\n            key: \"edge\",\n            pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n        },\n        {\n            key: \"ie\",\n            pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n        },\n        {\n            key: \"ie\",\n            pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n        },\n        {\n            key: \"chrome\",\n            pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n        },\n        {\n            key: \"firefox\",\n            pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n        },\n        {\n            key: \"safari\",\n            pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/\n        }\n    ];\n    // Find the FIRST matching browser\n    for (const { key, pattern } of browserPatterns){\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return {\n                browser: key,\n                version: `${major}.${minor}.${patch}`\n            };\n        }\n    }\n    return null;\n}\nconst normalizeArch = (arch)=>{\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === \"x32\") return \"x32\";\n    if (arch === \"x86_64\" || arch === \"x64\") return \"x64\";\n    if (arch === \"arm\") return \"arm\";\n    if (arch === \"aarch64\" || arch === \"arm64\") return \"arm64\";\n    if (arch) return `other:${arch}`;\n    return \"unknown\";\n};\nconst normalizePlatform = (platform)=>{\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes(\"ios\")) return \"iOS\";\n    if (platform === \"android\") return \"Android\";\n    if (platform === \"darwin\") return \"MacOS\";\n    if (platform === \"win32\") return \"Windows\";\n    if (platform === \"freebsd\") return \"FreeBSD\";\n    if (platform === \"openbsd\") return \"OpenBSD\";\n    if (platform === \"linux\") return \"Linux\";\n    if (platform) return `Other:${platform}`;\n    return \"Unknown\";\n};\nlet _platformHeaders;\nconst getPlatformHeaders = ()=>{\n    return _platformHeaders !== null && _platformHeaders !== void 0 ? _platformHeaders : _platformHeaders = getPlatformProperties();\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function getDefaultFetch() {\n    if (typeof fetch !== \"undefined\") {\n        return fetch;\n    }\n    throw new Error(\"`fetch` is not defined as a global; Either pass `fetch` to the client, `new GeminiNextGenAPIClient({ fetch })` or polyfill the global, `globalThis.fetch = fetch`\");\n}\nfunction makeReadableStream(...args) {\n    const ReadableStream = globalThis.ReadableStream;\n    if (typeof ReadableStream === \"undefined\") {\n        // Note: All of the platforms / runtimes we officially support already define\n        // `ReadableStream` as a global, so this should only ever be hit on unsupported runtimes.\n        throw new Error(\"`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`\");\n    }\n    return new ReadableStream(...args);\n}\nfunction ReadableStreamFrom(iterable) {\n    let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n    return makeReadableStream({\n        start () {},\n        async pull (controller) {\n            const { done, value } = await iter.next();\n            if (done) {\n                controller.close();\n            } else {\n                controller.enqueue(value);\n            }\n        },\n        async cancel () {\n            var _a;\n            await ((_a = iter.return) === null || _a === void 0 ? void 0 : _a.call(iter));\n        }\n    });\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */ function ReadableStreamToAsyncIterable(stream) {\n    if (stream[Symbol.asyncIterator]) return stream;\n    const reader = stream.getReader();\n    return {\n        async next () {\n            try {\n                const result = await reader.read();\n                if (result === null || result === void 0 ? void 0 : result.done) reader.releaseLock(); // release lock when stream becomes closed\n                return result;\n            } catch (e) {\n                reader.releaseLock(); // release lock when stream becomes errored\n                throw e;\n            }\n        },\n        async return () {\n            const cancelPromise = reader.cancel();\n            reader.releaseLock();\n            await cancelPromise;\n            return {\n                done: true,\n                value: undefined\n            };\n        },\n        [Symbol.asyncIterator] () {\n            return this;\n        }\n    };\n}\n/**\n * Cancels a ReadableStream we don't need to consume.\n * See https://undici.nodejs.org/#/?id=garbage-collection\n */ async function CancelReadableStream(stream) {\n    var _a, _b;\n    if (stream === null || typeof stream !== \"object\") return;\n    if (stream[Symbol.asyncIterator]) {\n        await ((_b = (_a = stream[Symbol.asyncIterator]()).return) === null || _b === void 0 ? void 0 : _b.call(_a));\n        return;\n    }\n    const reader = stream.getReader();\n    const cancelPromise = reader.cancel();\n    reader.releaseLock();\n    await cancelPromise;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const FallbackEncoder = ({ headers, body })=>{\n    return {\n        bodyHeaders: {\n            \"content-type\": \"application/json\"\n        },\n        body: JSON.stringify(body)\n    };\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const checkFileSupport = ()=>{\n    var _a;\n    if (typeof File === \"undefined\") {\n        const { process: process1 } = globalThis;\n        const isOldNode = typeof ((_a = process1 === null || process1 === void 0 ? void 0 : process1.versions) === null || _a === void 0 ? void 0 : _a.node) === \"string\" && parseInt(process1.versions.node.split(\".\")) < 20;\n        throw new Error(\"`File` is not defined as a global, which is required for file uploads.\" + (isOldNode ? \" Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`.\" : \"\"));\n    }\n};\n/**\n * Construct a `File` instance. This is used to ensure a helpful error is thrown\n * for environments that don't define a global `File` yet.\n */ function makeFile(fileBits, fileName, options) {\n    checkFileSupport();\n    return new File(fileBits, fileName !== null && fileName !== void 0 ? fileName : \"unknown_file\", options);\n}\nfunction getName(value) {\n    return (typeof value === \"object\" && value !== null && (\"name\" in value && value.name && String(value.name) || \"url\" in value && value.url && String(value.url) || \"filename\" in value && value.filename && String(value.filename) || \"path\" in value && value.path && String(value.path)) || \"\").split(/[\\\\/]/).pop() || undefined;\n}\nconst isAsyncIterable = (value)=>value != null && typeof value === \"object\" && typeof value[Symbol.asyncIterator] === \"function\";\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */ const isBlobLike = (value)=>value != null && typeof value === \"object\" && typeof value.size === \"number\" && typeof value.type === \"string\" && typeof value.text === \"function\" && typeof value.slice === \"function\" && typeof value.arrayBuffer === \"function\";\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */ const isFileLike = (value)=>value != null && typeof value === \"object\" && typeof value.name === \"string\" && typeof value.lastModified === \"number\" && isBlobLike(value);\nconst isResponseLike = (value)=>value != null && typeof value === \"object\" && typeof value.url === \"string\" && typeof value.blob === \"function\";\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file. Can be an {@link Uploadable}, BlobLikePart, or AsyncIterable of BlobLikeParts\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */ async function toFile(value, name, options) {\n    checkFileSupport();\n    // If it's a promise, resolve it.\n    value = await value;\n    // If we've been given a `File` we don't need to do anything\n    if (isFileLike(value)) {\n        if (value instanceof File) {\n            return value;\n        }\n        return makeFile([\n            await value.arrayBuffer()\n        ], value.name);\n    }\n    if (isResponseLike(value)) {\n        const blob = await value.blob();\n        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop());\n        return makeFile(await getBytes(blob), name, options);\n    }\n    const parts = await getBytes(value);\n    name || (name = getName(value));\n    if (!(options === null || options === void 0 ? void 0 : options.type)) {\n        const type = parts.find((part)=>typeof part === \"object\" && \"type\" in part && part.type);\n        if (typeof type === \"string\") {\n            options = Object.assign(Object.assign({}, options), {\n                type\n            });\n        }\n    }\n    return makeFile(parts, name, options);\n}\nasync function getBytes(value) {\n    var _a, e_1, _b, _c;\n    var _d;\n    let parts = [];\n    if (typeof value === \"string\" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n    value instanceof ArrayBuffer) {\n        parts.push(value);\n    } else if (isBlobLike(value)) {\n        parts.push(value instanceof Blob ? value : await value.arrayBuffer());\n    } else if (isAsyncIterable(value) // includes Readable, ReadableStream, etc.\n    ) {\n        try {\n            for(var _e = true, value_1 = __asyncValues(value), value_1_1; value_1_1 = await value_1.next(), _a = value_1_1.done, !_a; _e = true){\n                _c = value_1_1.value;\n                _e = false;\n                const chunk = _c;\n                parts.push(...await getBytes(chunk)); // TODO, consider validating?\n            }\n        } catch (e_1_1) {\n            e_1 = {\n                error: e_1_1\n            };\n        } finally{\n            try {\n                if (!_e && !_a && (_b = value_1.return)) await _b.call(value_1);\n            } finally{\n                if (e_1) throw e_1.error;\n            }\n        }\n    } else {\n        const constructor = (_d = value === null || value === void 0 ? void 0 : value.constructor) === null || _d === void 0 ? void 0 : _d.name;\n        throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : \"\"}${propsForError(value)}`);\n    }\n    return parts;\n}\nfunction propsForError(value) {\n    if (typeof value !== \"object\" || value === null) return \"\";\n    const props = Object.getOwnPropertyNames(value);\n    return `; props: [${props.map((p)=>`\"${p}\"`).join(\", \")}]`;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class APIResource {\n    constructor(client){\n        this._client = client;\n    }\n}\n/**\n * The key path from the client. For example, a resource accessible as `client.resource.subresource` would\n * have a property `static override readonly _key = Object.freeze(['resource', 'subresource'] as const);`.\n */ APIResource._key = [];\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Percent-encode everything that isn't safe to have in a path without encoding safe chars.\n *\n * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:\n * > unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n * > sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * > pchar       = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n */ function encodeURIPath(str) {\n    return str.replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);\n}\nconst EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));\nconst createPathTagFunction = (pathEncoder = encodeURIPath)=>function path(statics, ...params) {\n        // If there are no params, no processing is needed.\n        if (statics.length === 1) return statics[0];\n        let postPath = false;\n        const invalidSegments = [];\n        const path1 = statics.reduce((previousValue, currentValue, index)=>{\n            var _a, _b, _c;\n            if (/[?#]/.test(currentValue)) {\n                postPath = true;\n            }\n            const value = params[index];\n            let encoded = (postPath ? encodeURIComponent : pathEncoder)(\"\" + value);\n            if (index !== params.length && (value == null || typeof value === \"object\" && // handle values from other realms\n            value.toString === ((_c = Object.getPrototypeOf((_b = Object.getPrototypeOf((_a = value.hasOwnProperty) !== null && _a !== void 0 ? _a : EMPTY)) !== null && _b !== void 0 ? _b : EMPTY)) === null || _c === void 0 ? void 0 : _c.toString))) {\n                encoded = value + \"\";\n                invalidSegments.push({\n                    start: previousValue.length + currentValue.length,\n                    length: encoded.length,\n                    error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`\n                });\n            }\n            return previousValue + currentValue + (index === params.length ? \"\" : encoded);\n        }, \"\");\n        const pathOnly = path1.split(/[?#]/, 1)[0];\n        const invalidSegmentPattern = /(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)/gi;\n        let match;\n        // Find all invalid segments\n        while((match = invalidSegmentPattern.exec(pathOnly)) !== null){\n            invalidSegments.push({\n                start: match.index,\n                length: match[0].length,\n                error: `Value \"${match[0]}\" can\\'t be safely passed as a path parameter`\n            });\n        }\n        invalidSegments.sort((a, b)=>a.start - b.start);\n        if (invalidSegments.length > 0) {\n            let lastEnd = 0;\n            const underline = invalidSegments.reduce((acc, segment)=>{\n                const spaces = \" \".repeat(segment.start - lastEnd);\n                const arrows = \"^\".repeat(segment.length);\n                lastEnd = segment.start + segment.length;\n                return acc + spaces + arrows;\n            }, \"\");\n            throw new GeminiNextGenAPIClientError(`Path parameters result in path with invalid segments:\\n${invalidSegments.map((e)=>e.error).join(\"\\n\")}\\n${path1}\\n${underline}`);\n        }\n        return path1;\n    };\n/**\n * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.\n */ const path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class BaseInteractions extends APIResource {\n    create(params, options) {\n        var _a;\n        const { api_version = this._client.apiVersion } = params, body = __rest(params, [\n            \"api_version\"\n        ]);\n        if (\"model\" in body && \"agent_config\" in body) {\n            throw new GeminiNextGenAPIClientError(`Invalid request: specified \\`model\\` and \\`agent_config\\`. If specifying \\`model\\`, use \\`generation_config\\`.`);\n        }\n        if (\"agent\" in body && \"generation_config\" in body) {\n            throw new GeminiNextGenAPIClientError(`Invalid request: specified \\`agent\\` and \\`generation_config\\`. If specifying \\`agent\\`, use \\`agent_config\\`.`);\n        }\n        return this._client.post(path`/${api_version}/interactions`, Object.assign(Object.assign({\n            body\n        }, options), {\n            stream: (_a = params.stream) !== null && _a !== void 0 ? _a : false\n        }));\n    }\n    /**\n     * Deletes the interaction by id.\n     *\n     * @example\n     * ```ts\n     * const interaction = await client.interactions.delete('id');\n     * ```\n     */ delete(id, params = {}, options) {\n        const { api_version = this._client.apiVersion } = params !== null && params !== void 0 ? params : {};\n        return this._client.delete(path`/${api_version}/interactions/${id}`, options);\n    }\n    /**\n     * Cancels an interaction by id. This only applies to background interactions that are still running.\n     *\n     * @example\n     * ```ts\n     * const interaction = await client.interactions.cancel('id');\n     * ```\n     */ cancel(id, params = {}, options) {\n        const { api_version = this._client.apiVersion } = params !== null && params !== void 0 ? params : {};\n        return this._client.post(path`/${api_version}/interactions/${id}/cancel`, options);\n    }\n    get(id, params = {}, options) {\n        var _a;\n        const _b = params !== null && params !== void 0 ? params : {}, { api_version = this._client.apiVersion } = _b, query = __rest(_b, [\n            \"api_version\"\n        ]);\n        return this._client.get(path`/${api_version}/interactions/${id}`, Object.assign(Object.assign({\n            query\n        }, options), {\n            stream: (_a = params === null || params === void 0 ? void 0 : params.stream) !== null && _a !== void 0 ? _a : false\n        }));\n    }\n}\nBaseInteractions._key = Object.freeze([\n    \"interactions\"\n]);\nclass Interactions extends BaseInteractions {\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function concatBytes(buffers) {\n    let length = 0;\n    for (const buffer of buffers){\n        length += buffer.length;\n    }\n    const output = new Uint8Array(length);\n    let index = 0;\n    for (const buffer of buffers){\n        output.set(buffer, index);\n        index += buffer.length;\n    }\n    return output;\n}\nlet encodeUTF8_;\nfunction encodeUTF8(str) {\n    let encoder;\n    return (encodeUTF8_ !== null && encodeUTF8_ !== void 0 ? encodeUTF8_ : (encoder = new globalThis.TextEncoder(), encodeUTF8_ = encoder.encode.bind(encoder)))(str);\n}\nlet decodeUTF8_;\nfunction decodeUTF8(bytes) {\n    let decoder;\n    return (decodeUTF8_ !== null && decodeUTF8_ !== void 0 ? decodeUTF8_ : (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */ class LineDecoder {\n    constructor(){\n        this.buffer = new Uint8Array();\n        this.carriageReturnIndex = null;\n    }\n    decode(chunk) {\n        if (chunk == null) {\n            return [];\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === \"string\" ? encodeUTF8(chunk) : chunk;\n        this.buffer = concatBytes([\n            this.buffer,\n            binaryChunk\n        ]);\n        const lines = [];\n        let patternIndex;\n        while((patternIndex = findNewlineIndex(this.buffer, this.carriageReturnIndex)) != null){\n            if (patternIndex.carriage && this.carriageReturnIndex == null) {\n                // skip until we either get a corresponding `\\n`, a new `\\r` or nothing\n                this.carriageReturnIndex = patternIndex.index;\n                continue;\n            }\n            // we got double \\r or \\rtext\\n\n            if (this.carriageReturnIndex != null && (patternIndex.index !== this.carriageReturnIndex + 1 || patternIndex.carriage)) {\n                lines.push(decodeUTF8(this.buffer.subarray(0, this.carriageReturnIndex - 1)));\n                this.buffer = this.buffer.subarray(this.carriageReturnIndex);\n                this.carriageReturnIndex = null;\n                continue;\n            }\n            const endIndex = this.carriageReturnIndex !== null ? patternIndex.preceding - 1 : patternIndex.preceding;\n            const line = decodeUTF8(this.buffer.subarray(0, endIndex));\n            lines.push(line);\n            this.buffer = this.buffer.subarray(patternIndex.index);\n            this.carriageReturnIndex = null;\n        }\n        return lines;\n    }\n    flush() {\n        if (!this.buffer.length) {\n            return [];\n        }\n        return this.decode(\"\\n\");\n    }\n}\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set([\n    \"\\n\",\n    \"\\r\"\n]);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/**\n * This function searches the buffer for the end patterns, (\\r or \\n)\n * and returns an object with the index preceding the matched newline and the\n * index after the newline char. `null` is returned if no new line is found.\n *\n * ```ts\n * findNewLineIndex('abc\\ndef') -> { preceding: 2, index: 3 }\n * ```\n */ function findNewlineIndex(buffer, startIndex) {\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for(let i = startIndex !== null && startIndex !== void 0 ? startIndex : 0; i < buffer.length; i++){\n        if (buffer[i] === newline) {\n            return {\n                preceding: i,\n                index: i + 1,\n                carriage: false\n            };\n        }\n        if (buffer[i] === carriage) {\n            return {\n                preceding: i,\n                index: i + 1,\n                carriage: true\n            };\n        }\n    }\n    return null;\n}\nfunction findDoubleNewlineIndex(buffer) {\n    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n    // and returns the index right after the first occurrence of any pattern,\n    // or -1 if none of the patterns are found.\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for(let i = 0; i < buffer.length - 1; i++){\n        if (buffer[i] === newline && buffer[i + 1] === newline) {\n            // \\n\\n\n            return i + 2;\n        }\n        if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n            // \\r\\r\n            return i + 2;\n        }\n        if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {\n            // \\r\\n\\r\\n\n            return i + 4;\n        }\n    }\n    return -1;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nconst levelNumbers = {\n    off: 0,\n    error: 200,\n    warn: 300,\n    info: 400,\n    debug: 500\n};\nconst parseLogLevel = (maybeLevel, sourceName, client)=>{\n    if (!maybeLevel) {\n        return undefined;\n    }\n    if (hasOwn(levelNumbers, maybeLevel)) {\n        return maybeLevel;\n    }\n    loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);\n    return undefined;\n};\nfunction noop() {}\nfunction makeLogFn(fnLevel, logger, logLevel) {\n    if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {\n        return noop;\n    } else {\n        // Don't wrap logger functions, we want the stacktrace intact!\n        return logger[fnLevel].bind(logger);\n    }\n}\nconst noopLogger = {\n    error: noop,\n    warn: noop,\n    info: noop,\n    debug: noop\n};\nlet cachedLoggers = /* @__PURE__ */ new WeakMap();\nfunction loggerFor(client) {\n    var _a;\n    const logger = client.logger;\n    const logLevel = (_a = client.logLevel) !== null && _a !== void 0 ? _a : \"off\";\n    if (!logger) {\n        return noopLogger;\n    }\n    const cachedLogger = cachedLoggers.get(logger);\n    if (cachedLogger && cachedLogger[0] === logLevel) {\n        return cachedLogger[1];\n    }\n    const levelLogger = {\n        error: makeLogFn(\"error\", logger, logLevel),\n        warn: makeLogFn(\"warn\", logger, logLevel),\n        info: makeLogFn(\"info\", logger, logLevel),\n        debug: makeLogFn(\"debug\", logger, logLevel)\n    };\n    cachedLoggers.set(logger, [\n        logLevel,\n        levelLogger\n    ]);\n    return levelLogger;\n}\nconst formatRequestDetails = (details)=>{\n    if (details.options) {\n        details.options = Object.assign({}, details.options);\n        delete details.options[\"headers\"]; // redundant + leaks internals\n    }\n    if (details.headers) {\n        details.headers = Object.fromEntries((details.headers instanceof Headers ? [\n            ...details.headers\n        ] : Object.entries(details.headers)).map(([name, value])=>[\n                name,\n                name.toLowerCase() === \"x-goog-api-key\" || name.toLowerCase() === \"authorization\" || name.toLowerCase() === \"cookie\" || name.toLowerCase() === \"set-cookie\" ? \"***\" : value\n            ]));\n    }\n    if (\"retryOfRequestLogID\" in details) {\n        if (details.retryOfRequestLogID) {\n            details.retryOf = details.retryOfRequestLogID;\n        }\n        delete details.retryOfRequestLogID;\n    }\n    return details;\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Stream {\n    constructor(iterator, controller, client){\n        this.iterator = iterator;\n        this.controller = controller;\n        this.client = client;\n    }\n    static fromSSEResponse(response, controller, client) {\n        let consumed = false;\n        const logger = client ? loggerFor(client) : console;\n        function iterator() {\n            return __asyncGenerator(this, arguments, function* iterator_1() {\n                var _a, e_1, _b, _c;\n                if (consumed) {\n                    throw new GeminiNextGenAPIClientError(\"Cannot iterate over a consumed stream, use `.tee()` to split the stream.\");\n                }\n                consumed = true;\n                let done = false;\n                try {\n                    try {\n                        for(var _d = true, _e = __asyncValues(_iterSSEMessages(response, controller)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true){\n                            _c = _f.value;\n                            _d = false;\n                            const sse = _c;\n                            if (done) continue;\n                            if (sse.data.startsWith(\"[DONE]\")) {\n                                done = true;\n                                continue;\n                            } else {\n                                try {\n                                    // @ts-ignore\n                                    yield yield __await(JSON.parse(sse.data));\n                                } catch (e) {\n                                    logger.error(`Could not parse message into JSON:`, sse.data);\n                                    logger.error(`From chunk:`, sse.raw);\n                                    throw e;\n                                }\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                    done = true;\n                } catch (e) {\n                    // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                    if (isAbortError(e)) return yield __await(void 0);\n                    throw e;\n                } finally{\n                    // If the user `break`s, abort the ongoing request.\n                    if (!done) controller.abort();\n                }\n            });\n        }\n        return new Stream(iterator, controller, client);\n    }\n    /**\n     * Generates a Stream from a newline-separated ReadableStream\n     * where each item is a JSON value.\n     */ static fromReadableStream(readableStream, controller, client) {\n        let consumed = false;\n        function iterLines() {\n            return __asyncGenerator(this, arguments, function* iterLines_1() {\n                var _a, e_2, _b, _c;\n                const lineDecoder = new LineDecoder();\n                const iter = ReadableStreamToAsyncIterable(readableStream);\n                try {\n                    for(var _d = true, iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield __await(iter_1.next()), _a = iter_1_1.done, !_a; _d = true){\n                        _c = iter_1_1.value;\n                        _d = false;\n                        const chunk = _c;\n                        for (const line of lineDecoder.decode(chunk)){\n                            yield yield __await(line);\n                        }\n                    }\n                } catch (e_2_1) {\n                    e_2 = {\n                        error: e_2_1\n                    };\n                } finally{\n                    try {\n                        if (!_d && !_a && (_b = iter_1.return)) yield __await(_b.call(iter_1));\n                    } finally{\n                        if (e_2) throw e_2.error;\n                    }\n                }\n                for (const line of lineDecoder.flush()){\n                    yield yield __await(line);\n                }\n            });\n        }\n        function iterator() {\n            return __asyncGenerator(this, arguments, function* iterator_2() {\n                var _a, e_3, _b, _c;\n                if (consumed) {\n                    throw new GeminiNextGenAPIClientError(\"Cannot iterate over a consumed stream, use `.tee()` to split the stream.\");\n                }\n                consumed = true;\n                let done = false;\n                try {\n                    try {\n                        for(var _d = true, _e = __asyncValues(iterLines()), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true){\n                            _c = _f.value;\n                            _d = false;\n                            const line = _c;\n                            if (done) continue;\n                            // @ts-ignore\n                            if (line) yield yield __await(JSON.parse(line));\n                        }\n                    } catch (e_3_1) {\n                        e_3 = {\n                            error: e_3_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n                        } finally{\n                            if (e_3) throw e_3.error;\n                        }\n                    }\n                    done = true;\n                } catch (e) {\n                    // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                    if (isAbortError(e)) return yield __await(void 0);\n                    throw e;\n                } finally{\n                    // If the user `break`s, abort the ongoing request.\n                    if (!done) controller.abort();\n                }\n            });\n        }\n        return new Stream(iterator, controller, client);\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterator();\n    }\n    /**\n     * Splits the stream into two streams which can be\n     * independently read from at different speeds.\n     */ tee() {\n        const left = [];\n        const right = [];\n        const iterator = this.iterator();\n        const teeIterator = (queue)=>{\n            return {\n                next: ()=>{\n                    if (queue.length === 0) {\n                        const result = iterator.next();\n                        left.push(result);\n                        right.push(result);\n                    }\n                    return queue.shift();\n                }\n            };\n        };\n        return [\n            new Stream(()=>teeIterator(left), this.controller, this.client),\n            new Stream(()=>teeIterator(right), this.controller, this.client)\n        ];\n    }\n    /**\n     * Converts this stream to a newline-separated ReadableStream of\n     * JSON stringified values in the stream\n     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n     */ toReadableStream() {\n        const self = this;\n        let iter;\n        return makeReadableStream({\n            async start () {\n                iter = self[Symbol.asyncIterator]();\n            },\n            async pull (ctrl) {\n                try {\n                    const { value, done } = await iter.next();\n                    if (done) return ctrl.close();\n                    const bytes = encodeUTF8(JSON.stringify(value) + \"\\n\");\n                    ctrl.enqueue(bytes);\n                } catch (err) {\n                    ctrl.error(err);\n                }\n            },\n            async cancel () {\n                var _a;\n                await ((_a = iter.return) === null || _a === void 0 ? void 0 : _a.call(iter));\n            }\n        });\n    }\n}\nfunction _iterSSEMessages(response, controller) {\n    return __asyncGenerator(this, arguments, function* _iterSSEMessages_1() {\n        var _a, e_4, _b, _c;\n        if (!response.body) {\n            controller.abort();\n            if (typeof globalThis.navigator !== \"undefined\" && globalThis.navigator.product === \"ReactNative\") {\n                throw new GeminiNextGenAPIClientError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);\n            }\n            throw new GeminiNextGenAPIClientError(`Attempted to iterate over a response with no body`);\n        }\n        const sseDecoder = new SSEDecoder();\n        const lineDecoder = new LineDecoder();\n        const iter = ReadableStreamToAsyncIterable(response.body);\n        try {\n            for(var _d = true, _e = __asyncValues(iterSSEChunks(iter)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true){\n                _c = _f.value;\n                _d = false;\n                const sseChunk = _c;\n                for (const line of lineDecoder.decode(sseChunk)){\n                    const sse = sseDecoder.decode(line);\n                    if (sse) yield yield __await(sse);\n                }\n            }\n        } catch (e_4_1) {\n            e_4 = {\n                error: e_4_1\n            };\n        } finally{\n            try {\n                if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n            } finally{\n                if (e_4) throw e_4.error;\n            }\n        }\n        for (const line of lineDecoder.flush()){\n            const sse = sseDecoder.decode(line);\n            if (sse) yield yield __await(sse);\n        }\n    });\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */ function iterSSEChunks(iterator) {\n    return __asyncGenerator(this, arguments, function* iterSSEChunks_1() {\n        var _a, e_5, _b, _c;\n        let data = new Uint8Array();\n        try {\n            for(var _d = true, iterator_3 = __asyncValues(iterator), iterator_3_1; iterator_3_1 = yield __await(iterator_3.next()), _a = iterator_3_1.done, !_a; _d = true){\n                _c = iterator_3_1.value;\n                _d = false;\n                const chunk = _c;\n                if (chunk == null) {\n                    continue;\n                }\n                const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === \"string\" ? encodeUTF8(chunk) : chunk;\n                let newData = new Uint8Array(data.length + binaryChunk.length);\n                newData.set(data);\n                newData.set(binaryChunk, data.length);\n                data = newData;\n                let patternIndex;\n                while((patternIndex = findDoubleNewlineIndex(data)) !== -1){\n                    yield yield __await(data.slice(0, patternIndex));\n                    data = data.slice(patternIndex);\n                }\n            }\n        } catch (e_5_1) {\n            e_5 = {\n                error: e_5_1\n            };\n        } finally{\n            try {\n                if (!_d && !_a && (_b = iterator_3.return)) yield __await(_b.call(iterator_3));\n            } finally{\n                if (e_5) throw e_5.error;\n            }\n        }\n        if (data.length > 0) {\n            yield yield __await(data);\n        }\n    });\n}\nclass SSEDecoder {\n    constructor(){\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n    }\n    decode(line) {\n        if (line.endsWith(\"\\r\")) {\n            line = line.substring(0, line.length - 1);\n        }\n        if (!line) {\n            // empty line and we didn't previously encounter any messages\n            if (!this.event && !this.data.length) return null;\n            const sse = {\n                event: this.event,\n                data: this.data.join(\"\\n\"),\n                raw: this.chunks\n            };\n            this.event = null;\n            this.data = [];\n            this.chunks = [];\n            return sse;\n        }\n        this.chunks.push(line);\n        if (line.startsWith(\":\")) {\n            return null;\n        }\n        let [fieldname, _, value] = partition(line, \":\");\n        if (value.startsWith(\" \")) {\n            value = value.substring(1);\n        }\n        if (fieldname === \"event\") {\n            this.event = value;\n        } else if (fieldname === \"data\") {\n            this.data.push(value);\n        }\n        return null;\n    }\n}\nfunction partition(str, delimiter) {\n    const index = str.indexOf(delimiter);\n    if (index !== -1) {\n        return [\n            str.substring(0, index),\n            delimiter,\n            str.substring(index + delimiter.length)\n        ];\n    }\n    return [\n        str,\n        \"\",\n        \"\"\n    ];\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ async function defaultParseResponse(client, props) {\n    const { response, requestLogID, retryOfRequestLogID, startTime } = props;\n    const body = await (async ()=>{\n        var _a;\n        if (props.options.stream) {\n            loggerFor(client).debug(\"response\", response.status, response.url, response.headers, response.body);\n            // Note: there is an invariant here that isn't represented in the type system\n            // that if you set `stream: true` the response type must also be `Stream<T>`\n            if (props.options.__streamClass) {\n                return props.options.__streamClass.fromSSEResponse(response, props.controller, client);\n            }\n            return Stream.fromSSEResponse(response, props.controller, client);\n        }\n        // fetch refuses to read the body when the status code is 204.\n        if (response.status === 204) {\n            return null;\n        }\n        if (props.options.__binaryResponse) {\n            return response;\n        }\n        const contentType = response.headers.get(\"content-type\");\n        const mediaType = (_a = contentType === null || contentType === void 0 ? void 0 : contentType.split(\";\")[0]) === null || _a === void 0 ? void 0 : _a.trim();\n        const isJSON = (mediaType === null || mediaType === void 0 ? void 0 : mediaType.includes(\"application/json\")) || (mediaType === null || mediaType === void 0 ? void 0 : mediaType.endsWith(\"+json\"));\n        if (isJSON) {\n            const json = await response.json();\n            return json;\n        }\n        const text = await response.text();\n        return text;\n    })();\n    loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({\n        retryOfRequestLogID,\n        url: response.url,\n        status: response.status,\n        body,\n        durationMs: Date.now() - startTime\n    }));\n    return body;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */ class APIPromise extends Promise {\n    constructor(client, responsePromise, parseResponse = defaultParseResponse){\n        super((resolve)=>{\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n        this.client = client;\n    }\n    _thenUnwrap(transform) {\n        return new APIPromise(this.client, this.responsePromise, async (client, props)=>transform(await this.parseResponse(client, props), props));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` or add `\"lib\": [\"DOM\"]`\n     * to your `tsconfig.json`.\n     */ asResponse() {\n        return this.responsePromise.then((p)=>p.response);\n    }\n    /**\n     * Gets the parsed response data and the raw `Response` instance.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     *  Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` or add `\"lib\": [\"DOM\"]`\n     * to your `tsconfig.json`.\n     */ async withResponse() {\n        const [data, response] = await Promise.all([\n            this.parse(),\n            this.asResponse()\n        ]);\n        return {\n            data,\n            response\n        };\n    }\n    parse() {\n        if (!this.parsedPromise) {\n            this.parsedPromise = this.responsePromise.then((data)=>this.parseResponse(this.client, data));\n        }\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nconst brand_privateNullableHeaders = /* @__PURE__ */ Symbol(\"brand.privateNullableHeaders\");\nfunction* iterateHeaders(headers) {\n    if (!headers) return;\n    if (brand_privateNullableHeaders in headers) {\n        const { values, nulls } = headers;\n        yield* values.entries();\n        for (const name of nulls){\n            yield [\n                name,\n                null\n            ];\n        }\n        return;\n    }\n    let shouldClear = false;\n    let iter;\n    if (headers instanceof Headers) {\n        iter = headers.entries();\n    } else if (isReadonlyArray(headers)) {\n        iter = headers;\n    } else {\n        shouldClear = true;\n        iter = Object.entries(headers !== null && headers !== void 0 ? headers : {});\n    }\n    for (let row of iter){\n        const name = row[0];\n        if (typeof name !== \"string\") throw new TypeError(\"expected header name to be a string\");\n        const values = isReadonlyArray(row[1]) ? row[1] : [\n            row[1]\n        ];\n        let didClear = false;\n        for (const value of values){\n            if (value === undefined) continue;\n            // Objects keys always overwrite older headers, they never append.\n            // Yield a null to clear the header before adding the new values.\n            if (shouldClear && !didClear) {\n                didClear = true;\n                yield [\n                    name,\n                    null\n                ];\n            }\n            yield [\n                name,\n                value\n            ];\n        }\n    }\n}\nconst buildHeaders = (newHeaders)=>{\n    const targetHeaders = new Headers();\n    const nullHeaders = new Set();\n    for (const headers of newHeaders){\n        const seenHeaders = new Set();\n        for (const [name, value] of iterateHeaders(headers)){\n            const lowerName = name.toLowerCase();\n            if (!seenHeaders.has(lowerName)) {\n                targetHeaders.delete(name);\n                seenHeaders.add(lowerName);\n            }\n            if (value === null) {\n                targetHeaders.delete(name);\n                nullHeaders.add(lowerName);\n            } else {\n                targetHeaders.append(name, value);\n                nullHeaders.delete(lowerName);\n            }\n        }\n    }\n    return {\n        [brand_privateNullableHeaders]: true,\n        values: targetHeaders,\n        nulls: nullHeaders\n    };\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */ const readEnv = (env)=>{\n    var _a, _b, _c, _d, _e, _f;\n    if (typeof globalThis.process !== \"undefined\") {\n        return (_c = (_b = (_a = globalThis.process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n    }\n    if (typeof globalThis.Deno !== \"undefined\") {\n        return (_f = (_e = (_d = globalThis.Deno.env) === null || _d === void 0 ? void 0 : _d.get) === null || _e === void 0 ? void 0 : _e.call(_d, env)) === null || _f === void 0 ? void 0 : _f.trim();\n    }\n    return undefined;\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ var _a;\n/**\n * Base class for Gemini Next Gen API API clients.\n */ class BaseGeminiNextGenAPIClient {\n    /**\n     * API Client for interfacing with the Gemini Next Gen API API.\n     *\n     * @param {string | null | undefined} [opts.apiKey=process.env['GEMINI_API_KEY'] ?? null]\n     * @param {string | undefined} [opts.apiVersion=v1beta]\n     * @param {string} [opts.baseURL=process.env['GEMINI_NEXT_GEN_API_BASE_URL'] ?? https://generativelanguage.googleapis.com] - Override the default base URL for the API.\n     * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.\n     * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.\n     */ constructor(_b){\n        var _c, _d, _e, _f, _g, _h, _j;\n        var { baseURL = readEnv(\"GEMINI_NEXT_GEN_API_BASE_URL\"), apiKey = (_c = readEnv(\"GEMINI_API_KEY\")) !== null && _c !== void 0 ? _c : null, apiVersion = \"v1beta\" } = _b, opts = __rest(_b, [\n            \"baseURL\",\n            \"apiKey\",\n            \"apiVersion\"\n        ]);\n        const options = Object.assign(Object.assign({\n            apiKey,\n            apiVersion\n        }, opts), {\n            baseURL: baseURL || `https://generativelanguage.googleapis.com`\n        });\n        this.baseURL = options.baseURL;\n        this.timeout = (_d = options.timeout) !== null && _d !== void 0 ? _d : BaseGeminiNextGenAPIClient.DEFAULT_TIMEOUT /* 1 minute */ ;\n        this.logger = (_e = options.logger) !== null && _e !== void 0 ? _e : console;\n        const defaultLogLevel = \"warn\";\n        // Set default logLevel early so that we can log a warning in parseLogLevel.\n        this.logLevel = defaultLogLevel;\n        this.logLevel = (_g = (_f = parseLogLevel(options.logLevel, \"ClientOptions.logLevel\", this)) !== null && _f !== void 0 ? _f : parseLogLevel(readEnv(\"GEMINI_NEXT_GEN_API_LOG\"), \"process.env['GEMINI_NEXT_GEN_API_LOG']\", this)) !== null && _g !== void 0 ? _g : defaultLogLevel;\n        this.fetchOptions = options.fetchOptions;\n        this.maxRetries = (_h = options.maxRetries) !== null && _h !== void 0 ? _h : 2;\n        this.fetch = (_j = options.fetch) !== null && _j !== void 0 ? _j : getDefaultFetch();\n        this.encoder = FallbackEncoder;\n        this._options = options;\n        this.apiKey = apiKey;\n        this.apiVersion = apiVersion;\n        this.clientAdapter = options.clientAdapter;\n    }\n    /**\n     * Create a new client instance re-using the same options given to the current client with optional overriding.\n     */ withOptions(options) {\n        const client = new this.constructor(Object.assign(Object.assign(Object.assign({}, this._options), {\n            baseURL: this.baseURL,\n            maxRetries: this.maxRetries,\n            timeout: this.timeout,\n            logger: this.logger,\n            logLevel: this.logLevel,\n            fetch: this.fetch,\n            fetchOptions: this.fetchOptions,\n            apiKey: this.apiKey,\n            apiVersion: this.apiVersion\n        }), options));\n        return client;\n    }\n    /**\n     * Check whether the base URL is set to its default.\n     */ baseURLOverridden() {\n        return this.baseURL !== \"https://generativelanguage.googleapis.com\";\n    }\n    defaultQuery() {\n        return this._options.defaultQuery;\n    }\n    validateHeaders({ values, nulls }) {\n        // The headers object handles case insensitivity.\n        if (values.has(\"authorization\") || values.has(\"x-goog-api-key\")) {\n            return;\n        }\n        if (this.apiKey && values.get(\"x-goog-api-key\")) {\n            return;\n        }\n        if (nulls.has(\"x-goog-api-key\")) {\n            return;\n        }\n        throw new Error('Could not resolve authentication method. Expected the apiKey to be set. Or for the \"x-goog-api-key\" headers to be explicitly omitted');\n    }\n    async authHeaders(opts) {\n        const existingHeaders = buildHeaders([\n            opts.headers\n        ]);\n        if (existingHeaders.values.has(\"authorization\") || existingHeaders.values.has(\"x-goog-api-key\")) {\n            return undefined;\n        }\n        if (this.apiKey) {\n            return buildHeaders([\n                {\n                    \"x-goog-api-key\": this.apiKey\n                }\n            ]);\n        }\n        if (this.clientAdapter.isVertexAI()) {\n            return buildHeaders([\n                await this.clientAdapter.getAuthHeaders()\n            ]);\n        }\n        return undefined;\n    }\n    /**\n     * Basic re-implementation of `qs.stringify` for primitive types.\n     */ stringifyQuery(query) {\n        return Object.entries(query).filter(([_, value])=>typeof value !== \"undefined\").map(([key, value])=>{\n            if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            }\n            if (value === null) {\n                return `${encodeURIComponent(key)}=`;\n            }\n            throw new GeminiNextGenAPIClientError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        }).join(\"&\");\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${VERSION}`;\n    }\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${uuid4()}`;\n    }\n    makeStatusError(status, error, message, headers) {\n        return APIError.generate(status, error, message, headers);\n    }\n    buildURL(path, query, defaultBaseURL) {\n        const baseURL = !this.baseURLOverridden() && defaultBaseURL || this.baseURL;\n        const url = isAbsoluteURL(path) ? new URL(path) : new URL(baseURL + (baseURL.endsWith(\"/\") && path.startsWith(\"/\") ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!isEmptyObj(defaultQuery)) {\n            query = Object.assign(Object.assign({}, defaultQuery), query);\n        }\n        if (typeof query === \"object\" && query && !Array.isArray(query)) {\n            url.search = this.stringifyQuery(query);\n        }\n        return url.toString();\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n  \n     */ async prepareOptions(options) {\n        if (this.clientAdapter && this.clientAdapter.isVertexAI() && !options.path.startsWith(`/${this.apiVersion}/projects/`)) {\n            const oldPath = options.path.slice(this.apiVersion.length + 1);\n            options.path = `/${this.apiVersion}/projects/${this.clientAdapter.getProject()}/locations/${this.clientAdapter.getLocation()}${oldPath}`;\n        }\n    }\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */ async prepareRequest(request, { url, options }) {}\n    get(path, opts) {\n        return this.methodRequest(\"get\", path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest(\"post\", path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest(\"patch\", path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest(\"put\", path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest(\"delete\", path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then((opts)=>{\n            return Object.assign({\n                method,\n                path\n            }, opts);\n        }));\n    }\n    request(options, remainingRetries = null) {\n        return new APIPromise(this, this.makeRequest(options, remainingRetries, undefined));\n    }\n    async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {\n        var _b, _c, _d;\n        const options = await optionsInput;\n        const maxRetries = (_b = options.maxRetries) !== null && _b !== void 0 ? _b : this.maxRetries;\n        if (retriesRemaining == null) {\n            retriesRemaining = maxRetries;\n        }\n        await this.prepareOptions(options);\n        const { req, url, timeout } = await this.buildRequest(options, {\n            retryCount: maxRetries - retriesRemaining\n        });\n        await this.prepareRequest(req, {\n            url,\n            options\n        });\n        /** Not an API request ID, just for correlating local log entries. */ const requestLogID = \"log_\" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, \"0\");\n        const retryLogStr = retryOfRequestLogID === undefined ? \"\" : `, retryOf: ${retryOfRequestLogID}`;\n        const startTime = Date.now();\n        loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({\n            retryOfRequestLogID,\n            method: options.method,\n            url,\n            options,\n            headers: req.headers\n        }));\n        if ((_c = options.signal) === null || _c === void 0 ? void 0 : _c.aborted) {\n            throw new APIUserAbortError();\n        }\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n        const headersTime = Date.now();\n        if (response instanceof globalThis.Error) {\n            const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n            if ((_d = options.signal) === null || _d === void 0 ? void 0 : _d.aborted) {\n                throw new APIUserAbortError();\n            }\n            // detect native connection timeout errors\n            // deno throws \"TypeError: error sending request for url (https://example/): client error (Connect): tcp connect error: Operation timed out (os error 60): Operation timed out (os error 60)\"\n            // undici throws \"TypeError: fetch failed\" with cause \"ConnectTimeoutError: Connect Timeout Error (attempted address: example:443, timeout: 1ms)\"\n            // others do not provide enough information to distinguish timeouts from other connection errors\n            const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + (\"cause\" in response ? String(response.cause) : \"\"));\n            if (retriesRemaining) {\n                loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? \"timed out\" : \"failed\"} - ${retryMessage}`);\n                loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? \"timed out\" : \"failed\"} (${retryMessage})`, formatRequestDetails({\n                    retryOfRequestLogID,\n                    url,\n                    durationMs: headersTime - startTime,\n                    message: response.message\n                }));\n                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID !== null && retryOfRequestLogID !== void 0 ? retryOfRequestLogID : requestLogID);\n            }\n            loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? \"timed out\" : \"failed\"} - error; no more retries left`);\n            loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? \"timed out\" : \"failed\"} (error; no more retries left)`, formatRequestDetails({\n                retryOfRequestLogID,\n                url,\n                durationMs: headersTime - startTime,\n                message: response.message\n            }));\n            if (isTimeout) {\n                throw new APIConnectionTimeoutError();\n            }\n            throw new APIConnectionError({\n                cause: response\n            });\n        }\n        const responseInfo = `[${requestLogID}${retryLogStr}] ${req.method} ${url} ${response.ok ? \"succeeded\" : \"failed\"} with status ${response.status} in ${headersTime - startTime}ms`;\n        if (!response.ok) {\n            const shouldRetry = await this.shouldRetry(response);\n            if (retriesRemaining && shouldRetry) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                // We don't need the body of this response.\n                await CancelReadableStream(response.body);\n                loggerFor(this).info(`${responseInfo} - ${retryMessage}`);\n                loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({\n                    retryOfRequestLogID,\n                    url: response.url,\n                    status: response.status,\n                    headers: response.headers,\n                    durationMs: headersTime - startTime\n                }));\n                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID !== null && retryOfRequestLogID !== void 0 ? retryOfRequestLogID : requestLogID, response.headers);\n            }\n            const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;\n            loggerFor(this).info(`${responseInfo} - ${retryMessage}`);\n            const errText = await response.text().catch((err)=>castToError(err).message);\n            const errJSON = safeJSON(errText);\n            const errMessage = errJSON ? undefined : errText;\n            loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({\n                retryOfRequestLogID,\n                url: response.url,\n                status: response.status,\n                headers: response.headers,\n                message: errMessage,\n                durationMs: Date.now() - startTime\n            }));\n            // @ts-ignore\n            const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);\n            throw err;\n        }\n        loggerFor(this).info(responseInfo);\n        loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({\n            retryOfRequestLogID,\n            url: response.url,\n            status: response.status,\n            headers: response.headers,\n            durationMs: headersTime - startTime\n        }));\n        return {\n            response,\n            options,\n            controller,\n            requestLogID,\n            retryOfRequestLogID,\n            startTime\n        };\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const _b = init || {}, { signal, method } = _b, options = __rest(_b, [\n            \"signal\",\n            \"method\"\n        ]);\n        if (signal) signal.addEventListener(\"abort\", ()=>controller.abort());\n        const timeout = setTimeout(()=>controller.abort(), ms);\n        const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === \"object\" && options.body !== null && Symbol.asyncIterator in options.body;\n        const fetchOptions = Object.assign(Object.assign(Object.assign({\n            signal: controller.signal\n        }, isReadableBody ? {\n            duplex: \"half\"\n        } : {}), {\n            method: \"GET\"\n        }), options);\n        if (method) {\n            // Custom methods like 'patch' need to be uppercased\n            // See https://github.com/nodejs/undici/issues/2294\n            fetchOptions.method = method.toUpperCase();\n        }\n        try {\n            // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n            return await this.fetch.call(undefined, url, fetchOptions);\n        } finally{\n            clearTimeout(timeout);\n        }\n    }\n    async shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get(\"x-should-retry\");\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === \"true\") return true;\n        if (shouldRetryHeader === \"false\") return false;\n        // Retry on request timeouts.\n        if (response.status === 408) return true;\n        // Retry on lock timeouts.\n        if (response.status === 409) return true;\n        // Retry on rate limits.\n        if (response.status === 429) return true;\n        // Retry internal errors.\n        if (response.status >= 500) return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {\n        var _b;\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders.get(\"retry-after-ms\");\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) {\n                timeoutMillis = timeoutMs;\n            }\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders.get(\"retry-after\");\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) {\n                timeoutMillis = timeoutSeconds * 1000;\n            } else {\n                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n            }\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n            const maxRetries = (_b = options.maxRetries) !== null && _b !== void 0 ? _b : this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await sleep$1(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1, requestLogID);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    async buildRequest(inputOptions, { retryCount = 0 } = {}) {\n        var _b, _c, _d;\n        const options = Object.assign({}, inputOptions);\n        const { method, path, query, defaultBaseURL } = options;\n        const url = this.buildURL(path, query, defaultBaseURL);\n        if (\"timeout\" in options) validatePositiveInteger(\"timeout\", options.timeout);\n        options.timeout = (_b = options.timeout) !== null && _b !== void 0 ? _b : this.timeout;\n        const { bodyHeaders, body } = this.buildBody({\n            options\n        });\n        const reqHeaders = await this.buildHeaders({\n            options: inputOptions,\n            method,\n            bodyHeaders,\n            retryCount\n        });\n        const req = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n            method,\n            headers: reqHeaders\n        }, options.signal && {\n            signal: options.signal\n        }), globalThis.ReadableStream && body instanceof globalThis.ReadableStream && {\n            duplex: \"half\"\n        }), body && {\n            body\n        }), (_c = this.fetchOptions) !== null && _c !== void 0 ? _c : {}), (_d = options.fetchOptions) !== null && _d !== void 0 ? _d : {});\n        return {\n            req,\n            url,\n            timeout: options.timeout\n        };\n    }\n    async buildHeaders({ options, method, bodyHeaders, retryCount }) {\n        let idempotencyHeaders = {};\n        if (this.idempotencyHeader && method !== \"get\") {\n            if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\n            idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;\n        }\n        const authHeaders = await this.authHeaders(options);\n        let headers = buildHeaders([\n            idempotencyHeaders,\n            Object.assign(Object.assign({\n                Accept: \"application/json\",\n                \"User-Agent\": this.getUserAgent(),\n                \"X-Stainless-Retry-Count\": String(retryCount)\n            }, options.timeout ? {\n                \"X-Stainless-Timeout\": String(Math.trunc(options.timeout / 1000))\n            } : {}), getPlatformHeaders()),\n            this._options.defaultHeaders,\n            bodyHeaders,\n            options.headers,\n            authHeaders\n        ]);\n        this.validateHeaders(headers);\n        return headers.values;\n    }\n    buildBody({ options: { body, headers: rawHeaders } }) {\n        if (!body) {\n            return {\n                bodyHeaders: undefined,\n                body: undefined\n            };\n        }\n        const headers = buildHeaders([\n            rawHeaders\n        ]);\n        if (// Pass raw type verbatim\n        ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === \"string\" && // Preserve legacy string encoding behavior for now\n        headers.values.has(\"content-type\") || // `Blob` is superset of `File`\n        globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`\n        body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`\n        body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)\n        globalThis.ReadableStream && body instanceof globalThis.ReadableStream) {\n            return {\n                bodyHeaders: undefined,\n                body: body\n            };\n        } else if (typeof body === \"object\" && (Symbol.asyncIterator in body || Symbol.iterator in body && \"next\" in body && typeof body.next === \"function\")) {\n            return {\n                bodyHeaders: undefined,\n                body: ReadableStreamFrom(body)\n            };\n        } else {\n            return this.encoder({\n                body,\n                headers\n            });\n        }\n    }\n}\nBaseGeminiNextGenAPIClient.DEFAULT_TIMEOUT = 60000; // 1 minute\n/**\n * API Client for interfacing with the Gemini Next Gen API API.\n */ class GeminiNextGenAPIClient extends BaseGeminiNextGenAPIClient {\n    constructor(){\n        super(...arguments);\n        this.interactions = new Interactions(this);\n    }\n}\n_a = GeminiNextGenAPIClient;\nGeminiNextGenAPIClient.GeminiNextGenAPIClient = _a;\nGeminiNextGenAPIClient.GeminiNextGenAPIClientError = GeminiNextGenAPIClientError;\nGeminiNextGenAPIClient.APIError = APIError;\nGeminiNextGenAPIClient.APIConnectionError = APIConnectionError;\nGeminiNextGenAPIClient.APIConnectionTimeoutError = APIConnectionTimeoutError;\nGeminiNextGenAPIClient.APIUserAbortError = APIUserAbortError;\nGeminiNextGenAPIClient.NotFoundError = NotFoundError;\nGeminiNextGenAPIClient.ConflictError = ConflictError;\nGeminiNextGenAPIClient.RateLimitError = RateLimitError;\nGeminiNextGenAPIClient.BadRequestError = BadRequestError;\nGeminiNextGenAPIClient.AuthenticationError = AuthenticationError;\nGeminiNextGenAPIClient.InternalServerError = InternalServerError;\nGeminiNextGenAPIClient.PermissionDeniedError = PermissionDeniedError;\nGeminiNextGenAPIClient.UnprocessableEntityError = UnprocessableEntityError;\nGeminiNextGenAPIClient.toFile = toFile;\nGeminiNextGenAPIClient.Interactions = Interactions;\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const GOOGLE_API_KEY_HEADER = \"x-goog-api-key\";\nconst REQUIRED_VERTEX_AI_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\nclass NodeAuth {\n    constructor(opts){\n        if (opts.apiKey !== undefined) {\n            this.apiKey = opts.apiKey;\n            return;\n        }\n        const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);\n        this.googleAuth = new google_auth_library__WEBPACK_IMPORTED_MODULE_0__.GoogleAuth(vertexAuthOptions);\n    }\n    async addAuthHeaders(headers, url) {\n        if (this.apiKey !== undefined) {\n            if (this.apiKey.startsWith(\"auth_tokens/\")) {\n                throw new Error(\"Ephemeral tokens are only supported by the live API.\");\n            }\n            this.addKeyHeader(headers);\n            return;\n        }\n        return this.addGoogleAuthHeaders(headers, url);\n    }\n    addKeyHeader(headers) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey === undefined) {\n            // This should never happen, this method is only called\n            // when apiKey is set.\n            throw new Error(\"Trying to set API key header but apiKey is not set\");\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n    async addGoogleAuthHeaders(headers, url) {\n        if (this.googleAuth === undefined) {\n            // This should never happen, addGoogleAuthHeaders should only be\n            // called when there is no apiKey set and in these cases googleAuth\n            // is set.\n            throw new Error(\"Trying to set google-auth headers but googleAuth is unset\");\n        }\n        const authHeaders = await this.googleAuth.getRequestHeaders(url);\n        for (const [key, value] of authHeaders){\n            if (headers.get(key) !== null) {\n                continue;\n            }\n            headers.append(key, value);\n        }\n    }\n}\nfunction buildGoogleAuthOptions(googleAuthOptions) {\n    let authOptions;\n    if (!googleAuthOptions) {\n        authOptions = {\n            scopes: [\n                REQUIRED_VERTEX_AI_SCOPE\n            ]\n        };\n        return authOptions;\n    } else {\n        authOptions = googleAuthOptions;\n        if (!authOptions.scopes) {\n            authOptions.scopes = [\n                REQUIRED_VERTEX_AI_SCOPE\n            ];\n            return authOptions;\n        } else if (typeof authOptions.scopes === \"string\" && authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE || Array.isArray(authOptions.scopes) && authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0) {\n            throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);\n        }\n        return authOptions;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeDownloader {\n    async download(params, apiClient) {\n        if (params.downloadPath) {\n            const response = await downloadFile(params, apiClient);\n            if (response instanceof HttpResponse) {\n                const writer = (0,fs__WEBPACK_IMPORTED_MODULE_1__.createWriteStream)(params.downloadPath);\n                const body = node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable.fromWeb(response.responseInternal.body);\n                body.pipe(writer);\n                await (0,node_stream_promises__WEBPACK_IMPORTED_MODULE_4__.finished)(writer);\n            } else {\n                try {\n                    await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile)(params.downloadPath, response, {\n                        encoding: \"base64\"\n                    });\n                } catch (error) {\n                    throw new Error(`Failed to write file to ${params.downloadPath}: ${error}`);\n                }\n            }\n        }\n    }\n}\nasync function downloadFile(params, apiClient) {\n    var _a, _b, _c;\n    const name = tFileName(params.file);\n    if (name !== undefined) {\n        return await apiClient.request({\n            path: `files/${name}:download`,\n            httpMethod: \"GET\",\n            queryParams: {\n                \"alt\": \"media\"\n            },\n            httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n        });\n    } else if (isGeneratedVideo(params.file)) {\n        const videoBytes = (_c = params.file.video) === null || _c === void 0 ? void 0 : _c.videoBytes;\n        if (typeof videoBytes === \"string\") {\n            return videoBytes;\n        } else {\n            throw new Error(\"Failed to download generated video, Uri or videoBytes not found.\");\n        }\n    } else if (isVideo(params.file)) {\n        const videoBytes = params.file.videoBytes;\n        if (typeof videoBytes === \"string\") {\n            return videoBytes;\n        } else {\n            throw new Error(\"Failed to download video, Uri or videoBytes not found.\");\n        }\n    } else {\n        throw new Error(\"Unsupported file type\");\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new NodeWebSocket(url, headers, callbacks);\n    }\n}\nclass NodeWebSocket {\n    constructor(url, headers, callbacks){\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n    connect() {\n        this.ws = new ws__WEBPACK_IMPORTED_MODULE_5__.WebSocket(this.url, {\n            headers: this.headers\n        });\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.close();\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction cancelTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobResponseFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction cancelTuningJobResponseFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"validationDataset\"\n    ]) !== undefined) {\n        throw new Error(\"validationDataset parameter is not supported in Gemini API.\");\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromTunedModelDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"description\"\n    ]) !== undefined) {\n        throw new Error(\"description parameter is not supported in Gemini API.\");\n    }\n    const fromEpochCount = getValueByPath(fromObject, [\n        \"epochCount\"\n    ]);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"epochCount\"\n        ], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        \"learningRateMultiplier\"\n    ]);\n    if (fromLearningRateMultiplier != null) {\n        setValueByPath(toObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRateMultiplier\"\n        ], fromLearningRateMultiplier);\n    }\n    if (getValueByPath(fromObject, [\n        \"exportLastCheckpointOnly\"\n    ]) !== undefined) {\n        throw new Error(\"exportLastCheckpointOnly parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"preTunedModelCheckpointId\"\n    ]) !== undefined) {\n        throw new Error(\"preTunedModelCheckpointId parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"adapterSize\"\n    ]) !== undefined) {\n        throw new Error(\"adapterSize parameter is not supported in Gemini API.\");\n    }\n    const fromBatchSize = getValueByPath(fromObject, [\n        \"batchSize\"\n    ]);\n    if (parentObject !== undefined && fromBatchSize != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"batchSize\"\n        ], fromBatchSize);\n    }\n    const fromLearningRate = getValueByPath(fromObject, [\n        \"learningRate\"\n    ]);\n    if (parentObject !== undefined && fromLearningRate != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRate\"\n        ], fromLearningRate);\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"beta\"\n    ]) !== undefined) {\n        throw new Error(\"beta parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorValidationDataset = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorValidationDataset === undefined) {\n        discriminatorValidationDataset = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorValidationDataset === \"SUPERVISED_FINE_TUNING\") {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            \"validationDataset\"\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\"\n            ], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    } else if (discriminatorValidationDataset === \"PREFERENCE_TUNING\") {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            \"validationDataset\"\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\"\n            ], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    let discriminatorEpochCount = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorEpochCount === undefined) {\n        discriminatorEpochCount = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorEpochCount === \"SUPERVISED_FINE_TUNING\") {\n        const fromEpochCount = getValueByPath(fromObject, [\n            \"epochCount\"\n        ]);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"hyperParameters\",\n                \"epochCount\"\n            ], fromEpochCount);\n        }\n    } else if (discriminatorEpochCount === \"PREFERENCE_TUNING\") {\n        const fromEpochCount = getValueByPath(fromObject, [\n            \"epochCount\"\n        ]);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"hyperParameters\",\n                \"epochCount\"\n            ], fromEpochCount);\n        }\n    }\n    let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorLearningRateMultiplier === undefined) {\n        discriminatorLearningRateMultiplier = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorLearningRateMultiplier === \"SUPERVISED_FINE_TUNING\") {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            \"learningRateMultiplier\"\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"hyperParameters\",\n                \"learningRateMultiplier\"\n            ], fromLearningRateMultiplier);\n        }\n    } else if (discriminatorLearningRateMultiplier === \"PREFERENCE_TUNING\") {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            \"learningRateMultiplier\"\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"hyperParameters\",\n                \"learningRateMultiplier\"\n            ], fromLearningRateMultiplier);\n        }\n    }\n    let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorExportLastCheckpointOnly === undefined) {\n        discriminatorExportLastCheckpointOnly = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorExportLastCheckpointOnly === \"SUPERVISED_FINE_TUNING\") {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            \"exportLastCheckpointOnly\"\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"exportLastCheckpointOnly\"\n            ], fromExportLastCheckpointOnly);\n        }\n    } else if (discriminatorExportLastCheckpointOnly === \"PREFERENCE_TUNING\") {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            \"exportLastCheckpointOnly\"\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"exportLastCheckpointOnly\"\n            ], fromExportLastCheckpointOnly);\n        }\n    }\n    let discriminatorAdapterSize = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorAdapterSize === undefined) {\n        discriminatorAdapterSize = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorAdapterSize === \"SUPERVISED_FINE_TUNING\") {\n        const fromAdapterSize = getValueByPath(fromObject, [\n            \"adapterSize\"\n        ]);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"hyperParameters\",\n                \"adapterSize\"\n            ], fromAdapterSize);\n        }\n    } else if (discriminatorAdapterSize === \"PREFERENCE_TUNING\") {\n        const fromAdapterSize = getValueByPath(fromObject, [\n            \"adapterSize\"\n        ]);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"hyperParameters\",\n                \"adapterSize\"\n            ], fromAdapterSize);\n        }\n    }\n    if (getValueByPath(fromObject, [\n        \"batchSize\"\n    ]) !== undefined) {\n        throw new Error(\"batchSize parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"learningRate\"\n    ]) !== undefined) {\n        throw new Error(\"learningRate parameter is not supported in Vertex AI.\");\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromBeta = getValueByPath(fromObject, [\n        \"beta\"\n    ]);\n    if (parentObject !== undefined && fromBeta != null) {\n        setValueByPath(parentObject, [\n            \"preferenceOptimizationSpec\",\n            \"hyperParameters\",\n            \"beta\"\n        ], fromBeta);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToMldev(fromTrainingDataset);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createTuningJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        createTuningJobConfigToVertex(fromConfig, toObject, rootObject);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listTuningJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        listTuningJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tunedModels\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tuningJobs\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tunedModelFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tuningDatasetToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]) !== undefined) {\n        throw new Error(\"vertexDatasetResource parameter is not supported in Gemini API.\");\n    }\n    const fromExamples = getValueByPath(fromObject, [\n        \"examples\"\n    ]);\n    if (fromExamples != null) {\n        let transformedList = fromExamples;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return item;\n            });\n        }\n        setValueByPath(toObject, [\n            \"examples\",\n            \"examples\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tuningDatasetToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorGcsUri = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorGcsUri === undefined) {\n        discriminatorGcsUri = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorGcsUri === \"SUPERVISED_FINE_TUNING\") {\n        const fromGcsUri = getValueByPath(fromObject, [\n            \"gcsUri\"\n        ]);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"trainingDatasetUri\"\n            ], fromGcsUri);\n        }\n    } else if (discriminatorGcsUri === \"PREFERENCE_TUNING\") {\n        const fromGcsUri = getValueByPath(fromObject, [\n            \"gcsUri\"\n        ]);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"trainingDatasetUri\"\n            ], fromGcsUri);\n        }\n    }\n    let discriminatorVertexDatasetResource = getValueByPath(rootObject, [\n        \"config\",\n        \"method\"\n    ]);\n    if (discriminatorVertexDatasetResource === undefined) {\n        discriminatorVertexDatasetResource = \"SUPERVISED_FINE_TUNING\";\n    }\n    if (discriminatorVertexDatasetResource === \"SUPERVISED_FINE_TUNING\") {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            \"vertexDatasetResource\"\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, [\n                \"supervisedTuningSpec\",\n                \"trainingDatasetUri\"\n            ], fromVertexDatasetResource);\n        }\n    } else if (discriminatorVertexDatasetResource === \"PREFERENCE_TUNING\") {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            \"vertexDatasetResource\"\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, [\n                \"preferenceOptimizationSpec\",\n                \"trainingDatasetUri\"\n            ], fromVertexDatasetResource);\n        }\n    }\n    if (getValueByPath(fromObject, [\n        \"examples\"\n    ]) !== undefined) {\n        throw new Error(\"examples parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction tuningJobFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"completeTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], tunedModelFromMldev(fromTunedModel));\n    }\n    return toObject;\n}\nfunction tuningJobFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"tunedModel\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], fromTunedModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromSupervisedTuningSpec = getValueByPath(fromObject, [\n        \"supervisedTuningSpec\"\n    ]);\n    if (fromSupervisedTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"supervisedTuningSpec\"\n        ], fromSupervisedTuningSpec);\n    }\n    const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [\n        \"preferenceOptimizationSpec\"\n    ]);\n    if (fromPreferenceOptimizationSpec != null) {\n        setValueByPath(toObject, [\n            \"preferenceOptimizationSpec\"\n        ], fromPreferenceOptimizationSpec);\n    }\n    const fromTuningDataStats = getValueByPath(fromObject, [\n        \"tuningDataStats\"\n    ]);\n    if (fromTuningDataStats != null) {\n        setValueByPath(toObject, [\n            \"tuningDataStats\"\n        ], fromTuningDataStats);\n    }\n    const fromEncryptionSpec = getValueByPath(fromObject, [\n        \"encryptionSpec\"\n    ]);\n    if (fromEncryptionSpec != null) {\n        setValueByPath(toObject, [\n            \"encryptionSpec\"\n        ], fromEncryptionSpec);\n    }\n    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [\n        \"partnerModelTuningSpec\"\n    ]);\n    if (fromPartnerModelTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"partnerModelTuningSpec\"\n        ], fromPartnerModelTuningSpec);\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        \"customBaseModel\"\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, [\n            \"customBaseModel\"\n        ], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, [\n        \"experiment\"\n    ]);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, [\n            \"experiment\"\n        ], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, [\n        \"outputUri\"\n    ]);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, [\n            \"outputUri\"\n        ], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, [\n        \"pipelineJob\"\n    ]);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, [\n            \"pipelineJob\"\n        ], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        \"serviceAccount\"\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, [\n            \"serviceAccount\"\n        ], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromVeoTuningSpec = getValueByPath(fromObject, [\n        \"veoTuningSpec\"\n    ]);\n    if (fromVeoTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"veoTuningSpec\"\n        ], fromVeoTuningSpec);\n    }\n    return toObject;\n}\nfunction tuningOperationFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction tuningValidationDatasetToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"validationDatasetUri\"\n        ], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]);\n    if (fromVertexDatasetResource != null) {\n        setValueByPath(toObject, [\n            \"validationDatasetUri\"\n        ], fromVertexDatasetResource);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Tunings extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists tuning jobs.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of tuning jobs.\n         *\n         * @example\n         * ```ts\n         * const tuningJobs = await ai.tunings.list({config: {'pageSize': 2}});\n         * for await (const tuningJob of tuningJobs) {\n         *   console.log(tuningJob);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Gets a TuningJob.\n         *\n         * @param name - The resource name of the tuning job.\n         * @return - A TuningJob object.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.get = async (params)=>{\n            return await this.getInternal(params);\n        };\n        /**\n         * Creates a supervised fine-tuning job.\n         *\n         * @param params - The parameters for the tuning job.\n         * @return - A TuningJob operation.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.tune = async (params)=>{\n            var _a;\n            if (this.apiClient.isVertexAI()) {\n                if (params.baseModel.startsWith(\"projects/\")) {\n                    const preTunedModel = {\n                        tunedModelName: params.baseModel\n                    };\n                    if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {\n                        preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;\n                    }\n                    const paramsPrivate = Object.assign(Object.assign({}, params), {\n                        preTunedModel: preTunedModel\n                    });\n                    paramsPrivate.baseModel = undefined;\n                    return await this.tuneInternal(paramsPrivate);\n                } else {\n                    const paramsPrivate = Object.assign({}, params);\n                    return await this.tuneInternal(paramsPrivate);\n                }\n            } else {\n                const paramsPrivate = Object.assign({}, params);\n                const operation = await this.tuneMldevInternal(paramsPrivate);\n                let tunedModelName = \"\";\n                if (operation[\"metadata\"] !== undefined && operation[\"metadata\"][\"tunedModel\"] !== undefined) {\n                    tunedModelName = operation[\"metadata\"][\"tunedModel\"];\n                } else if (operation[\"name\"] !== undefined && operation[\"name\"].includes(\"/operations/\")) {\n                    tunedModelName = operation[\"name\"].split(\"/operations/\")[0];\n                }\n                const tuningJob = {\n                    name: tunedModelName,\n                    state: JobState.JOB_STATE_QUEUED\n                };\n                return tuningJob;\n            }\n        };\n    }\n    async getInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getTuningJobParametersToVertex(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getTuningJobParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listTuningJobsParametersToVertex(params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listTuningJobsParametersToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Cancels a tuning job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async cancel(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelTuningJobParametersToVertex(params);\n            path = formatMap(\"{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = cancelTuningJobResponseFromVertex(apiResponse);\n                const typedResp = new CancelTuningJobResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = cancelTuningJobParametersToMldev(params);\n            path = formatMap(\"{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = cancelTuningJobResponseFromMldev(apiResponse);\n                const typedResp = new CancelTuningJobResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async tuneInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createTuningJobParametersPrivateToVertex(params, params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    async tuneMldevInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createTuningJobParametersPrivateToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningOperationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nconst MAX_RETRY_COUNT = 3;\nconst INITIAL_RETRY_DELAY_MS = 1000;\nconst DELAY_MULTIPLIER = 2;\nconst X_GOOG_UPLOAD_STATUS_HEADER_FIELD = \"x-goog-upload-status\";\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a;\n    const response = await uploadBlobInternal(file, uploadUrl, apiClient);\n    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n        throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n    }\n    return responseJson[\"file\"];\n}\nasync function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {\n    var _a;\n    const response = await uploadBlobInternal(file, uploadUrl, apiClient);\n    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n        throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n    }\n    const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);\n    const typedResp = new UploadToFileSearchStoreOperation();\n    Object.assign(typedResp, resp);\n    return typedResp;\n}\nasync function uploadBlobInternal(file, uploadUrl, apiClient) {\n    var _a, _b;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = \"upload\";\n    fileSize = file.size;\n    while(offset < fileSize){\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += \", finalize\";\n        }\n        let retryCount = 0;\n        let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n        while(retryCount < MAX_RETRY_COUNT){\n            response = await apiClient.request({\n                path: \"\",\n                body: chunk,\n                httpMethod: \"POST\",\n                httpOptions: {\n                    apiVersion: \"\",\n                    baseUrl: uploadUrl,\n                    headers: {\n                        \"X-Goog-Upload-Command\": uploadCommand,\n                        \"X-Goog-Upload-Offset\": String(offset),\n                        \"Content-Length\": String(chunkSize)\n                    }\n                }\n            });\n            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                break;\n            }\n            retryCount++;\n            await sleep(currentDelayMs);\n            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n        }\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n        }\n    }\n    return response;\n}\nasync function getBlobStat(file) {\n    const fileStat = {\n        size: file.size,\n        type: file.type\n    };\n    return fileStat;\n}\nfunction sleep(ms) {\n    return new Promise((resolvePromise)=>setTimeout(resolvePromise, ms));\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeUploader {\n    async stat(file) {\n        const fileStat = {\n            size: 0,\n            type: undefined\n        };\n        if (typeof file === \"string\") {\n            const originalStat = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.stat(file);\n            fileStat.size = originalStat.size;\n            fileStat.type = this.inferMimeType(file);\n            return fileStat;\n        } else {\n            return await getBlobStat(file);\n        }\n    }\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === \"string\") {\n            return await this.uploadFileFromPath(file, uploadUrl, apiClient);\n        } else {\n            return uploadBlob(file, uploadUrl, apiClient);\n        }\n    }\n    async uploadToFileSearchStore(file, uploadUrl, apiClient) {\n        if (typeof file === \"string\") {\n            return await this.uploadFileToFileSearchStoreFromPath(file, uploadUrl, apiClient);\n        } else {\n            return uploadBlobToFileSearchStore(file, uploadUrl, apiClient);\n        }\n    }\n    /**\n     * Infers the MIME type of a file based on its extension.\n     *\n     * @param filePath The path to the file.\n     * @returns The MIME type of the file, or undefined if it cannot be inferred.\n     */ inferMimeType(filePath) {\n        // Get the file extension.\n        const fileExtension = filePath.slice(filePath.lastIndexOf(\".\") + 1);\n        // Create a map of file extensions to MIME types.\n        const mimeTypes = {\n            \"aac\": \"audio/aac\",\n            \"abw\": \"application/x-abiword\",\n            \"arc\": \"application/x-freearc\",\n            \"avi\": \"video/x-msvideo\",\n            \"azw\": \"application/vnd.amazon.ebook\",\n            \"bin\": \"application/octet-stream\",\n            \"bmp\": \"image/bmp\",\n            \"bz\": \"application/x-bzip\",\n            \"bz2\": \"application/x-bzip2\",\n            \"csh\": \"application/x-csh\",\n            \"css\": \"text/css\",\n            \"csv\": \"text/csv\",\n            \"doc\": \"application/msword\",\n            \"docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n            \"eot\": \"application/vnd.ms-fontobject\",\n            \"epub\": \"application/epub+zip\",\n            \"gz\": \"application/gzip\",\n            \"gif\": \"image/gif\",\n            \"htm\": \"text/html\",\n            \"html\": \"text/html\",\n            \"ico\": \"image/vnd.microsoft.icon\",\n            \"ics\": \"text/calendar\",\n            \"jar\": \"application/java-archive\",\n            \"jpeg\": \"image/jpeg\",\n            \"jpg\": \"image/jpeg\",\n            \"js\": \"text/javascript\",\n            \"json\": \"application/json\",\n            \"jsonld\": \"application/ld+json\",\n            \"kml\": \"application/vnd.google-earth.kml+xml\",\n            \"kmz\": \"application/vnd.google-earth.kmz+xml\",\n            \"mjs\": \"text/javascript\",\n            \"mp3\": \"audio/mpeg\",\n            \"mp4\": \"video/mp4\",\n            \"mpeg\": \"video/mpeg\",\n            \"mpkg\": \"application/vnd.apple.installer+xml\",\n            \"odt\": \"application/vnd.oasis.opendocument.text\",\n            \"oga\": \"audio/ogg\",\n            \"ogv\": \"video/ogg\",\n            \"ogx\": \"application/ogg\",\n            \"opus\": \"audio/opus\",\n            \"otf\": \"font/otf\",\n            \"png\": \"image/png\",\n            \"pdf\": \"application/pdf\",\n            \"php\": \"application/x-httpd-php\",\n            \"ppt\": \"application/vnd.ms-powerpoint\",\n            \"pptx\": \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n            \"rar\": \"application/vnd.rar\",\n            \"rtf\": \"application/rtf\",\n            \"sh\": \"application/x-sh\",\n            \"svg\": \"image/svg+xml\",\n            \"swf\": \"application/x-shockwave-flash\",\n            \"tar\": \"application/x-tar\",\n            \"tif\": \"image/tiff\",\n            \"tiff\": \"image/tiff\",\n            \"ts\": \"video/mp2t\",\n            \"ttf\": \"font/ttf\",\n            \"txt\": \"text/plain\",\n            \"vsd\": \"application/vnd.visio\",\n            \"wav\": \"audio/wav\",\n            \"weba\": \"audio/webm\",\n            \"webm\": \"video/webm\",\n            \"webp\": \"image/webp\",\n            \"woff\": \"font/woff\",\n            \"woff2\": \"font/woff2\",\n            \"xhtml\": \"application/xhtml+xml\",\n            \"xls\": \"application/vnd.ms-excel\",\n            \"xlsx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n            \"xml\": \"application/xml\",\n            \"xul\": \"application/vnd.mozilla.xul+xml\",\n            \"zip\": \"application/zip\",\n            \"3gp\": \"video/3gpp\",\n            \"3g2\": \"video/3gpp2\",\n            \"7z\": \"application/x-7z-compressed\"\n        };\n        // Look up the MIME type based on the file extension.\n        const mimeType = mimeTypes[fileExtension.toLowerCase()];\n        // Return the MIME type.\n        return mimeType;\n    }\n    async uploadFileFromPath(file, uploadUrl, apiClient) {\n        var _a;\n        const response = await this.uploadFileFromPathInternal(file, uploadUrl, apiClient);\n        const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n            throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n        }\n        return responseJson[\"file\"];\n    }\n    async uploadFileToFileSearchStoreFromPath(file, uploadUrl, apiClient) {\n        var _a;\n        const response = await this.uploadFileFromPathInternal(file, uploadUrl, apiClient);\n        const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n            throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n        }\n        const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);\n        const typedResp = new UploadToFileSearchStoreOperation();\n        Object.assign(typedResp, resp);\n        return typedResp;\n    }\n    async uploadFileFromPathInternal(file, uploadUrl, apiClient) {\n        var _a, _b;\n        let fileSize = 0;\n        let offset = 0;\n        let response = new HttpResponse(new Response());\n        let uploadCommand = \"upload\";\n        let fileHandle;\n        const fileName = path__WEBPACK_IMPORTED_MODULE_6__.basename(file);\n        try {\n            fileHandle = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.open(file, \"r\");\n            if (!fileHandle) {\n                throw new Error(`Failed to open file`);\n            }\n            fileSize = (await fileHandle.stat()).size;\n            while(offset < fileSize){\n                const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n                if (offset + chunkSize >= fileSize) {\n                    uploadCommand += \", finalize\";\n                }\n                const buffer = new Uint8Array(chunkSize);\n                const { bytesRead: bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);\n                if (bytesRead !== chunkSize) {\n                    throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);\n                }\n                const chunk = new Blob([\n                    buffer\n                ]);\n                let retryCount = 0;\n                let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n                while(retryCount < MAX_RETRY_COUNT){\n                    response = await apiClient.request({\n                        path: \"\",\n                        body: chunk,\n                        httpMethod: \"POST\",\n                        httpOptions: {\n                            apiVersion: \"\",\n                            baseUrl: uploadUrl,\n                            headers: {\n                                \"X-Goog-Upload-Command\": uploadCommand,\n                                \"X-Goog-Upload-Offset\": String(offset),\n                                \"Content-Length\": String(bytesRead),\n                                \"X-Goog-Upload-File-Name\": fileName\n                            }\n                        }\n                    });\n                    if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                        break;\n                    }\n                    retryCount++;\n                    await sleep(currentDelayMs);\n                    currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n                }\n                offset += bytesRead;\n                // The `x-goog-upload-status` header field can be `active`, `final` and\n                //`cancelled` in resposne.\n                if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n                    break;\n                }\n                if (fileSize <= offset) {\n                    throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n                }\n            }\n            return response;\n        } finally{\n            // Ensure the file handle is always closed\n            if (fileHandle) {\n                await fileHandle.close();\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const LANGUAGE_LABEL_PREFIX = \"gl-node/\";\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} must be set, or a {@link\n * GoogleGenAIOptions.apiKey} must be set when using Express Mode.\n *\n * Explicitly passed in values in {@link GoogleGenAIOptions} will always take\n * precedence over environment variables. If both project/location and api_key\n * exist in the environment variables, the project/location will be used.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */ class GoogleGenAI {\n    get interactions() {\n        if (this._interactions !== undefined) {\n            return this._interactions;\n        }\n        console.warn(\"GoogleGenAI.interactions: Interactions usage is experimental and may change in future versions.\");\n        const httpOpts = this.httpOptions;\n        // Unsupported Options Warnings\n        if (httpOpts === null || httpOpts === void 0 ? void 0 : httpOpts.extraBody) {\n            console.warn(\"GoogleGenAI.interactions: Client level httpOptions.extraBody is not supported by the interactions client and will be ignored.\");\n        }\n        const nextGenClient = new GeminiNextGenAPIClient({\n            baseURL: this.apiClient.getBaseUrl(),\n            apiKey: this.apiKey,\n            apiVersion: this.apiClient.getApiVersion(),\n            clientAdapter: this.apiClient,\n            defaultHeaders: this.apiClient.getDefaultHeaders(),\n            timeout: httpOpts === null || httpOpts === void 0 ? void 0 : httpOpts.timeout\n        });\n        this._interactions = nextGenClient.interactions;\n        return this._interactions;\n    }\n    constructor(options){\n        var _a, _b, _c, _d, _e, _f;\n        // Validate explicitly set initializer values.\n        if ((options.project || options.location) && options.apiKey) {\n            throw new Error(\"Project/location and API key are mutually exclusive in the client initializer.\");\n        }\n        this.vertexai = (_b = (_a = options.vertexai) !== null && _a !== void 0 ? _a : getBooleanEnv(\"GOOGLE_GENAI_USE_VERTEXAI\")) !== null && _b !== void 0 ? _b : false;\n        const envApiKey = getApiKeyFromEnv();\n        const envProject = getEnv(\"GOOGLE_CLOUD_PROJECT\");\n        const envLocation = getEnv(\"GOOGLE_CLOUD_LOCATION\");\n        this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;\n        this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;\n        this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;\n        // Handle when to use Vertex AI in express mode (api key)\n        if (options.vertexai) {\n            if ((_f = options.googleAuthOptions) === null || _f === void 0 ? void 0 : _f.credentials) {\n                // Explicit credentials take precedence over implicit api_key.\n                console.debug(\"The user provided Google Cloud credentials will take precedence\" + \" over the API key from the environment variable.\");\n                this.apiKey = undefined;\n            }\n            // Explicit api_key and explicit project/location already handled above.\n            if ((envProject || envLocation) && options.apiKey) {\n                // Explicit api_key takes precedence over implicit project/location.\n                console.debug(\"The user provided Vertex AI API key will take precedence over\" + \" the project/location from the environment variables.\");\n                this.project = undefined;\n                this.location = undefined;\n            } else if ((options.project || options.location) && envApiKey) {\n                // Explicit project/location takes precedence over implicit api_key.\n                console.debug(\"The user provided project/location will take precedence over\" + \" the API key from the environment variables.\");\n                this.apiKey = undefined;\n            } else if ((envProject || envLocation) && envApiKey) {\n                // Implicit project/location takes precedence over implicit api_key.\n                console.debug(\"The project/location from the environment variables will take\" + \" precedence over the API key from the environment variables.\");\n                this.apiKey = undefined;\n            }\n            if (!this.location && !this.apiKey) {\n                this.location = \"global\";\n            }\n        }\n        const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, getEnv(\"GOOGLE_VERTEX_BASE_URL\"), getEnv(\"GOOGLE_GEMINI_BASE_URL\"));\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            } else {\n                options.httpOptions = {\n                    baseUrl: baseUrl\n                };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        this.httpOptions = options.httpOptions;\n        const auth = new NodeAuth({\n            apiKey: this.apiKey,\n            googleAuthOptions: options.googleAuthOptions\n        });\n        this.apiClient = new ApiClient({\n            auth: auth,\n            project: this.project,\n            location: this.location,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: this.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,\n            uploader: new NodeUploader(),\n            downloader: new NodeDownloader()\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory());\n        this.batches = new Batches(this.apiClient);\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n        this.authTokens = new Tokens(this.apiClient);\n        this.tunings = new Tunings(this.apiClient);\n        this.fileSearchStores = new FileSearchStores(this.apiClient);\n    }\n}\nfunction getEnv(env) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n}\nfunction getBooleanEnv(env) {\n    return stringToBoolean(getEnv(env));\n}\nfunction stringToBoolean(str) {\n    if (str === undefined) {\n        return false;\n    }\n    return str.toLowerCase() === \"true\";\n}\nfunction getApiKeyFromEnv() {\n    const envGoogleApiKey = getEnv(\"GOOGLE_API_KEY\");\n    const envGeminiApiKey = getEnv(\"GEMINI_API_KEY\");\n    if (envGoogleApiKey && envGeminiApiKey) {\n        console.warn(\"Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.\");\n    }\n    return envGoogleApiKey || envGeminiApiKey || undefined;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNWO0FBQ0w7QUFDTTtBQUNEO0FBQ1M7QUFDbkI7QUFDRTtBQUUvQjs7OztDQUlDLEdBQ0QsSUFBSVEsd0JBQXdCQztBQUM1QixJQUFJQyx3QkFBd0JEO0FBQzVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0QsU0FBU0UsbUJBQW1CQyxhQUFhO0lBQ3JDSix3QkFBd0JJLGNBQWNDLFNBQVM7SUFDL0NILHdCQUF3QkUsY0FBY0UsU0FBUztBQUNuRDtBQUNBOztDQUVDLEdBQ0QsU0FBU0M7SUFDTCxPQUFPO1FBQ0hGLFdBQVdMO1FBQ1hNLFdBQVdKO0lBQ2Y7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU00sV0FBV0MsV0FBVyxFQUFFQyxRQUFRLEVBQUVDLG9CQUFvQixFQUFFQyxvQkFBb0I7SUFDakYsSUFBSUMsSUFBSUM7SUFDUixJQUFJLENBQUVMLENBQUFBLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWU0sT0FBTyxHQUFHO1FBQ2xGLE1BQU1DLGtCQUFrQlQ7UUFDeEIsSUFBSUcsVUFBVTtZQUNWLE9BQU8sQ0FBQ0csS0FBS0csZ0JBQWdCVixTQUFTLE1BQU0sUUFBUU8sT0FBTyxLQUFLLElBQUlBLEtBQUtGO1FBQzdFLE9BQ0s7WUFDRCxPQUFPLENBQUNHLEtBQUtFLGdCQUFnQlgsU0FBUyxNQUFNLFFBQVFTLE9BQU8sS0FBSyxJQUFJQSxLQUFLRjtRQUM3RTtJQUNKO0lBQ0EsT0FBT0gsWUFBWU0sT0FBTztBQUM5QjtBQUVB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c291cmNlcyI6WyJ3ZWJwYWNrOi8vaW50ZXJ2aWV3YXkvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzPzJkNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR29vZ2xlQXV0aCB9IGZyb20gJ2dvb2dsZS1hdXRoLWxpYnJhcnknO1xuaW1wb3J0IHsgY3JlYXRlV3JpdGVTdHJlYW0gfSBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQgeyB3cml0ZUZpbGUgfSBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ25vZGU6c3RyZWFtJztcbmltcG9ydCB7IGZpbmlzaGVkIH0gZnJvbSAnbm9kZTpzdHJlYW0vcHJvbWlzZXMnO1xuaW1wb3J0ICogYXMgTm9kZVdzIGZyb20gJ3dzJztcbmltcG9ydCAqIGFzIHBhdGgkMSBmcm9tICdwYXRoJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xubGV0IF9kZWZhdWx0QmFzZUdlbWluaVVybCA9IHVuZGVmaW5lZDtcbmxldCBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwgPSB1bmRlZmluZWQ7XG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgYmFzZSBVUkxzIGZvciB0aGUgR2VtaW5pIEFQSSBhbmQgVmVydGV4IEFJIEFQSS5cbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemluZyB0aGUgU0RLLiBJZiB0aGVcbiAqIGJhc2UgVVJMcyBhcmUgc2V0IGFmdGVyIGluaXRpYWxpemluZyB0aGUgU0RLLCB0aGUgYmFzZSBVUkxzIHdpbGwgbm90IGJlXG4gKiB1cGRhdGVkLiBCYXNlIFVSTHMgcHJvdmlkZWQgaW4gdGhlIEh0dHBPcHRpb25zIHdpbGwgYWxzbyB0YWtlIHByZWNlZGVuY2Ugb3ZlclxuICogVVJMcyBzZXQgaGVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7R29vZ2xlR2VuQUksIHNldERlZmF1bHRCYXNlVXJsc30gZnJvbSAnQGdvb2dsZS9nZW5haSc7XG4gKiAvLyBPdmVycmlkZSB0aGUgYmFzZSBVUkwgZm9yIHRoZSBHZW1pbmkgQVBJLlxuICogc2V0RGVmYXVsdEJhc2VVcmxzKHtnZW1pbmlVcmw6J2h0dHBzOi8vZ2VtaW5pLmdvb2dsZS5jb20nfSk7XG4gKlxuICogLy8gT3ZlcnJpZGUgdGhlIGJhc2UgVVJMIGZvciB0aGUgVmVydGV4IEFJIEFQSS5cbiAqIHNldERlZmF1bHRCYXNlVXJscyh7dmVydGV4VXJsOiAnaHR0cHM6Ly92ZXJ0ZXhhaS5nb29nbGVhcGlzLmNvbSd9KTtcbiAqXG4gKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7YXBpS2V5OiAnR0VNSU5JX0FQSV9LRVknfSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gc2V0RGVmYXVsdEJhc2VVcmxzKGJhc2VVcmxQYXJhbXMpIHtcbiAgICBfZGVmYXVsdEJhc2VHZW1pbmlVcmwgPSBiYXNlVXJsUGFyYW1zLmdlbWluaVVybDtcbiAgICBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwgPSBiYXNlVXJsUGFyYW1zLnZlcnRleFVybDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBiYXNlIFVSTHMgZm9yIHRoZSBHZW1pbmkgQVBJIGFuZCBWZXJ0ZXggQUkgQVBJLlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0QmFzZVVybHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2VtaW5pVXJsOiBfZGVmYXVsdEJhc2VHZW1pbmlVcmwsXG4gICAgICAgIHZlcnRleFVybDogX2RlZmF1bHRCYXNlVmVydGV4VXJsLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgYmFzZSBVUkwgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBwcmlvcml0eTpcbiAqICAgMS4gQmFzZSBVUkxzIHNldCB2aWEgSHR0cE9wdGlvbnMuXG4gKiAgIDIuIEJhc2UgVVJMcyBzZXQgdmlhIHRoZSBsYXRlc3QgY2FsbCB0byBzZXREZWZhdWx0QmFzZVVybHMuXG4gKiAgIDMuIEJhc2UgVVJMcyBzZXQgdmlhIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0QmFzZVVybChodHRwT3B0aW9ucywgdmVydGV4YWksIHZlcnRleEJhc2VVcmxGcm9tRW52LCBnZW1pbmlCYXNlVXJsRnJvbUVudikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCEoaHR0cE9wdGlvbnMgPT09IG51bGwgfHwgaHR0cE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0dHBPcHRpb25zLmJhc2VVcmwpKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRCYXNlVXJscyA9IGdldERlZmF1bHRCYXNlVXJscygpO1xuICAgICAgICBpZiAodmVydGV4YWkpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBkZWZhdWx0QmFzZVVybHMudmVydGV4VXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2ZXJ0ZXhCYXNlVXJsRnJvbUVudjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSBkZWZhdWx0QmFzZVVybHMuZ2VtaW5pVXJsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBnZW1pbmlCYXNlVXJsRnJvbUVudjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHR0cE9wdGlvbnMuYmFzZVVybDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQmFzZU1vZHVsZSB7XG59XG5mdW5jdGlvbiBmb3JtYXRNYXAodGVtcGxhdGVTdHJpbmcsIHZhbHVlTWFwKSB7XG4gICAgLy8gVXNlIGEgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbmQgYWxsIHBsYWNlaG9sZGVycyBpbiB0aGUgdGVtcGxhdGUgc3RyaW5nXG4gICAgY29uc3QgcmVnZXggPSAvXFx7KFtefV0rKVxcfS9nO1xuICAgIC8vIFJlcGxhY2UgZWFjaCBwbGFjZWhvbGRlciB3aXRoIGl0cyBjb3JyZXNwb25kaW5nIHZhbHVlIGZyb20gdGhlIHZhbHVlTWFwXG4gICAgcmV0dXJuIHRlbXBsYXRlU3RyaW5nLnJlcGxhY2UocmVnZXgsIChtYXRjaCwga2V5KSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVNYXAsIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVNYXBba2V5XTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGEgc3RyaW5nIGlmIGl0J3Mgbm90IGEgc3RyaW5nIGFscmVhZHlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsID8gU3RyaW5nKHZhbHVlKSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSGFuZGxlIG1pc3Npbmcga2V5c1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJyR7a2V5fScgbm90IGZvdW5kIGluIHZhbHVlTWFwLmApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUJ5UGF0aChkYXRhLCBrZXlzLCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICBpZiAoIShrZXlOYW1lIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFba2V5TmFtZV0gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB2YWx1ZS5sZW5ndGggfSwgKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIG11c3QgYmUgYSBsaXN0IGdpdmVuIGFuIGFycmF5IHBhdGggJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXlOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5RGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBhcnJheURhdGFbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChlbnRyeSwga2V5cy5zbGljZShpICsgMSksIHZhbHVlW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkIG9mIGFycmF5RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoZCwga2V5cy5zbGljZShpICsgMSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkuZW5kc1dpdGgoJ1swXScpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgIGlmICghKGtleU5hbWUgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2tleU5hbWVdID0gW3t9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFycmF5RGF0YSA9IGRhdGFba2V5TmFtZV07XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChhcnJheURhdGFbMF0sIGtleXMuc2xpY2UoaSArIDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhW2tleV0gfHwgdHlwZW9mIGRhdGFba2V5XSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBkYXRhW2tleV07XG4gICAgfVxuICAgIGNvbnN0IGtleVRvU2V0ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGV4aXN0aW5nRGF0YSA9IGRhdGFba2V5VG9TZXRdO1xuICAgIGlmIChleGlzdGluZ0RhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZXhpc3RpbmdEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleGlzdGluZ0RhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBleGlzdGluZ0RhdGEgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGV4aXN0aW5nRGF0YSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2V0IHZhbHVlIGZvciBhbiBleGlzdGluZyBrZXkuIEtleTogJHtrZXlUb1NldH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGtleVRvU2V0ID09PSAnX3NlbGYnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUFzUmVjb3JkID0gdmFsdWU7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEsIHZhbHVlQXNSZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YVtrZXlUb1NldF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlQnlQYXRoKGRhdGEsIGtleXMsIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnX3NlbGYnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5RGF0YS5tYXAoKGQpID0+IGdldFZhbHVlQnlQYXRoKGQsIGtleXMuc2xpY2UoaSArIDEpLCBkZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG4vKipcbiAqIE1vdmVzIHZhbHVlcyBmcm9tIHNvdXJjZSBwYXRocyB0byBkZXN0aW5hdGlvbiBwYXRocy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqICAgbW92ZVZhbHVlQnlQYXRoKFxuICogICAgIHsncmVxdWVzdHMnOiBbeydjb250ZW50JzogdjF9LCB7J2NvbnRlbnQnOiB2Mn1dfSxcbiAqICAgICB7J3JlcXVlc3RzW10uKic6ICdyZXF1ZXN0c1tdLnJlcXVlc3QuKid9XG4gKiAgIClcbiAqICAgICAtPiB7J3JlcXVlc3RzJzogW3sncmVxdWVzdCc6IHsnY29udGVudCc6IHYxfX0sIHsncmVxdWVzdCc6IHsnY29udGVudCc6IHYyfX1dfVxuICovXG5mdW5jdGlvbiBtb3ZlVmFsdWVCeVBhdGgoZGF0YSwgcGF0aHMpIHtcbiAgICBmb3IgKGNvbnN0IFtzb3VyY2VQYXRoLCBkZXN0UGF0aF0gb2YgT2JqZWN0LmVudHJpZXMocGF0aHMpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUtleXMgPSBzb3VyY2VQYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGNvbnN0IGRlc3RLZXlzID0gZGVzdFBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGtleXMgdG8gZXhjbHVkZSBmcm9tIHdpbGRjYXJkIHRvIGF2b2lkIGN5Y2xpYyByZWZlcmVuY2VzXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgd2lsZGNhcmRJZHggPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlS2V5c1tpXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgd2lsZGNhcmRJZHggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWxkY2FyZElkeCAhPT0gLTEgJiYgZGVzdEtleXMubGVuZ3RoID4gd2lsZGNhcmRJZHgpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGludGVybWVkaWF0ZSBrZXkgYmV0d2VlbiBzb3VyY2UgYW5kIGRlc3QgcGF0aHNcbiAgICAgICAgICAgIC8vIEV4YW1wbGU6IHNvdXJjZT1bJ3JlcXVlc3RzW10nLCAnKiddLCBkZXN0PVsncmVxdWVzdHNbXScsICdyZXF1ZXN0JywgJyonXVxuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBleGNsdWRlICdyZXF1ZXN0J1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHdpbGRjYXJkSWR4OyBpIDwgZGVzdEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBkZXN0S2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnKicgJiYgIWtleS5lbmRzV2l0aCgnW10nKSAmJiAha2V5LmVuZHNXaXRoKCdbMF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBleGNsdWRlS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX21vdmVWYWx1ZVJlY3Vyc2l2ZShkYXRhLCBzb3VyY2VLZXlzLCBkZXN0S2V5cywgMCwgZXhjbHVkZUtleXMpO1xuICAgIH1cbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgbW92ZXMgdmFsdWVzIGZyb20gc291cmNlIHBhdGggdG8gZGVzdGluYXRpb24gcGF0aC5cbiAqL1xuZnVuY3Rpb24gX21vdmVWYWx1ZVJlY3Vyc2l2ZShkYXRhLCBzb3VyY2VLZXlzLCBkZXN0S2V5cywga2V5SWR4LCBleGNsdWRlS2V5cykge1xuICAgIGlmIChrZXlJZHggPj0gc291cmNlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBzb3VyY2VLZXlzW2tleUlkeF07XG4gICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgY29uc3QgZGF0YVJlY29yZCA9IGRhdGE7XG4gICAgICAgIGlmIChrZXlOYW1lIGluIGRhdGFSZWNvcmQgJiYgQXJyYXkuaXNBcnJheShkYXRhUmVjb3JkW2tleU5hbWVdKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGRhdGFSZWNvcmRba2V5TmFtZV0pIHtcbiAgICAgICAgICAgICAgICBfbW92ZVZhbHVlUmVjdXJzaXZlKGl0ZW0sIHNvdXJjZUtleXMsIGRlc3RLZXlzLCBrZXlJZHggKyAxLCBleGNsdWRlS2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5ID09PSAnKicpIHtcbiAgICAgICAgLy8gd2lsZGNhcmQgLSBtb3ZlIGFsbCBmaWVsZHNcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhUmVjb3JkID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGtleXNUb01vdmUgPSBPYmplY3Qua2V5cyhkYXRhUmVjb3JkKS5maWx0ZXIoKGspID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSAmJiAhZXhjbHVkZUtleXMuaGFzKGspKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlc1RvTW92ZSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXNUb01vdmUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNUb01vdmVba10gPSBkYXRhUmVjb3JkW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHZhbHVlcyBhdCBkZXN0aW5hdGlvblxuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsdWVzVG9Nb3ZlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rlc3RLZXlzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkayBvZiBkZXN0S2V5cy5zbGljZShrZXlJZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkayA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEZXN0S2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVzdEtleXMucHVzaChkayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoZGF0YVJlY29yZCwgbmV3RGVzdEtleXMsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXNUb01vdmUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YVJlY29yZFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTmF2aWdhdGUgdG8gbmV4dCBsZXZlbFxuICAgICAgICBjb25zdCBkYXRhUmVjb3JkID0gZGF0YTtcbiAgICAgICAgaWYgKGtleSBpbiBkYXRhUmVjb3JkKSB7XG4gICAgICAgICAgICBfbW92ZVZhbHVlUmVjdXJzaXZlKGRhdGFSZWNvcmRba2V5XSwgc291cmNlS2V5cywgZGVzdEtleXMsIGtleUlkeCArIDEsIGV4Y2x1ZGVLZXlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdEJ5dGVzJDEoZnJvbUJ5dGVzKSB7XG4gICAgaWYgKHR5cGVvZiBmcm9tQnl0ZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbUltYWdlQnl0ZXMgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICAvLyBUT0RPKGIvMzg5MTMzOTE0KTogUmVtb3ZlIGR1bW15IGJ5dGVzIGNvbnZlcnRlci5cbiAgICByZXR1cm4gZnJvbUJ5dGVzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PcGVyYXRpb25OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PcGVyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3BlcmF0aW9uTmFtZSddLCBmcm9tT3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvdXJjZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc291cmNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVJlc291cmNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAncmVzb3VyY2VOYW1lJ10sIGZyb21SZXNvdXJjZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2UnLFxuICAgICAgICAnZ2VuZXJhdGVWaWRlb1Jlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldiQxKGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4JDEoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVkU2FtcGxlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9zJ10pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRWaWRlb3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21NbGRldiQxKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21WZXJ0ZXgkMShmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBpbXBvcnRGaWxlUmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZVJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmVudCddLCBmcm9tUGFyZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvY3VtZW50TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10pO1xuICAgIGlmIChmcm9tRG9jdW1lbnROYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10sIGZyb21Eb2N1bWVudE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmVudCddLCBmcm9tUGFyZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvY3VtZW50TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10pO1xuICAgIGlmIChmcm9tRG9jdW1lbnROYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10sIGZyb21Eb2N1bWVudE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kZWRWaWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyQxKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RpbmcnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzJDEoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKiogT3V0Y29tZSBvZiB0aGUgY29kZSBleGVjdXRpb24uICovXG52YXIgT3V0Y29tZTtcbihmdW5jdGlvbiAoT3V0Y29tZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHN0YXR1cy4gVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfVU5TUEVDSUZJRURcIl0gPSBcIk9VVENPTUVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX09LXCJdID0gXCJPVVRDT01FX09LXCI7XG4gICAgLyoqXG4gICAgICogQ29kZSBleGVjdXRpb24gZmluaXNoZWQgYnV0IHdpdGggYSBmYWlsdXJlLiBgc3RkZXJyYCBzaG91bGQgY29udGFpbiB0aGUgcmVhc29uLlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX0ZBSUxFRFwiXSA9IFwiT1VUQ09NRV9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiByYW4gZm9yIHRvbyBsb25nLCBhbmQgd2FzIGNhbmNlbGxlZC4gVGhlcmUgbWF5IG9yIG1heSBub3QgYmUgYSBwYXJ0aWFsIG91dHB1dCBwcmVzZW50LlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX0RFQURMSU5FX0VYQ0VFREVEXCJdID0gXCJPVVRDT01FX0RFQURMSU5FX0VYQ0VFREVEXCI7XG59KShPdXRjb21lIHx8IChPdXRjb21lID0ge30pKTtcbi8qKiBQcm9ncmFtbWluZyBsYW5ndWFnZSBvZiB0aGUgYGNvZGVgLiAqL1xudmFyIExhbmd1YWdlO1xuKGZ1bmN0aW9uIChMYW5ndWFnZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGxhbmd1YWdlLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBMYW5ndWFnZVtcIkxBTkdVQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJMQU5HVUFHRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFB5dGhvbiA+PSAzLjEwLCB3aXRoIG51bXB5IGFuZCBzaW1weSBhdmFpbGFibGUuXG4gICAgICovXG4gICAgTGFuZ3VhZ2VbXCJQWVRIT05cIl0gPSBcIlBZVEhPTlwiO1xufSkoTGFuZ3VhZ2UgfHwgKExhbmd1YWdlID0ge30pKTtcbi8qKiBTcGVjaWZpZXMgaG93IHRoZSByZXNwb25zZSBzaG91bGQgYmUgc2NoZWR1bGVkIGluIHRoZSBjb252ZXJzYXRpb24uICovXG52YXIgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmc7XG4oZnVuY3Rpb24gKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJTQ0hFRFVMSU5HX1VOU1BFQ0lGSUVEXCJdID0gXCJTQ0hFRFVMSU5HX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT25seSBhZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGRvIG5vdCBpbnRlcnJ1cHQgb3IgdHJpZ2dlciBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiU0lMRU5UXCJdID0gXCJTSUxFTlRcIjtcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGFuZCBwcm9tcHQgdG8gZ2VuZXJhdGUgb3V0cHV0IHdpdGhvdXQgaW50ZXJydXB0aW5nIG9uZ29pbmcgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIldIRU5fSURMRVwiXSA9IFwiV0hFTl9JRExFXCI7XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSByZXN1bHQgdG8gdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0LCBpbnRlcnJ1cHQgb25nb2luZyBnZW5lcmF0aW9uIGFuZCBwcm9tcHQgdG8gZ2VuZXJhdGUgb3V0cHV0LlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiSU5URVJSVVBUXCJdID0gXCJJTlRFUlJVUFRcIjtcbn0pKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nIHx8IChGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZyA9IHt9KSk7XG4vKiogVGhlIHR5cGUgb2YgdGhlIGRhdGEuICovXG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIC8qKlxuICAgICAqIE5vdCBzcGVjaWZpZWQsIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBUeXBlW1wiVFlQRV9VTlNQRUNJRklFRFwiXSA9IFwiVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgc3RyaW5nIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiU1RSSU5HXCJdID0gXCJTVFJJTkdcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIG51bWJlciB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk5VTUJFUlwiXSA9IFwiTlVNQkVSXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBpbnRlZ2VyIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiSU5URUdFUlwiXSA9IFwiSU5URUdFUlwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgYm9vbGVhbiB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIkJPT0xFQU5cIl0gPSBcIkJPT0xFQU5cIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIGFycmF5IHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiQVJSQVlcIl0gPSBcIkFSUkFZXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBvYmplY3QgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJPQkpFQ1RcIl0gPSBcIk9CSkVDVFwiO1xuICAgIC8qKlxuICAgICAqIE51bGwgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJOVUxMXCJdID0gXCJOVUxMXCI7XG59KShUeXBlIHx8IChUeXBlID0ge30pKTtcbi8qKiBUaGUgQVBJIHNwZWMgdGhhdCB0aGUgZXh0ZXJuYWwgQVBJIGltcGxlbWVudHMuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQXBpU3BlYztcbihmdW5jdGlvbiAoQXBpU3BlYykge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIEFQSSBzcGVjLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiQVBJX1NQRUNfVU5TUEVDSUZJRURcIl0gPSBcIkFQSV9TUEVDX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIHNlYXJjaCBBUEkgc3BlYy5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiU0lNUExFX1NFQVJDSFwiXSA9IFwiU0lNUExFX1NFQVJDSFwiO1xuICAgIC8qKlxuICAgICAqIEVsYXN0aWMgc2VhcmNoIEFQSSBzcGVjLlxuICAgICAqL1xuICAgIEFwaVNwZWNbXCJFTEFTVElDX1NFQVJDSFwiXSA9IFwiRUxBU1RJQ19TRUFSQ0hcIjtcbn0pKEFwaVNwZWMgfHwgKEFwaVNwZWMgPSB7fSkpO1xuLyoqIFR5cGUgb2YgYXV0aCBzY2hlbWUuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQXV0aFR5cGU7XG4oZnVuY3Rpb24gKEF1dGhUeXBlKSB7XG4gICAgQXV0aFR5cGVbXCJBVVRIX1RZUEVfVU5TUEVDSUZJRURcIl0gPSBcIkFVVEhfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5vIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJOT19BVVRIXCJdID0gXCJOT19BVVRIXCI7XG4gICAgLyoqXG4gICAgICogQVBJIEtleSBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiQVBJX0tFWV9BVVRIXCJdID0gXCJBUElfS0VZX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBIVFRQIEJhc2ljIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJIVFRQX0JBU0lDX0FVVEhcIl0gPSBcIkhUVFBfQkFTSUNfQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIEdvb2dsZSBTZXJ2aWNlIEFjY291bnQgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfQVVUSFwiXSA9IFwiR09PR0xFX1NFUlZJQ0VfQUNDT1VOVF9BVVRIXCI7XG4gICAgLyoqXG4gICAgICogT0F1dGggYXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIk9BVVRIXCJdID0gXCJPQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5JRCBDb25uZWN0IChPSURDKSBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiT0lEQ19BVVRIXCJdID0gXCJPSURDX0FVVEhcIjtcbn0pKEF1dGhUeXBlIHx8IChBdXRoVHlwZSA9IHt9KSk7XG4vKiogVGhlIGxvY2F0aW9uIG9mIHRoZSBBUEkga2V5LiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIEh0dHBFbGVtZW50TG9jYXRpb247XG4oZnVuY3Rpb24gKEh0dHBFbGVtZW50TG9jYXRpb24pIHtcbiAgICBIdHRwRWxlbWVudExvY2F0aW9uW1wiSFRUUF9JTl9VTlNQRUNJRklFRFwiXSA9IFwiSFRUUF9JTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBxdWVyeS5cbiAgICAgKi9cbiAgICBIdHRwRWxlbWVudExvY2F0aW9uW1wiSFRUUF9JTl9RVUVSWVwiXSA9IFwiSFRUUF9JTl9RVUVSWVwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBoZWFkZXIuXG4gICAgICovXG4gICAgSHR0cEVsZW1lbnRMb2NhdGlvbltcIkhUVFBfSU5fSEVBREVSXCJdID0gXCJIVFRQX0lOX0hFQURFUlwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBwYXRoLlxuICAgICAqL1xuICAgIEh0dHBFbGVtZW50TG9jYXRpb25bXCJIVFRQX0lOX1BBVEhcIl0gPSBcIkhUVFBfSU5fUEFUSFwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBib2R5LlxuICAgICAqL1xuICAgIEh0dHBFbGVtZW50TG9jYXRpb25bXCJIVFRQX0lOX0JPRFlcIl0gPSBcIkhUVFBfSU5fQk9EWVwiO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgaXMgaW4gdGhlIEhUVFAgcmVxdWVzdCBjb29raWUuXG4gICAgICovXG4gICAgSHR0cEVsZW1lbnRMb2NhdGlvbltcIkhUVFBfSU5fQ09PS0lFXCJdID0gXCJIVFRQX0lOX0NPT0tJRVwiO1xufSkoSHR0cEVsZW1lbnRMb2NhdGlvbiB8fCAoSHR0cEVsZW1lbnRMb2NhdGlvbiA9IHt9KSk7XG4vKiogU2l0ZXMgd2l0aCBjb25maWRlbmNlIGxldmVsIGNob3NlbiAmIGFib3ZlIHRoaXMgdmFsdWUgd2lsbCBiZSBibG9ja2VkIGZyb20gdGhlIHNlYXJjaCByZXN1bHRzLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFBoaXNoQmxvY2tUaHJlc2hvbGQ7XG4oZnVuY3Rpb24gKFBoaXNoQmxvY2tUaHJlc2hvbGQpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0cyB0byB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiUEhJU0hfQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCJdID0gXCJQSElTSF9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBCbG9ja3MgTG93IGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2tzIE1lZGl1bSBhbmQgYWJvdmUgY29uZmlkZW5jZSBVUkwgdGhhdCBpcyByaXNreS5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBIaWdoIGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19ISUdIX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfSElHSF9BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9ja3MgSGlnaGVyIGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19ISUdIRVJfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19ISUdIRVJfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2tzIFZlcnkgaGlnaCBhbmQgYWJvdmUgY29uZmlkZW5jZSBVUkwgdGhhdCBpcyByaXNreS5cbiAgICAgKi9cbiAgICBQaGlzaEJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfVkVSWV9ISUdIX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfVkVSWV9ISUdIX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBFeHRyZW1lbHkgaGlnaCBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19PTkxZX0VYVFJFTUVMWV9ISUdIXCJdID0gXCJCTE9DS19PTkxZX0VYVFJFTUVMWV9ISUdIXCI7XG59KShQaGlzaEJsb2NrVGhyZXNob2xkIHx8IChQaGlzaEJsb2NrVGhyZXNob2xkID0ge30pKTtcbi8qKiBTcGVjaWZpZXMgdGhlIGZ1bmN0aW9uIEJlaGF2aW9yLiBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEJpZGlHZW5lcmF0ZUNvbnRlbnQgbWV0aG9kLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuICovXG52YXIgQmVoYXZpb3I7XG4oZnVuY3Rpb24gKEJlaGF2aW9yKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJVTlNQRUNJRklFRFwiXSA9IFwiVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSBzeXN0ZW0gd2lsbCB3YWl0IHRvIHJlY2VpdmUgdGhlIGZ1bmN0aW9uIHJlc3BvbnNlIGJlZm9yZSBjb250aW51aW5nIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJCTE9DS0lOR1wiXSA9IFwiQkxPQ0tJTkdcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSBzeXN0ZW0gd2lsbCBub3Qgd2FpdCB0byByZWNlaXZlIHRoZSBmdW5jdGlvbiByZXNwb25zZS4gSW5zdGVhZCwgaXQgd2lsbCBhdHRlbXB0IHRvIGhhbmRsZSBmdW5jdGlvbiByZXNwb25zZXMgYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlIHdoaWxlIG1haW50YWluaW5nIHRoZSBjb252ZXJzYXRpb24gYmV0d2VlbiB0aGUgdXNlciBhbmQgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiTk9OX0JMT0NLSU5HXCJdID0gXCJOT05fQkxPQ0tJTkdcIjtcbn0pKEJlaGF2aW9yIHx8IChCZWhhdmlvciA9IHt9KSk7XG4vKiogVGhlIG1vZGUgb2YgdGhlIHByZWRpY3RvciB0byBiZSB1c2VkIGluIGR5bmFtaWMgcmV0cmlldmFsLiAqL1xudmFyIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlO1xuKGZ1bmN0aW9uIChEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEFsd2F5cyB0cmlnZ2VyIHJldHJpZXZhbC5cbiAgICAgKi9cbiAgICBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBSdW4gcmV0cmlldmFsIG9ubHkgd2hlbiBzeXN0ZW0gZGVjaWRlcyBpdCBpcyBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGVbXCJNT0RFX0RZTkFNSUNcIl0gPSBcIk1PREVfRFlOQU1JQ1wiO1xufSkoRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUgfHwgKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlID0ge30pKTtcbi8qKiBGdW5jdGlvbiBjYWxsaW5nIG1vZGUuICovXG52YXIgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZTtcbihmdW5jdGlvbiAoRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGZ1bmN0aW9uIGNhbGxpbmcgbW9kZS4gVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG1vZGVsIGJlaGF2aW9yLCBtb2RlbCBkZWNpZGVzIHRvIHByZWRpY3QgZWl0aGVyIGZ1bmN0aW9uIGNhbGxzIG9yIG5hdHVyYWwgbGFuZ3VhZ2UgcmVzcG9uc2UuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIkFVVE9cIl0gPSBcIkFVVE9cIjtcbiAgICAvKipcbiAgICAgKiBNb2RlbCBpcyBjb25zdHJhaW5lZCB0byBhbHdheXMgcHJlZGljdGluZyBmdW5jdGlvbiBjYWxscyBvbmx5LiBJZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiBhcmUgc2V0LCB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGxzIHdpbGwgYmUgbGltaXRlZCB0byBhbnkgb25lIG9mIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiLCBlbHNlIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbHMgd2lsbCBiZSBhbnkgb25lIG9mIHRoZSBwcm92aWRlZCBcImZ1bmN0aW9uX2RlY2xhcmF0aW9uc1wiLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJBTllcIl0gPSBcIkFOWVwiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIHdpbGwgbm90IHByZWRpY3QgYW55IGZ1bmN0aW9uIGNhbGxzLiBNb2RlbCBiZWhhdmlvciBpcyBzYW1lIGFzIHdoZW4gbm90IHBhc3NpbmcgYW55IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucy5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiTk9ORVwiXSA9IFwiTk9ORVwiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIGlzIGNvbnN0cmFpbmVkIHRvIHByZWRpY3QgZWl0aGVyIGZ1bmN0aW9uIGNhbGxzIG9yIG5hdHVyYWwgbGFuZ3VhZ2UgcmVzcG9uc2UuIElmIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiIGFyZSBzZXQsIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbHMgd2lsbCBiZSBsaW1pdGVkIHRvIGFueSBvbmUgb2YgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIsIGVsc2UgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxscyB3aWxsIGJlIGFueSBvbmUgb2YgdGhlIHByb3ZpZGVkIFwiZnVuY3Rpb25fZGVjbGFyYXRpb25zXCIuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIlZBTElEQVRFRFwiXSA9IFwiVkFMSURBVEVEXCI7XG59KShGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlIHx8IChGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlID0ge30pKTtcbi8qKiBUaGUgbnVtYmVyIG9mIHRob3VnaHRzIHRva2VucyB0aGF0IHRoZSBtb2RlbCBzaG91bGQgZ2VuZXJhdGUuICovXG52YXIgVGhpbmtpbmdMZXZlbDtcbihmdW5jdGlvbiAoVGhpbmtpbmdMZXZlbCkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHRoaW5raW5nIGxldmVsLlxuICAgICAqL1xuICAgIFRoaW5raW5nTGV2ZWxbXCJUSElOS0lOR19MRVZFTF9VTlNQRUNJRklFRFwiXSA9IFwiVEhJTktJTkdfTEVWRUxfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBMb3cgdGhpbmtpbmcgbGV2ZWwuXG4gICAgICovXG4gICAgVGhpbmtpbmdMZXZlbFtcIkxPV1wiXSA9IFwiTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaXVtIHRoaW5raW5nIGxldmVsLlxuICAgICAqL1xuICAgIFRoaW5raW5nTGV2ZWxbXCJNRURJVU1cIl0gPSBcIk1FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIEhpZ2ggdGhpbmtpbmcgbGV2ZWwuXG4gICAgICovXG4gICAgVGhpbmtpbmdMZXZlbFtcIkhJR0hcIl0gPSBcIkhJR0hcIjtcbiAgICAvKipcbiAgICAgKiBNSU5JTUFMIHRoaW5raW5nIGxldmVsLlxuICAgICAqL1xuICAgIFRoaW5raW5nTGV2ZWxbXCJNSU5JTUFMXCJdID0gXCJNSU5JTUFMXCI7XG59KShUaGlua2luZ0xldmVsIHx8IChUaGlua2luZ0xldmVsID0ge30pKTtcbi8qKiBIYXJtIGNhdGVnb3J5LiAqL1xudmFyIEhhcm1DYXRlZ29yeTtcbihmdW5jdGlvbiAoSGFybUNhdGVnb3J5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGhhcmFzc21lbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9IQVJBU1NNRU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBoYXRlIHNwZWVjaC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCJdID0gXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgc2V4dWFsbHkgZXhwbGljaXQgY29udGVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCJdID0gXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgZGFuZ2Vyb3VzIGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9EQU5HRVJPVVNfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQ6IEVsZWN0aW9uIGZpbHRlciBpcyBub3QgbG9uZ2VyIHN1cHBvcnRlZC4gVGhlIGhhcm0gY2F0ZWdvcnkgaXMgY2l2aWMgaW50ZWdyaXR5LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfQ0lWSUNfSU5URUdSSVRZXCJdID0gXCJIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIGhhdGUuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVRFXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBVEVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBkYW5nZXJvdXMgY29udGVudC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0RBTkdFUk9VU19DT05URU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0RBTkdFUk9VU19DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2UgaGFyYXNzbWVudC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFSQVNTTUVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIHNleHVhbGx5IGV4cGxpY2l0IGNvbnRlbnQuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9TRVhVQUxMWV9FWFBMSUNJVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9TRVhVQUxMWV9FWFBMSUNJVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGZvciBqYWlsYnJlYWsgcHJvbXB0cy4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0pBSUxCUkVBS1wiXSA9IFwiSEFSTV9DQVRFR09SWV9KQUlMQlJFQUtcIjtcbn0pKEhhcm1DYXRlZ29yeSB8fCAoSGFybUNhdGVnb3J5ID0ge30pKTtcbi8qKiBTcGVjaWZ5IGlmIHRoZSB0aHJlc2hvbGQgaXMgdXNlZCBmb3IgcHJvYmFiaWxpdHkgb3Igc2V2ZXJpdHkgc2NvcmUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aHJlc2hvbGQgaXMgdXNlZCBmb3IgcHJvYmFiaWxpdHkgc2NvcmUuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgSGFybUJsb2NrTWV0aG9kO1xuKGZ1bmN0aW9uIChIYXJtQmxvY2tNZXRob2QpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBibG9jayBtZXRob2QgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybUJsb2NrTWV0aG9kW1wiSEFSTV9CTE9DS19NRVRIT0RfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQkxPQ0tfTUVUSE9EX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gYmxvY2sgbWV0aG9kIHVzZXMgYm90aCBwcm9iYWJpbGl0eSBhbmQgc2V2ZXJpdHkgc2NvcmVzLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja01ldGhvZFtcIlNFVkVSSVRZXCJdID0gXCJTRVZFUklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGJsb2NrIG1ldGhvZCB1c2VzIHRoZSBwcm9iYWJpbGl0eSBzY29yZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tNZXRob2RbXCJQUk9CQUJJTElUWVwiXSA9IFwiUFJPQkFCSUxJVFlcIjtcbn0pKEhhcm1CbG9ja01ldGhvZCB8fCAoSGFybUJsb2NrTWV0aG9kID0ge30pKTtcbi8qKiBUaGUgaGFybSBibG9jayB0aHJlc2hvbGQuICovXG52YXIgSGFybUJsb2NrVGhyZXNob2xkO1xuKGZ1bmN0aW9uIChIYXJtQmxvY2tUaHJlc2hvbGQpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBoYXJtIGJsb2NrIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJIQVJNX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBsb3cgdGhyZXNob2xkIGFuZCBhYm92ZSAoaS5lLiBibG9jayBtb3JlKS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgbWVkaXVtIHRocmVzaG9sZCBhbmQgYWJvdmUuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIG9ubHkgaGlnaCB0aHJlc2hvbGQgKGkuZS4gYmxvY2sgbGVzcykuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfT05MWV9ISUdIXCJdID0gXCJCTE9DS19PTkxZX0hJR0hcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBub25lLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX05PTkVcIl0gPSBcIkJMT0NLX05PTkVcIjtcbiAgICAvKipcbiAgICAgKiBUdXJuIG9mZiB0aGUgc2FmZXR5IGZpbHRlci5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJPRkZcIl0gPSBcIk9GRlwiO1xufSkoSGFybUJsb2NrVGhyZXNob2xkIHx8IChIYXJtQmxvY2tUaHJlc2hvbGQgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUaGUgcmVhc29uIHdoeSB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy5cblxuSWYgZW1wdHksIHRoZSBtb2RlbCBoYXMgbm90IHN0b3BwZWQgZ2VuZXJhdGluZyB0aGUgdG9rZW5zLiAqL1xudmFyIEZpbmlzaFJlYXNvbjtcbihmdW5jdGlvbiAoRmluaXNoUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmlzaCByZWFzb24gaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiXSA9IFwiRklOSVNIX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gcmVhY2hlZCBhIG5hdHVyYWwgc3RvcHBpbmcgcG9pbnQgb3IgYSBjb25maWd1cmVkIHN0b3Agc2VxdWVuY2UuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU1RPUFwiXSA9IFwiU1RPUFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gcmVhY2hlZCB0aGUgY29uZmlndXJlZCBtYXhpbXVtIG91dHB1dCB0b2tlbnMuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTUFYX1RPS0VOU1wiXSA9IFwiTUFYX1RPS0VOU1wiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IHBvdGVudGlhbGx5IGNvbnRhaW5zIHNhZmV0eSB2aW9sYXRpb25zLiBOT1RFOiBXaGVuIHN0cmVhbWluZywgW2NvbnRlbnRdW10gaXMgZW1wdHkgaWYgY29udGVudCBmaWx0ZXJzIGJsb2NrcyB0aGUgb3V0cHV0LlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNBRkVUWVwiXSA9IFwiU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIG9mIHBvdGVudGlhbCByZWNpdGF0aW9uLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlJFQ0lUQVRJT05cIl0gPSBcIlJFQ0lUQVRJT05cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2Ugb2YgdXNpbmcgYW4gdW5zdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTEFOR1VBR0VcIl0gPSBcIkxBTkdVQUdFXCI7XG4gICAgLyoqXG4gICAgICogQWxsIG90aGVyIHJlYXNvbnMgdGhhdCBzdG9wcGVkIHRoZSB0b2tlbiBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIk9USEVSXCJdID0gXCJPVEhFUlwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IGNvbnRhaW5zIGZvcmJpZGRlbiB0ZXJtcy5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJCTE9DS0xJU1RcIl0gPSBcIkJMT0NLTElTVFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBmb3IgcG90ZW50aWFsbHkgY29udGFpbmluZyBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSB0aGUgY29udGVudCBwb3RlbnRpYWxseSBjb250YWlucyBTZW5zaXRpdmUgUGVyc29uYWxseSBJZGVudGlmaWFibGUgSW5mb3JtYXRpb24gKFNQSUkpLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNQSUlcIl0gPSBcIlNQSUlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIl0gPSBcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgZ2VuZXJhdGVkIGltYWdlcyBoYXZlIHNhZmV0eSB2aW9sYXRpb25zLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIklNQUdFX1NBRkVUWVwiXSA9IFwiSU1BR0VfU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRvb2wgY2FsbCBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiVU5FWFBFQ1RFRF9UT09MX0NBTExcIl0gPSBcIlVORVhQRUNURURfVE9PTF9DQUxMXCI7XG4gICAgLyoqXG4gICAgICogSW1hZ2UgZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGdlbmVyYXRlZCBpbWFnZXMgaGF2ZSBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiSU1BR0VfUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJJTUFHRV9QUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgd2FzIGV4cGVjdGVkIHRvIGdlbmVyYXRlIGFuIGltYWdlLCBidXQgbm9uZSB3YXMgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIk5PX0lNQUdFXCJdID0gXCJOT19JTUFHRVwiO1xuICAgIC8qKlxuICAgICAqIEltYWdlIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBnZW5lcmF0ZWQgaW1hZ2UgbWF5IGJlIGEgcmVjaXRhdGlvbiBmcm9tIGEgc291cmNlLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIklNQUdFX1JFQ0lUQVRJT05cIl0gPSBcIklNQUdFX1JFQ0lUQVRJT05cIjtcbiAgICAvKipcbiAgICAgKiBJbWFnZSBnZW5lcmF0aW9uIHN0b3BwZWQgZm9yIGEgcmVhc29uIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIklNQUdFX09USEVSXCJdID0gXCJJTUFHRV9PVEhFUlwiO1xufSkoRmluaXNoUmVhc29uIHx8IChGaW5pc2hSZWFzb24gPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBIYXJtIHByb2JhYmlsaXR5IGxldmVscyBpbiB0aGUgY29udGVudC4gKi9cbnZhciBIYXJtUHJvYmFiaWxpdHk7XG4oZnVuY3Rpb24gKEhhcm1Qcm9iYWJpbGl0eSkge1xuICAgIC8qKlxuICAgICAqIEhhcm0gcHJvYmFiaWxpdHkgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5lZ2xpZ2libGUgbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJORUdMSUdJQkxFXCJdID0gXCJORUdMSUdJQkxFXCI7XG4gICAgLyoqXG4gICAgICogTG93IGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTE9XXCJdID0gXCJMT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpdW0gbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJNRURJVU1cIl0gPSBcIk1FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJISUdIXCJdID0gXCJISUdIXCI7XG59KShIYXJtUHJvYmFiaWxpdHkgfHwgKEhhcm1Qcm9iYWJpbGl0eSA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIEhhcm0gc2V2ZXJpdHkgbGV2ZWxzIGluIHRoZSBjb250ZW50LiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIEhhcm1TZXZlcml0eTtcbihmdW5jdGlvbiAoSGFybVNldmVyaXR5KSB7XG4gICAgLyoqXG4gICAgICogSGFybSBzZXZlcml0eSB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX1NFVkVSSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTmVnbGlnaWJsZSBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTkVHTElHSUJMRVwiXSA9IFwiSEFSTV9TRVZFUklUWV9ORUdMSUdJQkxFXCI7XG4gICAgLyoqXG4gICAgICogTG93IGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9MT1dcIl0gPSBcIkhBUk1fU0VWRVJJVFlfTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaXVtIGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9NRURJVU1cIl0gPSBcIkhBUk1fU0VWRVJJVFlfTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfSElHSFwiXSA9IFwiSEFSTV9TRVZFUklUWV9ISUdIXCI7XG59KShIYXJtU2V2ZXJpdHkgfHwgKEhhcm1TZXZlcml0eSA9IHt9KSk7XG4vKiogU3RhdHVzIG9mIHRoZSB1cmwgcmV0cmlldmFsLiAqL1xudmFyIFVybFJldHJpZXZhbFN0YXR1cztcbihmdW5jdGlvbiAoVXJsUmV0cmlldmFsU3RhdHVzKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TUEVDSUZJRURcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1NVQ0NFU1NcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1NVQ0NFU1NcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBkdWUgdG8gZXJyb3IuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfRVJST1JcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX0VSUk9SXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBmYWlsZWQgYmVjYXVzZSB0aGUgY29udGVudCBpcyBiZWhpbmQgcGF5d2FsbC4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1BBWVdBTExcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1BBWVdBTExcIjtcbiAgICAvKipcbiAgICAgKiBVcmwgcmV0cmlldmFsIGlzIGZhaWxlZCBiZWNhdXNlIHRoZSBjb250ZW50IGlzIHVuc2FmZS4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU0FGRVwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TQUZFXCI7XG59KShVcmxSZXRyaWV2YWxTdGF0dXMgfHwgKFVybFJldHJpZXZhbFN0YXR1cyA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIFRoZSByZWFzb24gd2h5IHRoZSBwcm9tcHQgd2FzIGJsb2NrZWQuICovXG52YXIgQmxvY2tlZFJlYXNvbjtcbihmdW5jdGlvbiAoQmxvY2tlZFJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2VkIHJlYXNvbiBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiQkxPQ0tFRF9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIkJMT0NLRURfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBmb3Igc2FmZXR5IHJlYXNvbnMuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIlNBRkVUWVwiXSA9IFwiU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBmb3Igb3RoZXIgcmVhc29ucy4gRm9yIGV4YW1wbGUsIGl0IG1heSBiZSBkdWUgdG8gdGhlIHByb21wdCdzIGxhbmd1YWdlLCBvciBiZWNhdXNlIGl0IGNvbnRhaW5zIG90aGVyIGhhcm1mdWwgY29udGVudC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBiZWNhdXNlIGl0IGNvbnRhaW5zIGEgdGVybSBmcm9tIHRoZSB0ZXJtaW5vbG9neSBibG9ja2xpc3QuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIkJMT0NLTElTVFwiXSA9IFwiQkxPQ0tMSVNUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBiZWNhdXNlIGl0IGNvbnRhaW5zIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiUFJPSElCSVRFRF9DT05URU5UXCJdID0gXCJQUk9ISUJJVEVEX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGJlY2F1c2UgaXQgY29udGFpbnMgY29udGVudCB0aGF0IGlzIHVuc2FmZSBmb3IgaW1hZ2UgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiSU1BR0VfU0FGRVRZXCJdID0gXCJJTUFHRV9TQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGJ5IE1vZGVsIEFybW9yLiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJNT0RFTF9BUk1PUlwiXSA9IFwiTU9ERUxfQVJNT1JcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvbXB0IHdhcyBibG9ja2VkIGFzIGEgamFpbGJyZWFrIGF0dGVtcHQuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIkpBSUxCUkVBS1wiXSA9IFwiSkFJTEJSRUFLXCI7XG59KShCbG9ja2VkUmVhc29uIHx8IChCbG9ja2VkUmVhc29uID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gVGhlIHRyYWZmaWMgdHlwZSBmb3IgdGhpcyByZXF1ZXN0LiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFRyYWZmaWNUeXBlO1xuKGZ1bmN0aW9uIChUcmFmZmljVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHJlcXVlc3QgdHJhZmZpYyB0eXBlLlxuICAgICAqL1xuICAgIFRyYWZmaWNUeXBlW1wiVFJBRkZJQ19UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUUkFGRklDX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCB3YXMgcHJvY2Vzc2VkIHVzaW5nIFBheS1Bcy1Zb3UtR28gcXVvdGEuXG4gICAgICovXG4gICAgVHJhZmZpY1R5cGVbXCJPTl9ERU1BTkRcIl0gPSBcIk9OX0RFTUFORFwiO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZm9yIFByb3Zpc2lvbmVkIFRocm91Z2hwdXQgdHJhZmZpYy5cbiAgICAgKi9cbiAgICBUcmFmZmljVHlwZVtcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIl0gPSBcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIjtcbn0pKFRyYWZmaWNUeXBlIHx8IChUcmFmZmljVHlwZSA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNb2RhbGl0eTtcbihmdW5jdGlvbiAoTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gdGV4dFxuICAgICAqL1xuICAgIE1vZGFsaXR5W1wiVEVYVFwiXSA9IFwiVEVYVFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiBpbWFnZXMuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gYXVkaW8uXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJBVURJT1wiXSA9IFwiQVVESU9cIjtcbn0pKE1vZGFsaXR5IHx8IChNb2RhbGl0eSA9IHt9KSk7XG4vKiogVGhlIG1lZGlhIHJlc29sdXRpb24gdG8gdXNlLiAqL1xudmFyIE1lZGlhUmVzb2x1dGlvbjtcbihmdW5jdGlvbiAoTWVkaWFSZXNvbHV0aW9uKSB7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBoYXMgbm90IGJlZW4gc2V0XG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGxvdyAoNjQgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBtZWRpdW0gKDI1NiB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGhpZ2ggKHpvb21lZCByZWZyYW1pbmcgd2l0aCAyNTYgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fSElHSFwiO1xufSkoTWVkaWFSZXNvbHV0aW9uIHx8IChNZWRpYVJlc29sdXRpb24gPSB7fSkpO1xuLyoqIFR1bmluZyBtb2RlLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFR1bmluZ01vZGU7XG4oZnVuY3Rpb24gKFR1bmluZ01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgbW9kZSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfVU5TUEVDSUZJRURcIl0gPSBcIlRVTklOR19NT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogRnVsbCBmaW5lLXR1bmluZyBtb2RlLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9GVUxMXCJdID0gXCJUVU5JTkdfTU9ERV9GVUxMXCI7XG4gICAgLyoqXG4gICAgICogUEVGVCBhZGFwdGVyIHR1bmluZyBtb2RlLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9QRUZUX0FEQVBURVJcIl0gPSBcIlRVTklOR19NT0RFX1BFRlRfQURBUFRFUlwiO1xufSkoVHVuaW5nTW9kZSB8fCAoVHVuaW5nTW9kZSA9IHt9KSk7XG4vKiogQWRhcHRlciBzaXplIGZvciB0dW5pbmcuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgQWRhcHRlclNpemU7XG4oZnVuY3Rpb24gKEFkYXB0ZXJTaXplKSB7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1VOU1BFQ0lGSUVEXCJdID0gXCJBREFQVEVSX1NJWkVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMS5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9PTkVcIl0gPSBcIkFEQVBURVJfU0laRV9PTkVcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9UV09cIl0gPSBcIkFEQVBURVJfU0laRV9UV09cIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgNC5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9GT1VSXCJdID0gXCJBREFQVEVSX1NJWkVfRk9VUlwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSA4LlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX0VJR0hUXCJdID0gXCJBREFQVEVSX1NJWkVfRUlHSFRcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMTYuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfU0lYVEVFTlwiXSA9IFwiQURBUFRFUl9TSVpFX1NJWFRFRU5cIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgMzIuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfVEhJUlRZX1RXT1wiXSA9IFwiQURBUFRFUl9TSVpFX1RISVJUWV9UV09cIjtcbn0pKEFkYXB0ZXJTaXplIHx8IChBZGFwdGVyU2l6ZSA9IHt9KSk7XG4vKiogSm9iIHN0YXRlLiAqL1xudmFyIEpvYlN0YXRlO1xuKGZ1bmN0aW9uIChKb2JTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2Igc3RhdGUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfVU5TUEVDSUZJRURcIl0gPSBcIkpPQl9TVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4ganVzdCBjcmVhdGVkIG9yIHJlc3VtZWQgYW5kIHByb2Nlc3NpbmcgaGFzIG5vdCB5ZXQgYmVndW4uXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUVVFVUVEXCJdID0gXCJKT0JfU1RBVEVfUVVFVUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZpY2UgaXMgcHJlcGFyaW5nIHRvIHJ1biB0aGUgam9iLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BFTkRJTkdcIl0gPSBcIkpPQl9TVEFURV9QRU5ESU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9SVU5OSU5HXCJdID0gXCJKT0JfU1RBVEVfUlVOTklOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9TVUNDRUVERURcIl0gPSBcIkpPQl9TVEFURV9TVUNDRUVERURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGZhaWxlZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9GQUlMRURcIl0gPSBcIkpPQl9TVEFURV9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGJlaW5nIGNhbmNlbGxlZC4gRnJvbSB0aGlzIHN0YXRlIHRoZSBqb2IgbWF5IG9ubHkgZ28gdG8gZWl0aGVyIGBKT0JfU1RBVEVfU1VDQ0VFREVEYCwgYEpPQl9TVEFURV9GQUlMRURgIG9yIGBKT0JfU1RBVEVfQ0FOQ0VMTEVEYC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9DQU5DRUxMSU5HXCJdID0gXCJKT0JfU1RBVEVfQ0FOQ0VMTElOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4gY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0NBTkNFTExFRFwiXSA9IFwiSk9CX1NUQVRFX0NBTkNFTExFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4gc3RvcHBlZCwgYW5kIGNhbiBiZSByZXN1bWVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BBVVNFRFwiXSA9IFwiSk9CX1NUQVRFX1BBVVNFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGV4cGlyZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfRVhQSVJFRFwiXSA9IFwiSk9CX1NUQVRFX0VYUElSRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGJlaW5nIHVwZGF0ZWQuIE9ubHkgam9icyBpbiB0aGUgYEpPQl9TVEFURV9SVU5OSU5HYCBzdGF0ZSBjYW4gYmUgdXBkYXRlZC4gQWZ0ZXIgdXBkYXRpbmcsIHRoZSBqb2IgZ29lcyBiYWNrIHRvIHRoZSBgSk9CX1NUQVRFX1JVTk5JTkdgIHN0YXRlLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1VQREFUSU5HXCJdID0gXCJKT0JfU1RBVEVfVVBEQVRJTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIHBhcnRpYWxseSBzdWNjZWVkZWQsIHNvbWUgcmVzdWx0cyBtYXkgYmUgbWlzc2luZyBkdWUgdG8gZXJyb3JzLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BBUlRJQUxMWV9TVUNDRUVERURcIl0gPSBcIkpPQl9TVEFURV9QQVJUSUFMTFlfU1VDQ0VFREVEXCI7XG59KShKb2JTdGF0ZSB8fCAoSm9iU3RhdGUgPSB7fSkpO1xuLyoqIFRoZSB0dW5pbmcgdGFzay4gRWl0aGVyIEkyViBvciBUMlYuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgVHVuaW5nVGFzaztcbihmdW5jdGlvbiAoVHVuaW5nVGFzaykge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIFR1bmluZ1Rhc2tbXCJUVU5JTkdfVEFTS19VTlNQRUNJRklFRFwiXSA9IFwiVFVOSU5HX1RBU0tfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgdGFzayBmb3IgaW1hZ2UgdG8gdmlkZW8uXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX0kyVlwiXSA9IFwiVFVOSU5HX1RBU0tfSTJWXCI7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIHRhc2sgZm9yIHRleHQgdG8gdmlkZW8uXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX1QyVlwiXSA9IFwiVFVOSU5HX1RBU0tfVDJWXCI7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIHRhc2sgZm9yIHJlZmVyZW5jZSB0byB2aWRlby5cbiAgICAgKi9cbiAgICBUdW5pbmdUYXNrW1wiVFVOSU5HX1RBU0tfUjJWXCJdID0gXCJUVU5JTkdfVEFTS19SMlZcIjtcbn0pKFR1bmluZ1Rhc2sgfHwgKFR1bmluZ1Rhc2sgPSB7fSkpO1xuLyoqIFRoZSB0b2tlbml6YXRpb24gcXVhbGl0eSB1c2VkIGZvciBnaXZlbiBtZWRpYS4gKi9cbnZhciBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWw7XG4oZnVuY3Rpb24gKFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbCkge1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gaGFzIG5vdCBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWxbXCJNRURJQV9SRVNPTFVUSU9OX1VOU1BFQ0lGSUVEXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gbG93LlxuICAgICAqL1xuICAgIFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbFtcIk1FRElBX1JFU09MVVRJT05fTE9XXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIG1lZGl1bS5cbiAgICAgKi9cbiAgICBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWxbXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9NRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBoaWdoLlxuICAgICAqL1xuICAgIFBhcnRNZWRpYVJlc29sdXRpb25MZXZlbFtcIk1FRElBX1JFU09MVVRJT05fSElHSFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9ISUdIXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gdWx0cmEgaGlnaC5cbiAgICAgKi9cbiAgICBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWxbXCJNRURJQV9SRVNPTFVUSU9OX1VMVFJBX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fVUxUUkFfSElHSFwiO1xufSkoUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsIHx8IChQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWwgPSB7fSkpO1xuLyoqIE9wdGlvbnMgZm9yIGZlYXR1cmUgc2VsZWN0aW9uIHByZWZlcmVuY2UuICovXG52YXIgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2U7XG4oZnVuY3Rpb24gKEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlKSB7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJGRUFUVVJFX1NFTEVDVElPTl9QUkVGRVJFTkNFX1VOU1BFQ0lGSUVEXCJdID0gXCJGRUFUVVJFX1NFTEVDVElPTl9QUkVGRVJFTkNFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJQUklPUklUSVpFX1FVQUxJVFlcIl0gPSBcIlBSSU9SSVRJWkVfUVVBTElUWVwiO1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiQkFMQU5DRURcIl0gPSBcIkJBTEFOQ0VEXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJQUklPUklUSVpFX0NPU1RcIl0gPSBcIlBSSU9SSVRJWkVfQ09TVFwiO1xufSkoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgfHwgKEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlID0ge30pKTtcbi8qKiBUaGUgZW52aXJvbm1lbnQgYmVpbmcgb3BlcmF0ZWQuICovXG52YXIgRW52aXJvbm1lbnQ7XG4oZnVuY3Rpb24gKEVudmlyb25tZW50KSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdHMgdG8gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFbnZpcm9ubWVudFtcIkVOVklST05NRU5UX1VOU1BFQ0lGSUVEXCJdID0gXCJFTlZJUk9OTUVOVF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9wZXJhdGVzIGluIGEgd2ViIGJyb3dzZXIuXG4gICAgICovXG4gICAgRW52aXJvbm1lbnRbXCJFTlZJUk9OTUVOVF9CUk9XU0VSXCJdID0gXCJFTlZJUk9OTUVOVF9CUk9XU0VSXCI7XG59KShFbnZpcm9ubWVudCB8fCAoRW52aXJvbm1lbnQgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgc2FmZXR5IGZpbHRlciBsZXZlbCBmb3Igb2JqZWN0aW9uYWJsZSBjb250ZW50LiAqL1xudmFyIFNhZmV0eUZpbHRlckxldmVsO1xuKGZ1bmN0aW9uIChTYWZldHlGaWx0ZXJMZXZlbCkge1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfTE9XX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiO1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTUVESVVNX0FORF9BQk9WRVwiO1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfT05MWV9ISUdIXCJdID0gXCJCTE9DS19PTkxZX0hJR0hcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX05PTkVcIl0gPSBcIkJMT0NLX05PTkVcIjtcbn0pKFNhZmV0eUZpbHRlckxldmVsIHx8IChTYWZldHlGaWx0ZXJMZXZlbCA9IHt9KSk7XG4vKiogRW51bSB0aGF0IGNvbnRyb2xzIHRoZSBnZW5lcmF0aW9uIG9mIHBlb3BsZS4gKi9cbnZhciBQZXJzb25HZW5lcmF0aW9uO1xuKGZ1bmN0aW9uIChQZXJzb25HZW5lcmF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQmxvY2sgZ2VuZXJhdGlvbiBvZiBpbWFnZXMgb2YgcGVvcGxlLlxuICAgICAqL1xuICAgIFBlcnNvbkdlbmVyYXRpb25bXCJET05UX0FMTE9XXCJdID0gXCJET05UX0FMTE9XXCI7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgaW1hZ2VzIG9mIGFkdWx0cywgYnV0IG5vdCBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBQZXJzb25HZW5lcmF0aW9uW1wiQUxMT1dfQURVTFRcIl0gPSBcIkFMTE9XX0FEVUxUXCI7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgaW1hZ2VzIHRoYXQgaW5jbHVkZSBhZHVsdHMgYW5kIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIFBlcnNvbkdlbmVyYXRpb25bXCJBTExPV19BTExcIl0gPSBcIkFMTE9XX0FMTFwiO1xufSkoUGVyc29uR2VuZXJhdGlvbiB8fCAoUGVyc29uR2VuZXJhdGlvbiA9IHt9KSk7XG4vKiogRW51bSB0aGF0IHNwZWNpZmllcyB0aGUgbGFuZ3VhZ2Ugb2YgdGhlIHRleHQgaW4gdGhlIHByb21wdC4gKi9cbnZhciBJbWFnZVByb21wdExhbmd1YWdlO1xuKGZ1bmN0aW9uIChJbWFnZVByb21wdExhbmd1YWdlKSB7XG4gICAgLyoqXG4gICAgICogQXV0by1kZXRlY3QgdGhlIGxhbmd1YWdlLlxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJhdXRvXCJdID0gXCJhdXRvXCI7XG4gICAgLyoqXG4gICAgICogRW5nbGlzaFxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJlblwiXSA9IFwiZW5cIjtcbiAgICAvKipcbiAgICAgKiBKYXBhbmVzZVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJqYVwiXSA9IFwiamFcIjtcbiAgICAvKipcbiAgICAgKiBLb3JlYW5cbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wia29cIl0gPSBcImtvXCI7XG4gICAgLyoqXG4gICAgICogSGluZGlcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiaGlcIl0gPSBcImhpXCI7XG4gICAgLyoqXG4gICAgICogQ2hpbmVzZVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJ6aFwiXSA9IFwiemhcIjtcbiAgICAvKipcbiAgICAgKiBQb3J0dWd1ZXNlXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcInB0XCJdID0gXCJwdFwiO1xuICAgIC8qKlxuICAgICAqIFNwYW5pc2hcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiZXNcIl0gPSBcImVzXCI7XG59KShJbWFnZVByb21wdExhbmd1YWdlIHx8IChJbWFnZVByb21wdExhbmd1YWdlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgbWFzayBtb2RlIG9mIGEgbWFzayByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgTWFza1JlZmVyZW5jZU1vZGU7XG4oZnVuY3Rpb24gKE1hc2tSZWZlcmVuY2VNb2RlKSB7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfREVGQVVMVFwiXSA9IFwiTUFTS19NT0RFX0RFRkFVTFRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9VU0VSX1BST1ZJREVEXCJdID0gXCJNQVNLX01PREVfVVNFUl9QUk9WSURFRFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX0JBQ0tHUk9VTkRcIl0gPSBcIk1BU0tfTU9ERV9CQUNLR1JPVU5EXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfRk9SRUdST1VORFwiXSA9IFwiTUFTS19NT0RFX0ZPUkVHUk9VTkRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9TRU1BTlRJQ1wiXSA9IFwiTUFTS19NT0RFX1NFTUFOVElDXCI7XG59KShNYXNrUmVmZXJlbmNlTW9kZSB8fCAoTWFza1JlZmVyZW5jZU1vZGUgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBjb250cm9sIHR5cGUgb2YgYSBjb250cm9sIHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBDb250cm9sUmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoQ29udHJvbFJlZmVyZW5jZVR5cGUpIHtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9ERUZBVUxUXCJdID0gXCJDT05UUk9MX1RZUEVfREVGQVVMVFwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0NBTk5ZXCJdID0gXCJDT05UUk9MX1RZUEVfQ0FOTllcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9TQ1JJQkJMRVwiXSA9IFwiQ09OVFJPTF9UWVBFX1NDUklCQkxFXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfRkFDRV9NRVNIXCJdID0gXCJDT05UUk9MX1RZUEVfRkFDRV9NRVNIXCI7XG59KShDb250cm9sUmVmZXJlbmNlVHlwZSB8fCAoQ29udHJvbFJlZmVyZW5jZVR5cGUgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBzdWJqZWN0IHR5cGUgb2YgYSBzdWJqZWN0IHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBTdWJqZWN0UmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoU3ViamVjdFJlZmVyZW5jZVR5cGUpIHtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9ERUZBVUxUXCJdID0gXCJTVUJKRUNUX1RZUEVfREVGQVVMVFwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX1BFUlNPTlwiXSA9IFwiU1VCSkVDVF9UWVBFX1BFUlNPTlwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX0FOSU1BTFwiXSA9IFwiU1VCSkVDVF9UWVBFX0FOSU1BTFwiO1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX1BST0RVQ1RcIl0gPSBcIlNVQkpFQ1RfVFlQRV9QUk9EVUNUXCI7XG59KShTdWJqZWN0UmVmZXJlbmNlVHlwZSB8fCAoU3ViamVjdFJlZmVyZW5jZVR5cGUgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBlZGl0aW5nIG1vZGUuICovXG52YXIgRWRpdE1vZGU7XG4oZnVuY3Rpb24gKEVkaXRNb2RlKSB7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfREVGQVVMVFwiXSA9IFwiRURJVF9NT0RFX0RFRkFVTFRcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9JTlBBSU5UX1JFTU9WQUxcIl0gPSBcIkVESVRfTU9ERV9JTlBBSU5UX1JFTU9WQUxcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9JTlBBSU5UX0lOU0VSVElPTlwiXSA9IFwiRURJVF9NT0RFX0lOUEFJTlRfSU5TRVJUSU9OXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfT1VUUEFJTlRcIl0gPSBcIkVESVRfTU9ERV9PVVRQQUlOVFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0NPTlRST0xMRURfRURJVElOR1wiXSA9IFwiRURJVF9NT0RFX0NPTlRST0xMRURfRURJVElOR1wiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX1NUWUxFXCJdID0gXCJFRElUX01PREVfU1RZTEVcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9CR1NXQVBcIl0gPSBcIkVESVRfTU9ERV9CR1NXQVBcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9QUk9EVUNUX0lNQUdFXCJdID0gXCJFRElUX01PREVfUFJPRFVDVF9JTUFHRVwiO1xufSkoRWRpdE1vZGUgfHwgKEVkaXRNb2RlID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgcmVwcmVzZW50cyB0aGUgc2VnbWVudGF0aW9uIG1vZGUuICovXG52YXIgU2VnbWVudE1vZGU7XG4oZnVuY3Rpb24gKFNlZ21lbnRNb2RlKSB7XG4gICAgU2VnbWVudE1vZGVbXCJGT1JFR1JPVU5EXCJdID0gXCJGT1JFR1JPVU5EXCI7XG4gICAgU2VnbWVudE1vZGVbXCJCQUNLR1JPVU5EXCJdID0gXCJCQUNLR1JPVU5EXCI7XG4gICAgU2VnbWVudE1vZGVbXCJQUk9NUFRcIl0gPSBcIlBST01QVFwiO1xuICAgIFNlZ21lbnRNb2RlW1wiU0VNQU5USUNcIl0gPSBcIlNFTUFOVElDXCI7XG4gICAgU2VnbWVudE1vZGVbXCJJTlRFUkFDVElWRVwiXSA9IFwiSU5URVJBQ1RJVkVcIjtcbn0pKFNlZ21lbnRNb2RlIHx8IChTZWdtZW50TW9kZSA9IHt9KSk7XG4vKiogRW51bSBmb3IgdGhlIHJlZmVyZW5jZSB0eXBlIG9mIGEgdmlkZW8gZ2VuZXJhdGlvbiByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIGltYWdlIHRoYXQgcHJvdmlkZXMgYXNzZXRzIHRvIHRoZSBnZW5lcmF0ZWQgdmlkZW8sXG4gICAgICAgIHN1Y2ggYXMgdGhlIHNjZW5lLCBhbiBvYmplY3QsIGEgY2hhcmFjdGVyLCBldGMuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZVtcIkFTU0VUXCJdID0gXCJBU1NFVFwiO1xuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIGltYWdlIHRoYXQgcHJvdmlkZXMgYWVzdGhldGljcyBpbmNsdWRpbmcgY29sb3JzLFxuICAgICAgICBsaWdodGluZywgdGV4dHVyZSwgZXRjLiwgdG8gYmUgdXNlZCBhcyB0aGUgc3R5bGUgb2YgdGhlIGdlbmVyYXRlZCB2aWRlbyxcbiAgICAgICAgc3VjaCBhcyAnYW5pbWUnLCAncGhvdG9ncmFwaHknLCAnb3JpZ2FtaScsIGV0Yy5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlW1wiU1RZTEVcIl0gPSBcIlNUWUxFXCI7XG59KShWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlIHx8IChWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlID0ge30pKTtcbi8qKiBFbnVtIGZvciB0aGUgbWFzayBtb2RlIG9mIGEgdmlkZW8gZ2VuZXJhdGlvbiBtYXNrLiAqL1xudmFyIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlO1xuKGZ1bmN0aW9uIChWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGNvbnRhaW5zIGEgbWFza2VkIHJlY3Rhbmd1bGFyIHJlZ2lvbiB3aGljaCBpc1xuICAgICAgICBhcHBsaWVkIG9uIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgaW5wdXQgdmlkZW8uIFRoZSBvYmplY3QgZGVzY3JpYmVkIGluXG4gICAgICAgIHRoZSBwcm9tcHQgaXMgaW5zZXJ0ZWQgaW50byB0aGlzIHJlZ2lvbiBhbmQgd2lsbCBhcHBlYXIgaW4gc3Vic2VxdWVudFxuICAgICAgICBmcmFtZXMuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJJTlNFUlRcIl0gPSBcIklOU0VSVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGFuIG9iamVjdCBpbiB0aGVcbiAgICAgICAgZmlyc3QgdmlkZW8gZnJhbWUgdG8gdHJhY2suIFRoaXMgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSB0aGUgdmlkZW8uXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJSRU1PVkVcIl0gPSBcIlJFTU9WRVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGEgcmVnaW9uIGluIHRoZVxuICAgICAgICB2aWRlby4gT2JqZWN0cyBpbiB0aGlzIHJlZ2lvbiB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJSRU1PVkVfU1RBVElDXCJdID0gXCJSRU1PVkVfU1RBVElDXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgY29udGFpbnMgYSBtYXNrZWQgcmVjdGFuZ3VsYXIgcmVnaW9uIHdoZXJlXG4gICAgICAgIHRoZSBpbnB1dCB2aWRlbyB3aWxsIGdvLiBUaGUgcmVtYWluaW5nIGFyZWEgd2lsbCBiZSBnZW5lcmF0ZWQuIFZpZGVvXG4gICAgICAgIG1hc2tzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlW1wiT1VUUEFJTlRcIl0gPSBcIk9VVFBBSU5UXCI7XG59KShWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSB8fCAoVmlkZW9HZW5lcmF0aW9uTWFza01vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgY29tcHJlc3Npb24gcXVhbGl0eSBvZiB0aGUgZ2VuZXJhdGVkIHZpZGVvcy4gKi9cbnZhciBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBPcHRpbWl6ZWQgdmlkZW8gY29tcHJlc3Npb24gcXVhbGl0eS4gVGhpcyB3aWxsIHByb2R1Y2UgdmlkZW9zXG4gICAgICAgIHdpdGggYSBjb21wcmVzc2VkLCBzbWFsbGVyIGZpbGUgc2l6ZS5cbiAgICAgKi9cbiAgICBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eVtcIk9QVElNSVpFRFwiXSA9IFwiT1BUSU1JWkVEXCI7XG4gICAgLyoqXG4gICAgICogTG9zc2xlc3MgdmlkZW8gY29tcHJlc3Npb24gcXVhbGl0eS4gVGhpcyB3aWxsIHByb2R1Y2UgdmlkZW9zXG4gICAgICAgIHdpdGggYSBsYXJnZXIgZmlsZSBzaXplLlxuICAgICAqL1xuICAgIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5W1wiTE9TU0xFU1NcIl0gPSBcIkxPU1NMRVNTXCI7XG59KShWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSB8fCAoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSB0dW5pbmcgbWV0aG9kLiAqL1xudmFyIFR1bmluZ01ldGhvZDtcbihmdW5jdGlvbiAoVHVuaW5nTWV0aG9kKSB7XG4gICAgLyoqXG4gICAgICogU3VwZXJ2aXNlZCBmaW5lIHR1bmluZy5cbiAgICAgKi9cbiAgICBUdW5pbmdNZXRob2RbXCJTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HXCJdID0gXCJTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HXCI7XG4gICAgLyoqXG4gICAgICogUHJlZmVyZW5jZSBvcHRpbWl6YXRpb24gdHVuaW5nLlxuICAgICAqL1xuICAgIFR1bmluZ01ldGhvZFtcIlBSRUZFUkVOQ0VfVFVOSU5HXCJdID0gXCJQUkVGRVJFTkNFX1RVTklOR1wiO1xufSkoVHVuaW5nTWV0aG9kIHx8IChUdW5pbmdNZXRob2QgPSB7fSkpO1xuLyoqIFN0YXRlIGZvciB0aGUgbGlmZWN5Y2xlIG9mIGEgRG9jdW1lbnQuICovXG52YXIgRG9jdW1lbnRTdGF0ZTtcbihmdW5jdGlvbiAoRG9jdW1lbnRTdGF0ZSkge1xuICAgIERvY3VtZW50U3RhdGVbXCJTVEFURV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBVEVfVU5TUEVDSUZJRURcIjtcbiAgICBEb2N1bWVudFN0YXRlW1wiU1RBVEVfUEVORElOR1wiXSA9IFwiU1RBVEVfUEVORElOR1wiO1xuICAgIERvY3VtZW50U3RhdGVbXCJTVEFURV9BQ1RJVkVcIl0gPSBcIlNUQVRFX0FDVElWRVwiO1xuICAgIERvY3VtZW50U3RhdGVbXCJTVEFURV9GQUlMRURcIl0gPSBcIlNUQVRFX0ZBSUxFRFwiO1xufSkoRG9jdW1lbnRTdGF0ZSB8fCAoRG9jdW1lbnRTdGF0ZSA9IHt9KSk7XG4vKiogU3RhdGUgZm9yIHRoZSBsaWZlY3ljbGUgb2YgYSBGaWxlLiAqL1xudmFyIEZpbGVTdGF0ZTtcbihmdW5jdGlvbiAoRmlsZVN0YXRlKSB7XG4gICAgRmlsZVN0YXRlW1wiU1RBVEVfVU5TUEVDSUZJRURcIl0gPSBcIlNUQVRFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRmlsZVN0YXRlW1wiUFJPQ0VTU0lOR1wiXSA9IFwiUFJPQ0VTU0lOR1wiO1xuICAgIEZpbGVTdGF0ZVtcIkFDVElWRVwiXSA9IFwiQUNUSVZFXCI7XG4gICAgRmlsZVN0YXRlW1wiRkFJTEVEXCJdID0gXCJGQUlMRURcIjtcbn0pKEZpbGVTdGF0ZSB8fCAoRmlsZVN0YXRlID0ge30pKTtcbi8qKiBTb3VyY2Ugb2YgdGhlIEZpbGUuICovXG52YXIgRmlsZVNvdXJjZTtcbihmdW5jdGlvbiAoRmlsZVNvdXJjZSkge1xuICAgIEZpbGVTb3VyY2VbXCJTT1VSQ0VfVU5TUEVDSUZJRURcIl0gPSBcIlNPVVJDRV9VTlNQRUNJRklFRFwiO1xuICAgIEZpbGVTb3VyY2VbXCJVUExPQURFRFwiXSA9IFwiVVBMT0FERURcIjtcbiAgICBGaWxlU291cmNlW1wiR0VORVJBVEVEXCJdID0gXCJHRU5FUkFURURcIjtcbiAgICBGaWxlU291cmNlW1wiUkVHSVNURVJFRFwiXSA9IFwiUkVHSVNURVJFRFwiO1xufSkoRmlsZVNvdXJjZSB8fCAoRmlsZVNvdXJjZSA9IHt9KSk7XG4vKiogVGhlIHJlYXNvbiB3aHkgdGhlIHR1cm4gaXMgY29tcGxldGUuICovXG52YXIgVHVybkNvbXBsZXRlUmVhc29uO1xuKGZ1bmN0aW9uIChUdXJuQ29tcGxldGVSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBSZWFzb24gaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiVFVSTl9DT01QTEVURV9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIlRVUk5fQ09NUExFVEVfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbGwgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCJdID0gXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXNwb25zZSBpcyByZWplY3RlZCBieSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiUkVTUE9OU0VfUkVKRUNURURcIl0gPSBcIlJFU1BPTlNFX1JFSkVDVEVEXCI7XG4gICAgLyoqXG4gICAgICogTmVlZHMgbW9yZSBpbnB1dCBmcm9tIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIk5FRURfTU9SRV9JTlBVVFwiXSA9IFwiTkVFRF9NT1JFX0lOUFVUXCI7XG59KShUdXJuQ29tcGxldGVSZWFzb24gfHwgKFR1cm5Db21wbGV0ZVJlYXNvbiA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNZWRpYU1vZGFsaXR5O1xuKGZ1bmN0aW9uIChNZWRpYU1vZGFsaXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGFsaXR5IGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJURVhUXCJdID0gXCJURVhUXCI7XG4gICAgLyoqXG4gICAgICogSW1hZ2VzLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBWaWRlby5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiVklERU9cIl0gPSBcIlZJREVPXCI7XG4gICAgLyoqXG4gICAgICogQXVkaW8uXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIkFVRElPXCJdID0gXCJBVURJT1wiO1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50LCBlLmcuIFBERi5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiRE9DVU1FTlRcIl0gPSBcIkRPQ1VNRU5UXCI7XG59KShNZWRpYU1vZGFsaXR5IHx8IChNZWRpYU1vZGFsaXR5ID0ge30pKTtcbi8qKiBUaGUgdHlwZSBvZiB0aGUgVkFEIHNpZ25hbC4gKi9cbnZhciBWYWRTaWduYWxUeXBlO1xuKGZ1bmN0aW9uIChWYWRTaWduYWxUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgVkFEX1NJR05BTF9UWVBFX1VOU1BFQ0lGSUVELlxuICAgICAqL1xuICAgIFZhZFNpZ25hbFR5cGVbXCJWQURfU0lHTkFMX1RZUEVfVU5TUEVDSUZJRURcIl0gPSBcIlZBRF9TSUdOQUxfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIHNlbnRlbmNlIHNpZ25hbC5cbiAgICAgKi9cbiAgICBWYWRTaWduYWxUeXBlW1wiVkFEX1NJR05BTF9UWVBFX1NPU1wiXSA9IFwiVkFEX1NJR05BTF9UWVBFX1NPU1wiO1xuICAgIC8qKlxuICAgICAqIEVuZCBvZiBzZW50ZW5jZSBzaWduYWwuXG4gICAgICovXG4gICAgVmFkU2lnbmFsVHlwZVtcIlZBRF9TSUdOQUxfVFlQRV9FT1NcIl0gPSBcIlZBRF9TSUdOQUxfVFlQRV9FT1NcIjtcbn0pKFZhZFNpZ25hbFR5cGUgfHwgKFZhZFNpZ25hbFR5cGUgPSB7fSkpO1xuLyoqIFN0YXJ0IG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbnZhciBTdGFydFNlbnNpdGl2aXR5O1xuKGZ1bmN0aW9uIChTdGFydFNlbnNpdGl2aXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgU1RBUlRfU0VOU0lUSVZJVFlfTE9XLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBvZiBzcGVlY2ggbW9yZSBvZnRlbi5cbiAgICAgKi9cbiAgICBTdGFydFNlbnNpdGl2aXR5W1wiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IG9mIHNwZWVjaCBsZXNzIG9mdGVuLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9MT1dcIl0gPSBcIlNUQVJUX1NFTlNJVElWSVRZX0xPV1wiO1xufSkoU3RhcnRTZW5zaXRpdml0eSB8fCAoU3RhcnRTZW5zaXRpdml0eSA9IHt9KSk7XG4vKiogRW5kIG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbnZhciBFbmRTZW5zaXRpdml0eTtcbihmdW5jdGlvbiAoRW5kU2Vuc2l0aXZpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBFTkRfU0VOU0lUSVZJVFlfTE9XLlxuICAgICAqL1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIGVuZHMgc3BlZWNoIG1vcmUgb2Z0ZW4uXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiRU5EX1NFTlNJVElWSVRZX0hJR0hcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIGVuZHMgc3BlZWNoIGxlc3Mgb2Z0ZW4uXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfTE9XXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfTE9XXCI7XG59KShFbmRTZW5zaXRpdml0eSB8fCAoRW5kU2Vuc2l0aXZpdHkgPSB7fSkpO1xuLyoqIFRoZSBkaWZmZXJlbnQgd2F5cyBvZiBoYW5kbGluZyB1c2VyIGFjdGl2aXR5LiAqL1xudmFyIEFjdGl2aXR5SGFuZGxpbmc7XG4oZnVuY3Rpb24gKEFjdGl2aXR5SGFuZGxpbmcpIHtcbiAgICAvKipcbiAgICAgKiBJZiB1bnNwZWNpZmllZCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgYFNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNgLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJBQ1RJVklUWV9IQU5ETElOR19VTlNQRUNJRklFRFwiXSA9IFwiQUNUSVZJVFlfSEFORExJTkdfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdGFydCBvZiBhY3Rpdml0eSB3aWxsIGludGVycnVwdCB0aGUgbW9kZWwncyByZXNwb25zZSAoYWxzbyBjYWxsZWQgXCJiYXJnZSBpblwiKS4gVGhlIG1vZGVsJ3MgY3VycmVudCByZXNwb25zZSB3aWxsIGJlIGN1dC1vZmYgaW4gdGhlIG1vbWVudCBvZiB0aGUgaW50ZXJydXB0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTXCJdID0gXCJTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTXCI7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsJ3MgcmVzcG9uc2Ugd2lsbCBub3QgYmUgaW50ZXJydXB0ZWQuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIk5PX0lOVEVSUlVQVElPTlwiXSA9IFwiTk9fSU5URVJSVVBUSU9OXCI7XG59KShBY3Rpdml0eUhhbmRsaW5nIHx8IChBY3Rpdml0eUhhbmRsaW5nID0ge30pKTtcbi8qKiBPcHRpb25zIGFib3V0IHdoaWNoIGlucHV0IGlzIGluY2x1ZGVkIGluIHRoZSB1c2VyJ3MgdHVybi4gKi9cbnZhciBUdXJuQ292ZXJhZ2U7XG4oZnVuY3Rpb24gKFR1cm5Db3ZlcmFnZSkge1xuICAgIC8qKlxuICAgICAqIElmIHVuc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBgVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZYC5cbiAgICAgKi9cbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHR1cm4gb25seSBpbmNsdWRlcyBhY3Rpdml0eSBzaW5jZSB0aGUgbGFzdCB0dXJuLCBleGNsdWRpbmcgaW5hY3Rpdml0eSAoZS5nLiBzaWxlbmNlIG9uIHRoZSBhdWRpbyBzdHJlYW0pLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIFR1cm5Db3ZlcmFnZVtcIlRVUk5fSU5DTFVERVNfT05MWV9BQ1RJVklUWVwiXSA9IFwiVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHR1cm4gaW5jbHVkZXMgYWxsIHJlYWx0aW1lIGlucHV0IHNpbmNlIHRoZSBsYXN0IHR1cm4sIGluY2x1ZGluZyBpbmFjdGl2aXR5IChlLmcuIHNpbGVuY2Ugb24gdGhlIGF1ZGlvIHN0cmVhbSkuXG4gICAgICovXG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9JTkNMVURFU19BTExfSU5QVVRcIl0gPSBcIlRVUk5fSU5DTFVERVNfQUxMX0lOUFVUXCI7XG59KShUdXJuQ292ZXJhZ2UgfHwgKFR1cm5Db3ZlcmFnZSA9IHt9KSk7XG4vKiogU2NhbGUgb2YgdGhlIGdlbmVyYXRlZCBtdXNpYy4gKi9cbnZhciBTY2FsZTtcbihmdW5jdGlvbiAoU2NhbGUpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBTY2FsZVtcIlNDQUxFX1VOU1BFQ0lGSUVEXCJdID0gXCJTQ0FMRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEMgbWFqb3Igb3IgQSBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkNfTUFKT1JfQV9NSU5PUlwiXSA9IFwiQ19NQUpPUl9BX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRGIgbWFqb3Igb3IgQmIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJEX0ZMQVRfTUFKT1JfQl9GTEFUX01JTk9SXCJdID0gXCJEX0ZMQVRfTUFKT1JfQl9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRCBtYWpvciBvciBCIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRF9NQUpPUl9CX01JTk9SXCJdID0gXCJEX01BSk9SX0JfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBFYiBtYWpvciBvciBDIG1pbm9yXG4gICAgICovXG4gICAgU2NhbGVbXCJFX0ZMQVRfTUFKT1JfQ19NSU5PUlwiXSA9IFwiRV9GTEFUX01BSk9SX0NfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBFIG1ham9yIG9yIERiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRV9NQUpPUl9EX0ZMQVRfTUlOT1JcIl0gPSBcIkVfTUFKT1JfRF9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRiBtYWpvciBvciBEIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRl9NQUpPUl9EX01JTk9SXCJdID0gXCJGX01BSk9SX0RfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBHYiBtYWpvciBvciBFYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkdfRkxBVF9NQUpPUl9FX0ZMQVRfTUlOT1JcIl0gPSBcIkdfRkxBVF9NQUpPUl9FX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBHIG1ham9yIG9yIEUgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJHX01BSk9SX0VfTUlOT1JcIl0gPSBcIkdfTUFKT1JfRV9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEFiIG1ham9yIG9yIEYgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJBX0ZMQVRfTUFKT1JfRl9NSU5PUlwiXSA9IFwiQV9GTEFUX01BSk9SX0ZfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBBIG1ham9yIG9yIEdiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQV9NQUpPUl9HX0ZMQVRfTUlOT1JcIl0gPSBcIkFfTUFKT1JfR19GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQmIgbWFqb3Igb3IgRyBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkJfRkxBVF9NQUpPUl9HX01JTk9SXCJdID0gXCJCX0ZMQVRfTUFKT1JfR19NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEIgbWFqb3Igb3IgQWIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJCX01BSk9SX0FfRkxBVF9NSU5PUlwiXSA9IFwiQl9NQUpPUl9BX0ZMQVRfTUlOT1JcIjtcbn0pKFNjYWxlIHx8IChTY2FsZSA9IHt9KSk7XG4vKiogVGhlIG1vZGUgb2YgbXVzaWMgZ2VuZXJhdGlvbi4gKi9cbnZhciBNdXNpY0dlbmVyYXRpb25Nb2RlO1xuKGZ1bmN0aW9uIChNdXNpY0dlbmVyYXRpb25Nb2RlKSB7XG4gICAgLyoqXG4gICAgICogUmVseSBvbiB0aGUgc2VydmVyIGRlZmF1bHQgZ2VuZXJhdGlvbiBtb2RlLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJNVVNJQ19HRU5FUkFUSU9OX01PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1VU0lDX0dFTkVSQVRJT05fTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFN0ZWVyIHRleHQgcHJvbXB0cyB0byByZWdpb25zIG9mIGxhdGVudCBzcGFjZSB3aXRoIGhpZ2hlciBxdWFsaXR5XG4gICAgICAgIG11c2ljLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJRVUFMSVRZXCJdID0gXCJRVUFMSVRZXCI7XG4gICAgLyoqXG4gICAgICogU3RlZXIgdGV4dCBwcm9tcHRzIHRvIHJlZ2lvbnMgb2YgbGF0ZW50IHNwYWNlIHdpdGggYSBsYXJnZXJcbiAgICAgICAgZGl2ZXJzaXR5IG9mIG11c2ljLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJESVZFUlNJVFlcIl0gPSBcIkRJVkVSU0lUWVwiO1xuICAgIC8qKlxuICAgICAqIFN0ZWVyIHRleHQgcHJvbXB0cyB0byByZWdpb25zIG9mIGxhdGVudCBzcGFjZSBtb3JlIGxpa2VseSB0b1xuICAgICAgICBnZW5lcmF0ZSBtdXNpYyB3aXRoIHZvY2Fscy5cbiAgICAgKi9cbiAgICBNdXNpY0dlbmVyYXRpb25Nb2RlW1wiVk9DQUxJWkFUSU9OXCJdID0gXCJWT0NBTElaQVRJT05cIjtcbn0pKE11c2ljR2VuZXJhdGlvbk1vZGUgfHwgKE11c2ljR2VuZXJhdGlvbk1vZGUgPSB7fSkpO1xuLyoqIFRoZSBwbGF5YmFjayBjb250cm9sIHNpZ25hbCB0byBhcHBseSB0byB0aGUgbXVzaWMgZ2VuZXJhdGlvbi4gKi9cbnZhciBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2w7XG4oZnVuY3Rpb24gKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlBMQVlCQUNLX0NPTlRST0xfVU5TUEVDSUZJRURcIl0gPSBcIlBMQVlCQUNLX0NPTlRST0xfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTdGFydCBnZW5lcmF0aW5nIHRoZSBtdXNpYy5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJQTEFZXCJdID0gXCJQTEFZXCI7XG4gICAgLyoqXG4gICAgICogSG9sZCB0aGUgbXVzaWMgZ2VuZXJhdGlvbi4gVXNlIFBMQVkgdG8gcmVzdW1lIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUEFVU0VcIl0gPSBcIlBBVVNFXCI7XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbXVzaWMgZ2VuZXJhdGlvbiBhbmQgcmVzZXQgdGhlIGNvbnRleHQgKHByb21wdHMgcmV0YWluZWQpLlxuICAgICAgICBVc2UgUExBWSB0byByZXN0YXJ0IHRoZSBtdXNpYyBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlNUT1BcIl0gPSBcIlNUT1BcIjtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY29udGV4dCBvZiB0aGUgbXVzaWMgZ2VuZXJhdGlvbiB3aXRob3V0IHN0b3BwaW5nIGl0LlxuICAgICAgICBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHMgYW5kIGNvbmZpZy5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJSRVNFVF9DT05URVhUXCJdID0gXCJSRVNFVF9DT05URVhUXCI7XG59KShMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wgfHwgKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCA9IHt9KSk7XG4vKiogUmF3IG1lZGlhIGJ5dGVzIGZvciBmdW5jdGlvbiByZXNwb25zZS5cblxuVGV4dCBzaG91bGQgbm90IGJlIHNlbnQgYXMgcmF3IGJ5dGVzLCB1c2UgdGhlIEZ1bmN0aW9uUmVzcG9uc2UucmVzcG9uc2VcbmZpZWxkLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZUJsb2Ige1xufVxuLyoqIFVSSSBiYXNlZCBkYXRhIGZvciBmdW5jdGlvbiByZXNwb25zZS4gKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2VGaWxlRGF0YSB7XG59XG4vKiogQSBkYXRhdHlwZSBjb250YWluaW5nIG1lZGlhIHRoYXQgaXMgcGFydCBvZiBhIGBGdW5jdGlvblJlc3BvbnNlYCBtZXNzYWdlLlxuXG5BIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgY29uc2lzdHMgb2YgZGF0YSB3aGljaCBoYXMgYW4gYXNzb2NpYXRlZCBkYXRhdHlwZS4gQVxuYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBjYW4gb25seSBjb250YWluIG9uZSBvZiB0aGUgYWNjZXB0ZWQgdHlwZXMgaW5cbmBGdW5jdGlvblJlc3BvbnNlUGFydC5kYXRhYC5cblxuQSBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIG11c3QgaGF2ZSBhIGZpeGVkIElBTkEgTUlNRSB0eXBlIGlkZW50aWZ5aW5nIHRoZVxudHlwZSBhbmQgc3VidHlwZSBvZiB0aGUgbWVkaWEgaWYgdGhlIGBpbmxpbmVfZGF0YWAgZmllbGQgaXMgZmlsbGVkIHdpdGggcmF3XG5ieXRlcy4gKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2VQYXJ0IHtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgb2JqZWN0IGZyb20gYSBgYmFzZTY0YCBlbmNvZGVkIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21CYXNlNjQoZGF0YSwgbWltZVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmxpbmVEYXRhOiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIG9iamVjdCBmcm9tIGEgYFVSSWAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21VcmkodXJpLCBtaW1lVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVEYXRhOiB7XG4gICAgICAgICAgICBmaWxlVXJpOiB1cmksXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKiBBIGZ1bmN0aW9uIHJlc3BvbnNlLiAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZSB7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgVVJJYCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tVXJpKHVyaSwgbWltZVR5cGUsIG1lZGlhUmVzb2x1dGlvbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgZmlsZURhdGE6IHtcbiAgICAgICAgICAgIGZpbGVVcmk6IHVyaSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSB9LCAobWVkaWFSZXNvbHV0aW9uICYmIHsgbWVkaWFSZXNvbHV0aW9uOiB7IGxldmVsOiBtZWRpYVJlc29sdXRpb24gfSB9KSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgdGV4dGAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbVRleHQodGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBGdW5jdGlvbkNhbGxgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwobmFtZSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZ1bmN0aW9uQ2FsbDoge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBGdW5jdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZShpZCwgbmFtZSwgcmVzcG9uc2UsIHBhcnRzID0gW10pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmdW5jdGlvblJlc3BvbnNlOiBPYmplY3QuYXNzaWduKHsgaWQ6IGlkLCBuYW1lOiBuYW1lLCByZXNwb25zZTogcmVzcG9uc2UgfSwgKHBhcnRzLmxlbmd0aCA+IDAgJiYgeyBwYXJ0cyB9KSksXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBiYXNlNjRgIGVuY29kZWQgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tQmFzZTY0KGRhdGEsIG1pbWVUeXBlLCBtZWRpYVJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGlubGluZURhdGE6IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0gfSwgKG1lZGlhUmVzb2x1dGlvbiAmJiB7IG1lZGlhUmVzb2x1dGlvbjogeyBsZXZlbDogbWVkaWFSZXNvbHV0aW9uIH0gfSkpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIHRoZSBgb3V0Y29tZWAgYW5kIGBvdXRwdXRgIG9mIGEgYENvZGVFeGVjdXRpb25SZXN1bHRgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KG91dGNvbWUsIG91dHB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVFeGVjdXRpb25SZXN1bHQ6IHtcbiAgICAgICAgICAgIG91dGNvbWU6IG91dGNvbWUsXG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIHRoZSBgY29kZWAgYW5kIGBsYW5ndWFnZWAgb2YgYW4gYEV4ZWN1dGFibGVDb2RlYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRXhlY3V0YWJsZUNvZGUoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBleGVjdXRhYmxlQ29kZToge1xuICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gX2lzUGFydChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAoJ2ZpbGVEYXRhJyBpbiBvYmogfHxcbiAgICAgICAgICAgICd0ZXh0JyBpbiBvYmogfHxcbiAgICAgICAgICAgICdmdW5jdGlvbkNhbGwnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2lubGluZURhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyBpbiBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGlmICh0eXBlb2YgcGFydE9yU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJ0cy5wdXNoKGNyZWF0ZVBhcnRGcm9tVGV4dChwYXJ0T3JTdHJpbmcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzUGFydChwYXJ0T3JTdHJpbmcpKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGFydE9yU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJ0T3JTdHJpbmcpKSB7XG4gICAgICAgIGlmIChwYXJ0T3JTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRPclN0cmluZyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydE9yU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChjcmVhdGVQYXJ0RnJvbVRleHQocGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2lzUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgaW4gUGFydFVuaW9uIG11c3QgYmUgYSBQYXJ0IG9iamVjdCBvciBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0T3JTdHJpbmcgbXVzdCBiZSBhIFBhcnQgb2JqZWN0LCBzdHJpbmcsIG9yIGFycmF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBDb250ZW50YCBvYmplY3Qgd2l0aCBhIHVzZXIgcm9sZSBmcm9tIGEgYFBhcnRMaXN0VW5pb25gIG9iamVjdCBvciBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXNlckNvbnRlbnQocGFydE9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBwYXJ0czogX3RvUGFydHMocGFydE9yU3RyaW5nKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYENvbnRlbnRgIG9iamVjdCB3aXRoIGEgbW9kZWwgcm9sZSBmcm9tIGEgYFBhcnRMaXN0VW5pb25gIG9iamVjdCBvciBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kZWxDb250ZW50KHBhcnRPclN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICdtb2RlbCcsXG4gICAgICAgIHBhcnRzOiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpLFxuICAgIH07XG59XG4vKiogQSB3cmFwcGVyIGNsYXNzIGZvciB0aGUgaHR0cCByZXNwb25zZS4gKi9cbmNsYXNzIEh0dHBSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgaGVhZGVycy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIHJlc3BvbnNlLlxuICAgICAgICB0aGlzLnJlc3BvbnNlSW50ZXJuYWwgPSByZXNwb25zZTtcbiAgICB9XG4gICAganNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VJbnRlcm5hbC5qc29uKCk7XG4gICAgfVxufVxuLyoqIENvbnRlbnQgZmlsdGVyIHJlc3VsdHMgZm9yIGEgcHJvbXB0IHNlbnQgaW4gdGhlIHJlcXVlc3QuIE5vdGU6IFRoaXMgaXMgc2VudCBvbmx5IGluIHRoZSBmaXJzdCBzdHJlYW0gY2h1bmsgYW5kIG9ubHkgaWYgbm8gY2FuZGlkYXRlcyB3ZXJlIGdlbmVyYXRlZCBkdWUgdG8gY29udGVudCB2aW9sYXRpb25zLiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VQcm9tcHRGZWVkYmFjayB7XG59XG4vKiogVXNhZ2UgbWV0YWRhdGEgYWJvdXQgdGhlIGNvbnRlbnQgZ2VuZXJhdGlvbiByZXF1ZXN0IGFuZCByZXNwb25zZS4gVGhpcyBtZXNzYWdlIHByb3ZpZGVzIGEgZGV0YWlsZWQgYnJlYWtkb3duIG9mIHRva2VuIHVzYWdlIGFuZCBvdGhlciByZWxldmFudCBtZXRyaWNzLiBUaGlzIGRhdGEgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG5jbGFzcyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVVzYWdlTWV0YWRhdGEge1xufVxuLyoqIFJlc3BvbnNlIG1lc3NhZ2UgZm9yIFByZWRpY3Rpb25TZXJ2aWNlLkdlbmVyYXRlQ29udGVudC4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIHRleHQgZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm9uLXRleHQgcGFydHMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dFxuICAgICAqIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZCBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIHRob3VnaHQgcGFydHMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dFxuICAgICAqIHBhcnRzIGV4Y2x1ZGluZyB0aGUgdGhvdWdodCBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLnRleHQpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIHRleHQgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGxldCBhbnlUZXh0UGFydFRleHQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9uVGV4dFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAndGV4dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodFNpZ25hdHVyZScgJiZcbiAgICAgICAgICAgICAgICAgICAgKGZpZWxkVmFsdWUgIT09IG51bGwgfHwgZmllbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBub25UZXh0UGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50aG91Z2h0ID09PSAnYm9vbGVhbicgJiYgcGFydC50aG91Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlUZXh0UGFydFRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25UZXh0UGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLXRleHQgcGFydHMgJHtub25UZXh0UGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIHRleHQgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnQudGV4dCA9PT0gJycgaXMgZGlmZmVyZW50IGZyb20gcGFydC50ZXh0IGlzIG51bGxcbiAgICAgICAgcmV0dXJuIGFueVRleHRQYXJ0VGV4dCA/IHRleHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZVxuICAgICAqIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgaW5saW5lIGRhdGEgZnJvbSB0aGVcbiAgICAgKiBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhlcmUgYXJlIG5vbi1pbmxpbmUgZGF0YSBwYXJ0cyBpbiB0aGVcbiAgICAgKiByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZFxuICAgICAqIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBkYXRhIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgICBjb25zdCBub25EYXRhUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICdpbmxpbmVEYXRhJyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGRWYWx1ZSAhPT0gbnVsbCB8fCBmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbkRhdGFQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnQuaW5saW5lRGF0YSAmJiB0eXBlb2YgcGFydC5pbmxpbmVEYXRhLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSArPSBhdG9iKHBhcnQuaW5saW5lRGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRGF0YVBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi1kYXRhIHBhcnRzICR7bm9uRGF0YVBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCBkYXRhIHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiBkYXRhIHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gYnRvYShkYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZnVuY3Rpb24gY2FsbHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgZnVuY3Rpb24gY2FsbHMgZnJvbVxuICAgICAqIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZnVuY3Rpb24gY2FsbHMgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb250cm9sTGlnaHRGdW5jdGlvbkRlY2xhcmF0aW9uOiBGdW5jdGlvbkRlY2xhcmF0aW9uID0ge1xuICAgICAqICAgbmFtZTogJ2NvbnRyb2xMaWdodCcsXG4gICAgICogICBwYXJhbWV0ZXJzOiB7XG4gICAgICogICB0eXBlOiBUeXBlLk9CSkVDVCxcbiAgICAgKiAgIGRlc2NyaXB0aW9uOiAnU2V0IHRoZSBicmlnaHRuZXNzIGFuZCBjb2xvciB0ZW1wZXJhdHVyZSBvZiBhIHJvb20gbGlnaHQuJyxcbiAgICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICAgKiAgICAgYnJpZ2h0bmVzczoge1xuICAgICAqICAgICAgIHR5cGU6IFR5cGUuTlVNQkVSLFxuICAgICAqICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAqICAgICAgICAgJ0xpZ2h0IGxldmVsIGZyb20gMCB0byAxMDAuIFplcm8gaXMgb2ZmIGFuZCAxMDAgaXMgZnVsbCBicmlnaHRuZXNzLicsXG4gICAgICogICAgIH0sXG4gICAgICogICAgIGNvbG9yVGVtcGVyYXR1cmU6IHtcbiAgICAgKiAgICAgICB0eXBlOiBUeXBlLlNUUklORyxcbiAgICAgKiAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgKiAgICAgICAgICdDb2xvciB0ZW1wZXJhdHVyZSBvZiB0aGUgbGlnaHQgZml4dHVyZSB3aGljaCBjYW4gYmUgYGRheWxpZ2h0YCwgYGNvb2xgIG9yIGB3YXJtYC4nLFxuICAgICAqICAgICB9LFxuICAgICAqICAgfSxcbiAgICAgKiAgIHJlcXVpcmVkOiBbJ2JyaWdodG5lc3MnLCAnY29sb3JUZW1wZXJhdHVyZSddLFxuICAgICAqICB9O1xuICAgICAqICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgICBjb250ZW50czogJ0RpbSB0aGUgbGlnaHRzIHNvIHRoZSByb29tIGZlZWxzIGNvenkgYW5kIHdhcm0uJyxcbiAgICAgKiAgICAgY29uZmlnOiB7XG4gICAgICogICAgICAgdG9vbHM6IFt7ZnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtjb250cm9sTGlnaHRGdW5jdGlvbkRlY2xhcmF0aW9uXX1dLFxuICAgICAqICAgICAgIHRvb2xDb25maWc6IHtcbiAgICAgKiAgICAgICAgIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZzoge1xuICAgICAqICAgICAgICAgICBtb2RlOiBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlLkFOWSxcbiAgICAgKiAgICAgICAgICAgYWxsb3dlZEZ1bmN0aW9uTmFtZXM6IFsnY29udHJvbExpZ2h0J10sXG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgIH0sXG4gICAgICogICB9KTtcbiAgICAgKiAgY29uc29sZS5kZWJ1ZyhKU09OLnN0cmluZ2lmeShyZXNwb25zZS5mdW5jdGlvbkNhbGxzKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGZ1bmN0aW9uQ2FsbHMoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZnVuY3Rpb24gY2FsbHMgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbHMgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5mdW5jdGlvbkNhbGwpLm1hcCgocGFydCkgPT4gcGFydC5mdW5jdGlvbkNhbGwpLmZpbHRlcigoZnVuY3Rpb25DYWxsKSA9PiBmdW5jdGlvbkNhbGwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoZnVuY3Rpb25DYWxscyA9PT0gbnVsbCB8fCBmdW5jdGlvbkNhbGxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmdW5jdGlvbkNhbGxzLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGV4ZWN1dGFibGUgY29kZSBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBleGVjdXRhYmxlIGNvZGUgZnJvbVxuICAgICAqIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gZXhlY3V0YWJsZSBjb2RlIGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgIGNvbnRlbnRzOlxuICAgICAqICAgICAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSBmaXJzdCA1MCBwcmltZSBudW1iZXJzPyBHZW5lcmF0ZSBhbmQgcnVuIGNvZGUgZm9yIHRoZSBjYWxjdWxhdGlvbiwgYW5kIG1ha2Ugc3VyZSB5b3UgZ2V0IGFsbCA1MC4nXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdG9vbHM6IFt7Y29kZUV4ZWN1dGlvbjoge319XSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLmV4ZWN1dGFibGVDb2RlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZXhlY3V0YWJsZUNvZGUoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGV4ZWN1dGFibGUgY29kZSBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhlY3V0YWJsZUNvZGUgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5leGVjdXRhYmxlQ29kZSkubWFwKChwYXJ0KSA9PiBwYXJ0LmV4ZWN1dGFibGVDb2RlKS5maWx0ZXIoKGV4ZWN1dGFibGVDb2RlKSA9PiBleGVjdXRhYmxlQ29kZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChleGVjdXRhYmxlQ29kZSA9PT0gbnVsbCB8fCBleGVjdXRhYmxlQ29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhlY3V0YWJsZUNvZGUubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9qID0gZXhlY3V0YWJsZUNvZGUgPT09IG51bGwgfHwgZXhlY3V0YWJsZUNvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4ZWN1dGFibGVDb2RlWzBdKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouY29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgIGNvbnRlbnRzOlxuICAgICAqICAgICAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSBmaXJzdCA1MCBwcmltZSBudW1iZXJzPyBHZW5lcmF0ZSBhbmQgcnVuIGNvZGUgZm9yIHRoZSBjYWxjdWxhdGlvbiwgYW5kIG1ha2Ugc3VyZSB5b3UgZ2V0IGFsbCA1MC4nXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdG9vbHM6IFt7Y29kZUV4ZWN1dGlvbjoge319XSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmRlYnVnKHJlc3BvbnNlLmNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBjb2RlRXhlY3V0aW9uUmVzdWx0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVFeGVjdXRpb25SZXN1bHQgPSAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmZpbHRlcigocGFydCkgPT4gcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KS5tYXAoKHBhcnQpID0+IHBhcnQuY29kZUV4ZWN1dGlvblJlc3VsdCkuZmlsdGVyKChjb2RlRXhlY3V0aW9uUmVzdWx0KSA9PiBjb2RlRXhlY3V0aW9uUmVzdWx0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IG51bGwgfHwgY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29kZUV4ZWN1dGlvblJlc3VsdC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2ogPSBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSBudWxsIHx8IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvZGVFeGVjdXRpb25SZXN1bHRbMF0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5vdXRwdXQ7XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgZW1iZWRfY29udGVudCBtZXRob2QuICovXG5jbGFzcyBFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogVGhlIG91dHB1dCBpbWFnZXMgcmVzcG9uc2UuICovXG5jbGFzcyBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIHJlcXVlc3QgdG8gZWRpdCBhbiBpbWFnZS4gKi9cbmNsYXNzIEVkaXRJbWFnZVJlc3BvbnNlIHtcbn1cbmNsYXNzIFVwc2NhbGVJbWFnZVJlc3BvbnNlIHtcbn1cbi8qKiBUaGUgb3V0cHV0IGltYWdlcyByZXNwb25zZS4gKi9cbmNsYXNzIFJlY29udGV4dEltYWdlUmVzcG9uc2Uge1xufVxuLyoqIFRoZSBvdXRwdXQgaW1hZ2VzIHJlc3BvbnNlLiAqL1xuY2xhc3MgU2VnbWVudEltYWdlUmVzcG9uc2Uge1xufVxuY2xhc3MgTGlzdE1vZGVsc1Jlc3BvbnNlIHtcbn1cbmNsYXNzIERlbGV0ZU1vZGVsUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBjb3VudGluZyB0b2tlbnMuICovXG5jbGFzcyBDb3VudFRva2Vuc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgY29tcHV0aW5nIHRva2Vucy4gKi9cbmNsYXNzIENvbXB1dGVUb2tlbnNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2Ugd2l0aCBnZW5lcmF0ZWQgdmlkZW9zLiAqL1xuY2xhc3MgR2VuZXJhdGVWaWRlb3NSZXNwb25zZSB7XG59XG4vKiogQSB2aWRlbyBnZW5lcmF0aW9uIG9wZXJhdGlvbi4gKi9cbmNsYXNzIEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gT3BlcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIG9uZSBiZWluZyBjYWxsZWQgd2l0aCB0aGUgZmllbGRzIHNldCBmcm9tIHRoZSBBUEkgcmVzcG9uc2UuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2Zyb21BUElSZXNwb25zZSh7IGFwaVJlc3BvbnNlLCBfaXNWZXJ0ZXhBSSwgfSkge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBuZXcgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24oKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBjb25zdCBvcCA9IGFwaVJlc3BvbnNlO1xuICAgICAgICBpZiAoX2lzVmVydGV4QUkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4JDEob3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxKG9wKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKG9wZXJhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgdHVuaW5nIGpvYnMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSB7XG59XG4vKiogRW1wdHkgcmVzcG9uc2UgZm9yIHR1bmluZ3MuY2FuY2VsIG1ldGhvZC4gKi9cbmNsYXNzIENhbmNlbFR1bmluZ0pvYlJlc3BvbnNlIHtcbn1cbi8qKiBFbXB0eSByZXNwb25zZSBmb3IgY2FjaGVzLmRlbGV0ZSBtZXRob2QuICovXG5jbGFzcyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2Uge1xufVxuY2xhc3MgTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgZG9jdW1lbnRzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdERvY3VtZW50c1Jlc3BvbnNlIHtcbn1cbi8qKiBDb25maWcgZm9yIGZpbGVfc2VhcmNoX3N0b3Jlcy5saXN0IHJldHVybiB2YWx1ZS4gKi9cbmNsYXNzIExpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgcmVzdW1hYmxlIHVwbG9hZCBtZXRob2QuICovXG5jbGFzcyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3VtYWJsZVJlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgSW1wb3J0RmlsZSB0byBpbXBvcnQgYSBGaWxlIEFQSSBmaWxlIHdpdGggYSBmaWxlIHNlYXJjaCBzdG9yZS4gKi9cbmNsYXNzIEltcG9ydEZpbGVSZXNwb25zZSB7XG59XG4vKiogTG9uZy1ydW5uaW5nIG9wZXJhdGlvbiBmb3IgaW1wb3J0aW5nIGEgZmlsZSB0byBhIEZpbGVTZWFyY2hTdG9yZS4gKi9cbmNsYXNzIEltcG9ydEZpbGVPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBPcGVyYXRpb24gb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgb25lIGJlaW5nIGNhbGxlZCB3aXRoIHRoZSBmaWVsZHMgc2V0IGZyb20gdGhlIEFQSSByZXNwb25zZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZnJvbUFQSVJlc3BvbnNlKHsgYXBpUmVzcG9uc2UsIF9pc1ZlcnRleEFJLCB9KSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG5ldyBJbXBvcnRGaWxlT3BlcmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wID0gYXBpUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gaW1wb3J0RmlsZU9wZXJhdGlvbkZyb21NbGRldiQxKG9wKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcGVyYXRpb24sIHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbjtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBsaXN0IGZpbGVzIG1ldGhvZC4gKi9cbmNsYXNzIExpc3RGaWxlc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGNyZWF0ZSBmaWxlIG1ldGhvZC4gKi9cbmNsYXNzIENyZWF0ZUZpbGVSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBkZWxldGUgZmlsZSBtZXRob2QuICovXG5jbGFzcyBEZWxldGVGaWxlUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYGlubGluZWRfcmVzcG9uc2VzYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBJbmxpbmVkUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYHJlc3BvbnNlYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBTaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgaW5saW5lZF9lbWJlZGRpbmdfcmVzcG9uc2VzYCBwYXJhbWV0ZXIuICovXG5jbGFzcyBJbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgYmF0Y2hlcy5saXN0IHJldHVybiB2YWx1ZS4gKi9cbmNsYXNzIExpc3RCYXRjaEpvYnNSZXNwb25zZSB7XG59XG4vKiogUmVwcmVzZW50cyBhIHNpbmdsZSByZXNwb25zZSBpbiBhIHJlcGxheS4gKi9cbmNsYXNzIFJlcGxheVJlc3BvbnNlIHtcbn1cbi8qKiBBIHJhdyByZWZlcmVuY2UgaW1hZ2UuXG5cbkEgcmF3IHJlZmVyZW5jZSBpbWFnZSByZXByZXNlbnRzIHRoZSBiYXNlIGltYWdlIHRvIGVkaXQsIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLlxuSXQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQgaW4gYWRkaXRpb24gdG8gYSBtYXNrIHJlZmVyZW5jZSBpbWFnZSBvclxuYSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UuICovXG5jbGFzcyBSYXdSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfUkFXJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBtYXNrIHJlZmVyZW5jZSBpbWFnZS5cblxuVGhpcyBlbmNhcHN1bGF0ZXMgZWl0aGVyIGEgbWFzayBpbWFnZSBwcm92aWRlZCBieSB0aGUgdXNlciBhbmQgY29uZmlncyBmb3JcbnRoZSB1c2VyIHByb3ZpZGVkIG1hc2ssIG9yIG9ubHkgY29uZmlnIHBhcmFtZXRlcnMgZm9yIHRoZSBtb2RlbCB0byBnZW5lcmF0ZVxuYSBtYXNrLlxuXG5BIG1hc2sgaW1hZ2UgaXMgYW4gaW1hZ2Ugd2hvc2Ugbm9uLXplcm8gdmFsdWVzIGluZGljYXRlIHdoZXJlIHRvIGVkaXQgdGhlIGJhc2VcbmltYWdlLiBJZiB0aGUgdXNlciBwcm92aWRlcyBhIG1hc2sgaW1hZ2UsIHRoZSBtYXNrIG11c3QgYmUgaW4gdGhlIHNhbWVcbmRpbWVuc2lvbnMgYXMgdGhlIHJhdyBpbWFnZS4gKi9cbmNsYXNzIE1hc2tSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfTUFTSycsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgbWFza0ltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlLlxuXG5UaGUgaW1hZ2Ugb2YgdGhlIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlIGlzIGVpdGhlciBhIGNvbnRyb2wgaW1hZ2UgcHJvdmlkZWRcbmJ5IHRoZSB1c2VyLCBvciBhIHJlZ3VsYXIgaW1hZ2Ugd2hpY2ggdGhlIGJhY2tlbmQgd2lsbCB1c2UgdG8gZ2VuZXJhdGUgYVxuY29udHJvbCBpbWFnZSBvZi4gSW4gdGhlIGNhc2Ugb2YgdGhlIGxhdHRlciwgdGhlXG5lbmFibGVfY29udHJvbF9pbWFnZV9jb21wdXRhdGlvbiBmaWVsZCBpbiB0aGUgY29uZmlnIHNob3VsZCBiZSBzZXQgdG8gVHJ1ZS5cblxuQSBjb250cm9sIGltYWdlIGlzIGFuIGltYWdlIHRoYXQgcmVwcmVzZW50cyBhIHNrZXRjaCBpbWFnZSBvZiBhcmVhcyBmb3IgdGhlXG5tb2RlbCB0byBmaWxsIGluIGJhc2VkIG9uIHRoZSBwcm9tcHQuICovXG5jbGFzcyBDb250cm9sUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX0NPTlRST0wnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIGNvbnRyb2xJbWFnZUNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UuXG5cblRoaXMgZW5jYXBzdWxhdGVzIGEgc3R5bGUgcmVmZXJlbmNlIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLCBhbmRcbmFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuQSByYXcgcmVmZXJlbmNlIGltYWdlIGNhbiBhbHNvIGJlIHByb3ZpZGVkIGFzIGEgZGVzdGluYXRpb24gZm9yIHRoZSBzdHlsZSB0b1xuYmUgYXBwbGllZCB0by4gKi9cbmNsYXNzIFN0eWxlUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX1NUWUxFJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBzdHlsZUltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLlxuXG5UaGlzIGVuY2Fwc3VsYXRlcyBhIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLCBhbmRcbmFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLlxuXG5BIHJhdyByZWZlcmVuY2UgaW1hZ2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBkZXN0aW5hdGlvbiBmb3IgdGhlIHN1YmplY3QgdG9cbmJlIGFwcGxpZWQgdG8uICovXG5jbGFzcyBTdWJqZWN0UmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfU1VCSkVDVCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgc3ViamVjdEltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIGNvbnRlbnQgcmVmZXJlbmNlIGltYWdlLlxuXG5BIGNvbnRlbnQgcmVmZXJlbmNlIGltYWdlIHJlcHJlc2VudHMgYSBzdWJqZWN0IHRvIHJlZmVyZW5jZSAoZXguIHBlcnNvbixcbnByb2R1Y3QsIGFuaW1hbCkgcHJvdmlkZWQgYnkgdGhlIHVzZXIuIEl0IGNhbiBvcHRpb25hbGx5IGJlIHByb3ZpZGVkIGluXG5hZGRpdGlvbiB0byBhIHN0eWxlIHJlZmVyZW5jZSBpbWFnZSAoZXguIGJhY2tncm91bmQsIHN0eWxlIHJlZmVyZW5jZSkuICovXG5jbGFzcyBDb250ZW50UmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX0NPTlRFTlQnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciBBUEkgY2FsbC4gKi9cbmNsYXNzIExpdmVTZXJ2ZXJNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzIGZyb20gdGhlIHNlcnZlciBjb250ZW50IGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGxldCBhbnlUZXh0UGFydEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG5vblRleHRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9jID0gKF9iID0gKF9hID0gdGhpcy5zZXJ2ZXJDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZWxUdXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFydHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ3RleHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAhPT0gJ3Rob3VnaHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uVGV4dFBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGhvdWdodCA9PT0gJ2Jvb2xlYW4nICYmIHBhcnQudGhvdWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55VGV4dFBhcnRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vblRleHRQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyAke25vblRleHRQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gdGV4dCBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFydC50ZXh0ID09PSAnJyBpcyBkaWZmZXJlbnQgZnJvbSBwYXJ0LnRleHQgaXMgbnVsbFxuICAgICAgICByZXR1cm4gYW55VGV4dFBhcnRGb3VuZCA/IHRleHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIGZyb20gdGhlIHNlcnZlciBjb250ZW50IGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBub24taW5saW5lIGRhdGEgcGFydHMgaW4gdGhlXG4gICAgICogcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbmxpbmUgZGF0YSBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmRcbiAgICAgKiBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgICBjb25zdCBub25EYXRhUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfYyA9IChfYiA9IChfYSA9IHRoaXMuc2VydmVyQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGVsVHVybikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcnRzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICdpbmxpbmVEYXRhJyAmJiBmaWVsZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbkRhdGFQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnQuaW5saW5lRGF0YSAmJiB0eXBlb2YgcGFydC5pbmxpbmVEYXRhLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSArPSBhdG9iKHBhcnQuaW5saW5lRGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRGF0YVBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi1kYXRhIHBhcnRzICR7bm9uRGF0YVBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCBkYXRhIHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiBkYXRhIHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gYnRvYShkYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKiogQ2xpZW50IGdlbmVyYXRlZCByZXNwb25zZSB0byBhIGBUb29sQ2FsbGAgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuXG5JbmRpdmlkdWFsIGBGdW5jdGlvblJlc3BvbnNlYCBvYmplY3RzIGFyZSBtYXRjaGVkIHRvIHRoZSByZXNwZWN0aXZlXG5gRnVuY3Rpb25DYWxsYCBvYmplY3RzIGJ5IHRoZSBgaWRgIGZpZWxkLlxuXG5Ob3RlIHRoYXQgaW4gdGhlIHVuYXJ5IGFuZCBzZXJ2ZXItc3RyZWFtaW5nIEdlbmVyYXRlQ29udGVudCBBUElzIGZ1bmN0aW9uXG5jYWxsaW5nIGhhcHBlbnMgYnkgZXhjaGFuZ2luZyB0aGUgYENvbnRlbnRgIHBhcnRzLCB3aGlsZSBpbiB0aGUgYmlkaVxuR2VuZXJhdGVDb250ZW50IEFQSXMgZnVuY3Rpb24gY2FsbGluZyBoYXBwZW5zIG92ZXIgdGhpcyBkZWRpY2F0ZWQgc2V0IG9mXG5tZXNzYWdlcy4gKi9cbmNsYXNzIExpdmVDbGllbnRUb29sUmVzcG9uc2Uge1xufVxuLyoqIFBhcmFtZXRlcnMgZm9yIHNlbmRpbmcgdG9vbCByZXNwb25zZXMgdG8gdGhlIGxpdmUgQVBJLiAqL1xuY2xhc3MgTGl2ZVNlbmRUb29sUmVzcG9uc2VQYXJhbWV0ZXJzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIFRvb2wgcmVzcG9uc2VzIHRvIHNlbmQgdG8gdGhlIHNlc3Npb24uICovXG4gICAgICAgIHRoaXMuZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgbWVzc2FnZSBmb3IgdGhlIExpdmVNdXNpY0NsaWVudE1lc3NhZ2UgY2FsbC4gKi9cbmNsYXNzIExpdmVNdXNpY1NlcnZlck1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGF1ZGlvIGNodW5rIGZyb20gdGhlIHNlcnZlciBjb250ZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gYXVkaW8gY2h1bmtzIGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IGF1ZGlvQ2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlckNvbnRlbnQgJiZcbiAgICAgICAgICAgIHRoaXMuc2VydmVyQ29udGVudC5hdWRpb0NodW5rcyAmJlxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb250ZW50LmF1ZGlvQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZlckNvbnRlbnQuYXVkaW9DaHVua3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKiogVGhlIHJlc3BvbnNlIHdoZW4gbG9uZy1ydW5uaW5nIG9wZXJhdGlvbiBmb3IgdXBsb2FkaW5nIGEgZmlsZSB0byBhIEZpbGVTZWFyY2hTdG9yZSBjb21wbGV0ZS4gKi9cbmNsYXNzIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2Uge1xufVxuLyoqIExvbmctcnVubmluZyBvcGVyYXRpb24gZm9yIHVwbG9hZGluZyBhIGZpbGUgdG8gYSBGaWxlU2VhcmNoU3RvcmUuICovXG5jbGFzcyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIE9wZXJhdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBvbmUgYmVpbmcgY2FsbGVkIHdpdGggdGhlIGZpZWxkcyBzZXQgZnJvbSB0aGUgQVBJIHJlc3BvbnNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9mcm9tQVBJUmVzcG9uc2UoeyBhcGlSZXNwb25zZSwgX2lzVmVydGV4QUksIH0pIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wID0gYXBpUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb25Gcm9tTWxkZXYob3ApO1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wZXJhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbCBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAobW9kZWwuaW5jbHVkZXMoJy4uJykgfHwgbW9kZWwuaW5jbHVkZXMoJz8nKSB8fCBtb2RlbC5pbmNsdWRlcygnJicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtb2RlbCBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykgfHxcbiAgICAgICAgICAgIG1vZGVsLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpIHx8XG4gICAgICAgICAgICBtb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCcvJykgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBtb2RlbC5zcGxpdCgnLycsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGBwdWJsaXNoZXJzLyR7cGFydHNbMF19L21vZGVscy8ke3BhcnRzWzFdfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYHB1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy8ke21vZGVsfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykgfHwgbW9kZWwuc3RhcnRzV2l0aCgndHVuZWRNb2RlbHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgbW9kZWxzLyR7bW9kZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRDYWNoZXNNb2RlbChhcGlDbGllbnQsIG1vZGVsKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRNb2RlbCA9IHRNb2RlbChhcGlDbGllbnQsIG1vZGVsKTtcbiAgICBpZiAoIXRyYW5zZm9ybWVkTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZWRNb2RlbC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzLycpICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgLy8gdmVydGV4IGNhY2hlcyBvbmx5IHN1cHBvcnQgbW9kZWwgbmFtZSBzdGFydCB3aXRoIHByb2plY3RzLlxuICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7YXBpQ2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7YXBpQ2xpZW50LmdldExvY2F0aW9uKCl9LyR7dHJhbnNmb3JtZWRNb2RlbH1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSAmJiBhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHthcGlDbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHthcGlDbGllbnQuZ2V0TG9jYXRpb24oKX0vcHVibGlzaGVycy9nb29nbGUvJHt0cmFuc2Zvcm1lZE1vZGVsfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRNb2RlbDtcbiAgICB9XG59XG5mdW5jdGlvbiB0QmxvYnMoYmxvYnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShibG9icykpIHtcbiAgICAgICAgcmV0dXJuIGJsb2JzLm1hcCgoYmxvYikgPT4gdEJsb2IoYmxvYikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt0QmxvYihibG9icyldO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCbG9iKGJsb2IpIHtcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdvYmplY3QnICYmIGJsb2IgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIGlucHV0IGFzIEJsb2IuIFVuc3VwcG9ydGVkIGJsb2IgdHlwZTogJHt0eXBlb2YgYmxvYn1gKTtcbn1cbmZ1bmN0aW9uIHRJbWFnZUJsb2IoYmxvYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQmxvYiA9IHRCbG9iKGJsb2IpO1xuICAgIGlmICh0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUgJiZcbiAgICAgICAgdHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWltZSB0eXBlOiAke3RyYW5zZm9ybWVkQmxvYi5taW1lVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHRBdWRpb0Jsb2IoYmxvYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQmxvYiA9IHRCbG9iKGJsb2IpO1xuICAgIGlmICh0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUgJiZcbiAgICAgICAgdHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2F1ZGlvLycpKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEJsb2I7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWltZSB0eXBlOiAke3RyYW5zZm9ybWVkQmxvYi5taW1lVHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHRQYXJ0KG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3JpZ2luID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBvcmlnaW4gfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0IHR5cGU6ICR7dHlwZW9mIG9yaWdpbn1gKTtcbn1cbmZ1bmN0aW9uIHRQYXJ0cyhvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8XG4gICAgICAgIG9yaWdpbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KG9yaWdpbikgJiYgb3JpZ2luLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0TGlzdFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbi5tYXAoKGl0ZW0pID0+IHRQYXJ0KGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0UGFydChvcmlnaW4pXTtcbn1cbmZ1bmN0aW9uIF9pc0NvbnRlbnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3BhcnRzJyBpbiBvcmlnaW4gJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShvcmlnaW4ucGFydHMpKTtcbn1cbmZ1bmN0aW9uIF9pc0Z1bmN0aW9uQ2FsbFBhcnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbCcgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gdENvbnRlbnQob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRlbnRVbmlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoX2lzQ29udGVudChvcmlnaW4pKSB7XG4gICAgICAgIC8vIF9pc0NvbnRlbnQgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZVxuICAgICAgICAvLyBvcmlnaW4gaXMgYSBDb250ZW50LlxuICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIHBhcnRzOiB0UGFydHMob3JpZ2luKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBvcmlnaW4pIHtcbiAgICBpZiAoIW9yaWdpbikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmIEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLmZsYXRNYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0Q29udGVudChpdGVtKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5wYXJ0cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgY29udGVudC5wYXJ0c1swXS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0Q29udGVudChvcmlnaW4pO1xuICAgICAgICBpZiAoY29udGVudC5wYXJ0cyAmJlxuICAgICAgICAgICAgY29udGVudC5wYXJ0cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBjb250ZW50LnBhcnRzWzBdLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtjb250ZW50LnBhcnRzWzBdLnRleHRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLm1hcCgoaXRlbSkgPT4gdENvbnRlbnQoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RDb250ZW50KG9yaWdpbildO1xufVxuZnVuY3Rpb24gdENvbnRlbnRzKG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHxcbiAgICAgICAgb3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBvcmlnaW4ubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRlbnRzIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICAvLyBJZiBpdCdzIG5vdCBhbiBhcnJheSwgaXQncyBhIHNpbmdsZSBjb250ZW50IG9yIGEgc2luZ2xlIFBhcnRVbmlvbi5cbiAgICAgICAgaWYgKF9pc0Z1bmN0aW9uQ2FsbFBhcnQob3JpZ2luKSB8fCBfaXNGdW5jdGlvblJlc3BvbnNlUGFydChvcmlnaW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHNwZWNpZnkgZnVuY3Rpb25DYWxsIG9yIGZ1bmN0aW9uUmVzcG9uc2UgcGFydHMsIHBsZWFzZSB3cmFwIHRoZW0gaW4gYSBDb250ZW50IG9iamVjdCwgc3BlY2lmeWluZyB0aGUgcm9sZSBmb3IgdGhlbScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdENvbnRlbnQob3JpZ2luKV07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGFjY3VtdWxhdGVkUGFydHMgPSBbXTtcbiAgICBjb25zdCBpc0NvbnRlbnRBcnJheSA9IF9pc0NvbnRlbnQob3JpZ2luWzBdKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IGlzQ29udGVudCA9IF9pc0NvbnRlbnQoaXRlbSk7XG4gICAgICAgIGlmIChpc0NvbnRlbnQgIT0gaXNDb250ZW50QXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWl4aW5nIENvbnRlbnQgYW5kIFBhcnRzIGlzIG5vdCBzdXBwb3J0ZWQsIHBsZWFzZSBncm91cCB0aGUgcGFydHMgaW50byBhIHRoZSBhcHByb3ByaWF0ZSBDb250ZW50IG9iamVjdHMgYW5kIHNwZWNpZnkgdGhlIHJvbGVzIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ29udGVudCkge1xuICAgICAgICAgICAgLy8gYGlzQ29udGVudGAgY29udGFpbnMgdGhlIHJlc3VsdCBvZiBfaXNDb250ZW50LCB3aGljaCBpcyBhIHV0aWxpdHlcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBpdGVtIGlzIGEgQ29udGVudC5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9pc0Z1bmN0aW9uQ2FsbFBhcnQoaXRlbSkgfHwgX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gc3BlY2lmeSBmdW5jdGlvbkNhbGwgb3IgZnVuY3Rpb25SZXNwb25zZSBwYXJ0cywgcGxlYXNlIHdyYXAgdGhlbSwgYW5kIGFueSBvdGhlciBwYXJ0cywgaW4gQ29udGVudCBvYmplY3RzIGFzIGFwcHJvcHJpYXRlLCBzcGVjaWZ5aW5nIHRoZSByb2xlIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZFBhcnRzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0NvbnRlbnRBcnJheSkge1xuICAgICAgICByZXN1bHQucHVzaCh7IHJvbGU6ICd1c2VyJywgcGFydHM6IHRQYXJ0cyhhY2N1bXVsYXRlZFBhcnRzKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qXG5UcmFuc2Zvcm0gdGhlIHR5cGUgZmllbGQgZnJvbSBhbiBhcnJheSBvZiB0eXBlcyB0byBhbiBhcnJheSBvZiBhbnlPZiBmaWVsZHMuXG5FeGFtcGxlOlxuICB7dHlwZTogWydTVFJJTkcnLCAnTlVNQkVSJ119XG53aWxsIGJlIHRyYW5zZm9ybWVkIHRvXG4gIHthbnlPZjogW3t0eXBlOiAnU1RSSU5HJ30sIHt0eXBlOiAnTlVNQkVSJ31dfVxuKi9cbmZ1bmN0aW9uIGZsYXR0ZW5UeXBlQXJyYXlUb0FueU9mKHR5cGVMaXN0LCByZXN1bHRpbmdTY2hlbWEpIHtcbiAgICBpZiAodHlwZUxpc3QuaW5jbHVkZXMoJ251bGwnKSkge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBsaXN0V2l0aG91dE51bGwgPSB0eXBlTGlzdC5maWx0ZXIoKHR5cGUpID0+IHR5cGUgIT09ICdudWxsJyk7XG4gICAgaWYgKGxpc3RXaXRob3V0TnVsbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmVzdWx0aW5nU2NoZW1hWyd0eXBlJ10gPSBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKGxpc3RXaXRob3V0TnVsbFswXS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgPyBsaXN0V2l0aG91dE51bGxbMF0udG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ2FueU9mJ10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGxpc3RXaXRob3V0TnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0aW5nU2NoZW1hWydhbnlPZiddLnB1c2goe1xuICAgICAgICAgICAgICAgICd0eXBlJzogT2JqZWN0LnZhbHVlcyhUeXBlKS5pbmNsdWRlcyhpLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICAgID8gaS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIDogVHlwZS5UWVBFX1VOU1BFQ0lGSUVELFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzSnNvblNjaGVtYShfanNvblNjaGVtYSkge1xuICAgIGNvbnN0IGdlbkFJU2NoZW1hID0ge307XG4gICAgY29uc3Qgc2NoZW1hRmllbGROYW1lcyA9IFsnaXRlbXMnXTtcbiAgICBjb25zdCBsaXN0U2NoZW1hRmllbGROYW1lcyA9IFsnYW55T2YnXTtcbiAgICBjb25zdCBkaWN0U2NoZW1hRmllbGROYW1lcyA9IFsncHJvcGVydGllcyddO1xuICAgIGlmIChfanNvblNjaGVtYVsndHlwZSddICYmIF9qc29uU2NoZW1hWydhbnlPZiddKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBhbmQgYW55T2YgY2Fubm90IGJlIGJvdGggcG9wdWxhdGVkLicpO1xuICAgIH1cbiAgICAvKlxuICAgIFRoaXMgaXMgdG8gaGFuZGxlIHRoZSBudWxsYWJsZSBhcnJheSBvciBvYmplY3QuIFRoZSBfanNvblNjaGVtYSB3aWxsXG4gICAgYmUgaW4gdGhlIGZvcm1hdCBvZiB7YW55T2Y6IFt7dHlwZTogJ251bGwnfSwge3R5cGU6ICdvYmplY3QnfV19LiBUaGVcbiAgICBsb2dpYyBpcyB0byBjaGVjayBpZiBhbnlPZiBoYXMgMiBlbGVtZW50cyBhbmQgb25lIG9mIHRoZSBlbGVtZW50IGlzIG51bGwsXG4gICAgaWYgc28sIHRoZSBhbnlPZiBmaWVsZCBpcyB1bm5lY2Vzc2FyeSwgc28gd2UgbmVlZCB0byBnZXQgcmlkIG9mIHRoZSBhbnlPZlxuICAgIGZpZWxkIGFuZCBtYWtlIHRoZSBzY2hlbWEgbnVsbGFibGUuIFRoZW4gdXNlIHRoZSBvdGhlciBlbGVtZW50IGFzIHRoZSBuZXdcbiAgICBfanNvblNjaGVtYSBmb3IgcHJvY2Vzc2luZy4gVGhpcyBpcyBiZWNhdXNlIHRoZSBiYWNrZW5kIGRvZXNuJ3QgaGF2ZSBhIG51bGxcbiAgICB0eXBlLlxuICAgIFRoaXMgaGFzIHRvIGJlIGNoZWNrZWQgYmVmb3JlIHdlIHByb2Nlc3MgYW55IG90aGVyIGZpZWxkcy5cbiAgICBGb3IgZXhhbXBsZTpcbiAgICAgIGNvbnN0IG9iamVjdE51bGxhYmxlID0gei5vYmplY3Qoe1xuICAgICAgICBudWxsYWJsZUFycmF5OiB6LmFycmF5KHouc3RyaW5nKCkpLm51bGxhYmxlKCksXG4gICAgICB9KTtcbiAgICBXaWxsIGhhdmUgdGhlIHJhdyBfanNvblNjaGVtYSBhczpcbiAgICB7XG4gICAgICB0eXBlOiAnT0JKRUNUJyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBudWxsYWJsZUFycmF5OiB7XG4gICAgICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgICAgICB7dHlwZTogJ251bGwnfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFsgJ251bGxhYmxlQXJyYXknIF0sXG4gICAgfVxuICAgIFdpbGwgcmVzdWx0IGluIGZvbGxvd2luZyBzY2hlbWEgY29tcGF0aWJsZSB3aXRoIEdlbWluaSBBUEk6XG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdPQkpFQ1QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgIG51bGxhYmxlQXJyYXk6IHtcbiAgICAgICAgICAgICAgbnVsbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdBUlJBWScsXG4gICAgICAgICAgICAgIGl0ZW1zOiB7dHlwZTogJ3N0cmluZyd9LFxuICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbICdudWxsYWJsZUFycmF5JyBdLFxuICAgICAgfVxuICAgICovXG4gICAgY29uc3QgaW5jb21pbmdBbnlPZiA9IF9qc29uU2NoZW1hWydhbnlPZiddO1xuICAgIGlmIChpbmNvbWluZ0FueU9mICE9IG51bGwgJiYgaW5jb21pbmdBbnlPZi5sZW5ndGggPT0gMikge1xuICAgICAgICBpZiAoaW5jb21pbmdBbnlPZlswXVsndHlwZSddID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIGdlbkFJU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgIF9qc29uU2NoZW1hID0gaW5jb21pbmdBbnlPZlsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNvbWluZ0FueU9mWzFdWyd0eXBlJ10gPT09ICdudWxsJykge1xuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgICAgICAgICAgX2pzb25TY2hlbWEgPSBpbmNvbWluZ0FueU9mWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChfanNvblNjaGVtYVsndHlwZSddIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZmxhdHRlblR5cGVBcnJheVRvQW55T2YoX2pzb25TY2hlbWFbJ3R5cGUnXSwgZ2VuQUlTY2hlbWEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKF9qc29uU2NoZW1hKSkge1xuICAgICAgICAvLyBTa2lwIGlmIHRoZSBmaWVsZHZhbHVlIGlzIHVuZGVmaW5lZCBvciBudWxsLlxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGROYW1lID09ICd0eXBlJykge1xuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZTogbnVsbCBjYW4gbm90IGJlIHRoZSBvbmx5IHBvc3NpYmxlIHR5cGUgZm9yIHRoZSBmaWVsZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZCB0aGUgdHlwZSBmaWVsZCB3aXRoIGFycmF5IG9mIHR5cGVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ3R5cGUnXSA9IE9iamVjdC52YWx1ZXMoVHlwZSkuaW5jbHVkZXMoZmllbGRWYWx1ZS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgICAgID8gZmllbGRWYWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hRmllbGROYW1lcy5pbmNsdWRlcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVtmaWVsZE5hbWVdID1cbiAgICAgICAgICAgICAgICBwcm9jZXNzSnNvblNjaGVtYShmaWVsZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaXN0U2NoZW1hRmllbGROYW1lcy5pbmNsdWRlcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0U2NoZW1hRmllbGRWYWx1ZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVsndHlwZSddID09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgICBnZW5BSVNjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0U2NoZW1hRmllbGRWYWx1ZS5wdXNoKHByb2Nlc3NKc29uU2NoZW1hKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIGxpc3RTY2hlbWFGaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpY3RTY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpY3RTY2hlbWFGaWVsZFZhbHVlID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRpY3RTY2hlbWFGaWVsZFZhbHVlW2tleV0gPSBwcm9jZXNzSnNvblNjaGVtYSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVtmaWVsZE5hbWVdID1cbiAgICAgICAgICAgICAgICBkaWN0U2NoZW1hRmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIGlzIG5vdCBpbmNsdWRlZCBpbiBKU09OU2NoZW1hLCBza2lwcGluZyBpdC5cbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09ICdhZGRpdGlvbmFsUHJvcGVydGllcycpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPSBmaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW5BSVNjaGVtYTtcbn1cbi8vIHdlIHRha2UgdGhlIHVua25vd24gaW4gdGhlIHNjaGVtYSBmaWVsZCBiZWNhdXNlIHdlIHdhbnQgZW5hYmxlIHVzZXIgdG8gcGFzc1xuLy8gdGhlIG91dHB1dCBvZiBtYWpvciBzY2hlbWEgZGVjbGFyYXRpb24gdG9vbHMgd2l0aG91dCBjYXN0aW5nLiBUb29scyBzdWNoIGFzXG4vLyB6b2RUb0pzb25TY2hlbWEsIHR5cGVib3gsIHpvZFRvSnNvblNjaGVtYSBmdW5jdGlvbiBjYW4gcmV0dXJuIEpzb25TY2hlbWE3VHlwZVxuLy8gb3Igb2JqZWN0LCBzZWUgZGV0YWlscyBpblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1N0ZWZhblRlcmRlbGwvem9kLXRvLWpzb24tc2NoZW1hL2Jsb2IvNzA1MjVlZmU1NTVjZDIyNjY5MWUwOTNkMTcxMzcwYTNiMTA5MjFkMS9zcmMvem9kVG9Kc29uU2NoZW1hLnRzI0w3XG4vLyB0eXBlYm94IGNhbiByZXR1cm4gdW5rbm93biwgc2VlIGRldGFpbHMgaW5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5jbGFpcnp4ODEvdHlwZWJveC9ibG9iLzVhNTQzMTQzOWY3ZDVjYTZiNDk0ZDBkMThmYmZkN2IxYTM1NmQ2N2Mvc3JjL3R5cGUvY3JlYXRlL3R5cGUudHMjTDM1XG4vLyBOb3RlOiBwcm9wZXIganNvbiBzY2hlbWFzIHdpdGggdGhlICRzY2hlbWEgZmllbGQgc2V0IG5ldmVyIGFycml2ZSB0byB0aGlzXG4vLyB0cmFuc2Zvcm1lci4gU2NoZW1hcyB3aXRoICRzY2hlbWEgYXJlIHJvdXRlZCB0byB0aGUgZXF1aXZhbGVudCBBUEkganNvblxuLy8gc2NoZW1hIGZpZWxkLlxuZnVuY3Rpb24gdFNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0pzb25TY2hlbWEoc2NoZW1hKTtcbn1cbmZ1bmN0aW9uIHRTcGVlY2hDb25maWcoc3BlZWNoQ29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBzcGVlY2hDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzcGVlY2hDb25maWc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGVlY2hDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2b2ljZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgIHByZWJ1aWx0Vm9pY2VDb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgdm9pY2VOYW1lOiBzcGVlY2hDb25maWcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNwZWVjaENvbmZpZyB0eXBlOiAke3R5cGVvZiBzcGVlY2hDb25maWd9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdExpdmVTcGVlY2hDb25maWcoc3BlZWNoQ29uZmlnKSB7XG4gICAgaWYgKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZycgaW4gc3BlZWNoQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlTcGVha2VyVm9pY2VDb25maWcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgbGl2ZSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiBzcGVlY2hDb25maWc7XG59XG5mdW5jdGlvbiB0VG9vbCh0b29sKSB7XG4gICAgaWYgKHRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uIG9mIHRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycykuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMgPSBwcm9jZXNzSnNvblNjaGVtYShmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnNKc29uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnNKc29uU2NoZW1hID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UpLmluY2x1ZGVzKCckc2NoZW1hJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSA9IHByb2Nlc3NKc29uU2NoZW1hKGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlSnNvblNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZUpzb25TY2hlbWEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9vbDtcbn1cbmZ1bmN0aW9uIHRUb29scyh0b29scykge1xuICAgIC8vIENoZWNrIGlmIHRoZSBpbmNvbWluZyB0eXBlIGlzIGRlZmluZWQuXG4gICAgaWYgKHRvb2xzID09PSB1bmRlZmluZWQgfHwgdG9vbHMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9vbHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9vbHMgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYW4gYXJyYXkgb2YgVG9vbHMnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRvb2wpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBQcmVwZW5kcyByZXNvdXJjZSBuYW1lIHdpdGggcHJvamVjdCwgbG9jYXRpb24sIHJlc291cmNlX3ByZWZpeCBpZiBuZWVkZWQuXG4gKlxuICogQHBhcmFtIGNsaWVudCBUaGUgQVBJIGNsaWVudC5cbiAqIEBwYXJhbSByZXNvdXJjZU5hbWUgVGhlIHJlc291cmNlIG5hbWUuXG4gKiBAcGFyYW0gcmVzb3VyY2VQcmVmaXggVGhlIHJlc291cmNlIHByZWZpeC5cbiAqIEBwYXJhbSBzcGxpdHNBZnRlclByZWZpeCBUaGUgbnVtYmVyIG9mIHNwbGl0cyBhZnRlciB0aGUgcHJlZml4LlxuICogQHJldHVybnMgVGhlIGNvbXBsZXRlZCByZXNvdXJjZSBuYW1lLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICcxMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogY2xpZW50LnByb2plY3QgPSAnYmFyJ1xuICogY2xpZW50LmxvY2F0aW9uID0gJ3VzLXdlc3QxJ1xuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiByZXR1cm5zOiAncHJvamVjdHMvYmFyL2xvY2F0aW9ucy91cy13ZXN0MS9jYWNoZWRDb250ZW50cy8xMjMnXG4gKiBgYGBcbiAqXG4gKiBgYGBcbiAqIHJlc291cmNlX25hbWUgPSAncHJvamVjdHMvZm9vL2xvY2F0aW9ucy91cy1jZW50cmFsMS9jYWNoZWRDb250ZW50cy8xMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogY2xpZW50LnByb2plY3QgPSAnYmFyJ1xuICogY2xpZW50LmxvY2F0aW9uID0gJ3VzLXdlc3QxJ1xuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiByZXR1cm5zOiAncHJvamVjdHMvZm9vL2xvY2F0aW9ucy91cy1jZW50cmFsMS9jYWNoZWRDb250ZW50cy8xMjMnXG4gKiBgYGBcbiAqXG4gKiBgYGBcbiAqIHJlc291cmNlX25hbWUgPSAnMTIzJ1xuICogcmVzb3VyY2VfcHJlZml4ID0gJ2NhY2hlZENvbnRlbnRzJ1xuICogc3BsaXRzX2FmdGVyX3ByZWZpeCA9IDFcbiAqIGNsaWVudC52ZXJ0ZXhhaSA9IEZhbHNlXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnMgJ2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICdzb21lL3dyb25nL2NhY2hlZENvbnRlbnRzL3Jlc291cmNlL25hbWUvMTIzJ1xuICogcmVzb3VyY2VfcHJlZml4ID0gJ2NhY2hlZENvbnRlbnRzJ1xuICogc3BsaXRzX2FmdGVyX3ByZWZpeCA9IDFcbiAqIGNsaWVudC52ZXJ0ZXhhaSA9IEZhbHNlXG4gKiAjIGNsaWVudC52ZXJ0ZXhhaSA9IFRydWVcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogLT4gJ3NvbWUvd3JvbmcvcmVzb3VyY2UvbmFtZS8xMjMnXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gcmVzb3VyY2VOYW1lKGNsaWVudCwgcmVzb3VyY2VOYW1lLCByZXNvdXJjZVByZWZpeCwgc3BsaXRzQWZ0ZXJQcmVmaXggPSAxKSB7XG4gICAgY29uc3Qgc2hvdWxkQXBwZW5kUHJlZml4ID0gIXJlc291cmNlTmFtZS5zdGFydHNXaXRoKGAke3Jlc291cmNlUHJlZml4fS9gKSAmJlxuICAgICAgICByZXNvdXJjZU5hbWUuc3BsaXQoJy8nKS5sZW5ndGggPT09IHNwbGl0c0FmdGVyUHJlZml4O1xuICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aCgncHJvamVjdHMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoJ2xvY2F0aW9ucy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2NsaWVudC5nZXRQcm9qZWN0KCl9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoYCR7cmVzb3VyY2VQcmVmaXh9L2ApKSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7Y2xpZW50LmdldExvY2F0aW9uKCl9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hvdWxkQXBwZW5kUHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7Y2xpZW50LmdldExvY2F0aW9uKCl9LyR7cmVzb3VyY2VQcmVmaXh9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VOYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRBcHBlbmRQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIGAke3Jlc291cmNlUHJlZml4fS8ke3Jlc291cmNlTmFtZX1gO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lO1xufVxuZnVuY3Rpb24gdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgbmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc291cmNlTmFtZShhcGlDbGllbnQsIG5hbWUsICdjYWNoZWRDb250ZW50cycpO1xufVxuZnVuY3Rpb24gdFR1bmluZ0pvYlN0YXR1cyhzdGF0dXMpIHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlICdTVEFURV9VTlNQRUNJRklFRCc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9VTlNQRUNJRklFRCc7XG4gICAgICAgIGNhc2UgJ0NSRUFUSU5HJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1JVTk5JTkcnO1xuICAgICAgICBjYXNlICdBQ1RJVkUnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfU1VDQ0VFREVEJztcbiAgICAgICAgY2FzZSAnRkFJTEVEJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0ZBSUxFRCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykge1xuICAgIHJldHVybiB0Qnl0ZXMkMShmcm9tSW1hZ2VCeXRlcyk7XG59XG5mdW5jdGlvbiBfaXNGaWxlKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICduYW1lJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gaXNHZW5lcmF0ZWRWaWRlbyhvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndmlkZW8nIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiBpc1ZpZGVvKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICd1cmknIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiB0RmlsZU5hbWUoZnJvbU5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG5hbWU7XG4gICAgaWYgKF9pc0ZpbGUoZnJvbU5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBmcm9tTmFtZS5uYW1lO1xuICAgIH1cbiAgICBpZiAoaXNWaWRlbyhmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lLnVyaTtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNHZW5lcmF0ZWRWaWRlbyhmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IChfYSA9IGZyb21OYW1lLnZpZGVvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXJpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnJvbU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBmcm9tTmFtZTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBleHRyYWN0IGZpbGUgbmFtZSBmcm9tIHRoZSBwcm92aWRlZCBpbnB1dC4nKTtcbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSBuYW1lLnNwbGl0KCdmaWxlcy8nKVsxXTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzdWZmaXgubWF0Y2goL1thLXowLTldKy8pO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGV4dHJhY3QgZmlsZSBuYW1lIGZyb20gVVJJICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gbWF0Y2hbMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoJ2ZpbGVzLycpWzFdO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIHRNb2RlbHNVcmwoYXBpQ2xpZW50LCBiYXNlTW9kZWxzKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICByZXMgPSBiYXNlTW9kZWxzID8gJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscycgOiAnbW9kZWxzJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcyA9IGJhc2VNb2RlbHMgPyAnbW9kZWxzJyA6ICd0dW5lZE1vZGVscyc7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB0RXh0cmFjdE1vZGVscyhyZXNwb25zZSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsnbW9kZWxzJywgJ3R1bmVkTW9kZWxzJywgJ3B1Ymxpc2hlck1vZGVscyddKSB7XG4gICAgICAgIGlmIChoYXNGaWVsZChyZXNwb25zZSwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gaGFzRmllbGQoZGF0YSwgZmllbGROYW1lKSB7XG4gICAgcmV0dXJuIGRhdGEgIT09IG51bGwgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGZpZWxkTmFtZSBpbiBkYXRhO1xufVxuZnVuY3Rpb24gbWNwVG9HZW1pbmlUb29sKG1jcFRvb2wsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgbWNwVG9vbFNjaGVtYSA9IG1jcFRvb2w7XG4gICAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbiA9IHtcbiAgICAgICAgbmFtZTogbWNwVG9vbFNjaGVtYVsnbmFtZSddLFxuICAgICAgICBkZXNjcmlwdGlvbjogbWNwVG9vbFNjaGVtYVsnZGVzY3JpcHRpb24nXSxcbiAgICAgICAgcGFyYW1ldGVyc0pzb25TY2hlbWE6IG1jcFRvb2xTY2hlbWFbJ2lucHV0U2NoZW1hJ10sXG4gICAgfTtcbiAgICBpZiAobWNwVG9vbFNjaGVtYVsnb3V0cHV0U2NoZW1hJ10pIHtcbiAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvblsncmVzcG9uc2VKc29uU2NoZW1hJ10gPSBtY3BUb29sU2NoZW1hWydvdXRwdXRTY2hlbWEnXTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5iZWhhdmlvcikge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uWydiZWhhdmlvciddID0gY29uZmlnLmJlaGF2aW9yO1xuICAgIH1cbiAgICBjb25zdCBnZW1pbmlUb29sID0ge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICAgICAgXSxcbiAgICB9O1xuICAgIHJldHVybiBnZW1pbmlUb29sO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGxpc3Qgb2YgTUNQIHRvb2xzIHRvIGEgc2luZ2xlIEdlbWluaSB0b29sIHdpdGggYSBsaXN0IG9mIGZ1bmN0aW9uXG4gKiBkZWNsYXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1jcFRvb2xzVG9HZW1pbmlUb29sKG1jcFRvb2xzLCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb25zID0gW107XG4gICAgY29uc3QgdG9vbE5hbWVzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbWNwVG9vbCBvZiBtY3BUb29scykge1xuICAgICAgICBjb25zdCBtY3BUb29sTmFtZSA9IG1jcFRvb2wubmFtZTtcbiAgICAgICAgaWYgKHRvb2xOYW1lcy5oYXMobWNwVG9vbE5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBmdW5jdGlvbiBuYW1lICR7bWNwVG9vbE5hbWV9IGZvdW5kIGluIE1DUCB0b29scy4gUGxlYXNlIGVuc3VyZSBmdW5jdGlvbiBuYW1lcyBhcmUgdW5pcXVlLmApO1xuICAgICAgICB9XG4gICAgICAgIHRvb2xOYW1lcy5hZGQobWNwVG9vbE5hbWUpO1xuICAgICAgICBjb25zdCBnZW1pbmlUb29sID0gbWNwVG9HZW1pbmlUb29sKG1jcFRvb2wsIGNvbmZpZyk7XG4gICAgICAgIGlmIChnZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9ucy5wdXNoKC4uLmdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBmdW5jdGlvbkRlY2xhcmF0aW9ucyB9O1xufVxuLy8gVHJhbnNmb3JtcyBhIHNvdXJjZSBpbnB1dCBpbnRvIGEgQmF0Y2hKb2JTb3VyY2Ugb2JqZWN0IHdpdGggdmFsaWRhdGlvbi5cbmZ1bmN0aW9uIHRCYXRjaEpvYlNvdXJjZShjbGllbnQsIHNyYykge1xuICAgIGxldCBzb3VyY2VPYmo7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2dzOi8vJykpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VPYmogPSB7IGZvcm1hdDogJ2pzb25sJywgZ2NzVXJpOiBbc3JjXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2JxOi8vJykpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VPYmogPSB7IGZvcm1hdDogJ2JpZ3F1ZXJ5JywgYmlncXVlcnlVcmk6IHNyYyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzdHJpbmcgc291cmNlIGZvciBWZXJ0ZXggQUk6ICR7c3JjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTUxERVZcbiAgICAgICAgICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VPYmogPSB7IGZpbGVOYW1lOiBzcmMgfTsgLy8gRGVmYXVsdCB0byBmaWxlTmFtZSBmb3Igc3RyaW5nIGlucHV0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHN0cmluZyBzb3VyY2UgZm9yIEdlbWluaSBBUEk6ICR7c3JjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICBpZiAoY2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmxpbmVkUmVxdWVzdFtdIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZU9iaiA9IHsgaW5saW5lZFJlcXVlc3RzOiBzcmMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEl0J3MgYWxyZWFkeSBhIEJhdGNoSm9iU291cmNlIG9iamVjdFxuICAgICAgICBzb3VyY2VPYmogPSBzcmM7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRpb24gbG9naWNcbiAgICBjb25zdCB2ZXJ0ZXhTb3VyY2VzQ291bnQgPSBbc291cmNlT2JqLmdjc1VyaSwgc291cmNlT2JqLmJpZ3F1ZXJ5VXJpXS5maWx0ZXIoQm9vbGVhbikubGVuZ3RoO1xuICAgIGNvbnN0IG1sZGV2U291cmNlc0NvdW50ID0gW1xuICAgICAgICBzb3VyY2VPYmouaW5saW5lZFJlcXVlc3RzLFxuICAgICAgICBzb3VyY2VPYmouZmlsZU5hbWUsXG4gICAgXS5maWx0ZXIoQm9vbGVhbikubGVuZ3RoO1xuICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGlmIChtbGRldlNvdXJjZXNDb3VudCA+IDAgfHwgdmVydGV4U291cmNlc0NvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4YWN0bHkgb25lIG9mIGBnY3NVcmlgIG9yIGBiaWdxdWVyeVVyaWAgbXVzdCBiZSBzZXQgZm9yIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTUxERVZcbiAgICAgICAgaWYgKHZlcnRleFNvdXJjZXNDb3VudCA+IDAgfHwgbWxkZXZTb3VyY2VzQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhhY3RseSBvbmUgb2YgYGlubGluZWRSZXF1ZXN0c2AsIGBmaWxlTmFtZWAsICcgK1xuICAgICAgICAgICAgICAgICdtdXN0IGJlIHNldCBmb3IgR2VtaW5pIEFQSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlT2JqO1xufVxuZnVuY3Rpb24gdEJhdGNoSm9iRGVzdGluYXRpb24oZGVzdCkge1xuICAgIGlmICh0eXBlb2YgZGVzdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIGNvbnN0IGRlc3RTdHJpbmcgPSBkZXN0O1xuICAgIGlmIChkZXN0U3RyaW5nLnN0YXJ0c1dpdGgoJ2dzOi8vJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ2pzb25sJyxcbiAgICAgICAgICAgIGdjc1VyaTogZGVzdFN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVzdFN0cmluZy5zdGFydHNXaXRoKCdicTovLycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6ICdiaWdxdWVyeScsXG4gICAgICAgICAgICBiaWdxdWVyeVVyaTogZGVzdFN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVzdGluYXRpb246ICR7ZGVzdFN0cmluZ31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZGVzdCkge1xuICAgIC8vIEVuc3VyZSBkZXN0IGlzIGEgbm9uLW51bGwgb2JqZWN0IGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgIGlmICh0eXBlb2YgZGVzdCAhPT0gJ29iamVjdCcgfHwgZGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgbm90IGFuIG9iamVjdCwgaXQgY2Fubm90IGJlIGEgdmFsaWQgQmF0Y2hKb2JEZXN0aW5hdGlvblxuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgb3BlcmF0aW9ucyBwZXJmb3JtZWQuIFJldHVybiBpdCBjYXN0LCBvciBoYW5kbGUgYXMgYW4gZXJyb3IuXG4gICAgICAgIC8vIENhc3RpbmcgYW4gZW1wdHkgb2JqZWN0IG1pZ2h0IGJlIGEgc2FmZSBkZWZhdWx0LlxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIC8vIENhc3QgdG8gUmVjb3JkPHN0cmluZywgdW5rbm93bj4gdG8gYWxsb3cgc3RyaW5nIHByb3BlcnR5IGFjY2Vzcy5cbiAgICBjb25zdCBvYmogPSBkZXN0O1xuICAgIC8vIFNhZmVseSBhY2Nlc3MgbmVzdGVkIHByb3BlcnRpZXMuXG4gICAgY29uc3QgaW5saW5lUmVzcG9uc2VzVmFsID0gb2JqWydpbmxpbmVkUmVzcG9uc2VzJ107XG4gICAgaWYgKHR5cGVvZiBpbmxpbmVSZXNwb25zZXNWYWwgIT09ICdvYmplY3QnIHx8IGlubGluZVJlc3BvbnNlc1ZhbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgY29uc3QgaW5saW5lUmVzcG9uc2VzT2JqID0gaW5saW5lUmVzcG9uc2VzVmFsO1xuICAgIGNvbnN0IHJlc3BvbnNlc0FycmF5ID0gaW5saW5lUmVzcG9uc2VzT2JqWydpbmxpbmVkUmVzcG9uc2VzJ107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3BvbnNlc0FycmF5KSB8fCByZXNwb25zZXNBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGFueSByZXNwb25zZSBoYXMgdGhlICdlbWJlZGRpbmcnIHByb3BlcnR5LlxuICAgIGxldCBoYXNFbWJlZGRpbmcgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlSXRlbSBvZiByZXNwb25zZXNBcnJheSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlSXRlbSAhPT0gJ29iamVjdCcgfHwgcmVzcG9uc2VJdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZUl0ZW1PYmogPSByZXNwb25zZUl0ZW07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVmFsID0gcmVzcG9uc2VJdGVtT2JqWydyZXNwb25zZSddO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlVmFsICE9PSAnb2JqZWN0JyB8fCByZXNwb25zZVZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VPYmogPSByZXNwb25zZVZhbDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgdGhlICdlbWJlZGRpbmcnIGtleS5cbiAgICAgICAgaWYgKHJlc3BvbnNlT2JqWydlbWJlZGRpbmcnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYXNFbWJlZGRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUGVyZm9ybSB0aGUgdHJhbnNmb3JtYXRpb24gaWYgYW4gZW1iZWRkaW5nIHdhcyBmb3VuZC5cbiAgICBpZiAoaGFzRW1iZWRkaW5nKSB7XG4gICAgICAgIG9ialsnaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyddID0gb2JqWydpbmxpbmVkUmVzcG9uc2VzJ107XG4gICAgICAgIGRlbGV0ZSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICB9XG4gICAgLy8gQ2FzdCB0aGUgKHBvdGVudGlhbGx5KSBtb2RpZmllZCBvYmplY3QgdG8gdGhlIHRhcmdldCB0eXBlLlxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIG5hbWUpIHtcbiAgICBjb25zdCBuYW1lU3RyaW5nID0gbmFtZTtcbiAgICBpZiAoIWFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgbWxkZXZQYXR0ZXJuID0gL2JhdGNoZXNcXC9bXi9dKyQvO1xuICAgICAgICBpZiAobWxkZXZQYXR0ZXJuLnRlc3QobmFtZVN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lU3RyaW5nLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmF0Y2ggam9iIG5hbWU6ICR7bmFtZVN0cmluZ30uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmVydGV4UGF0dGVybiA9IC9ecHJvamVjdHNcXC9bXi9dK1xcL2xvY2F0aW9uc1xcL1teL10rXFwvYmF0Y2hQcmVkaWN0aW9uSm9ic1xcL1teL10rJC87XG4gICAgaWYgKHZlcnRleFBhdHRlcm4udGVzdChuYW1lU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gbmFtZVN0cmluZy5zcGxpdCgnLycpLnBvcCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXlxcZCskLy50ZXN0KG5hbWVTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBuYW1lU3RyaW5nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhdGNoIGpvYiBuYW1lOiAke25hbWVTdHJpbmd9LmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRKb2JTdGF0ZShzdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRlU3RyaW5nID0gc3RhdGU7XG4gICAgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfVU5TUEVDSUZJRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1VOU1BFQ0lGSUVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9QRU5ESU5HJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9QRU5ESU5HJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9SVU5OSU5HJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9SVU5OSU5HJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9TVUNDRUVERUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1NVQ0NFRURFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfRkFJTEVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9GQUlMRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX0NBTkNFTExFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfQ0FOQ0VMTEVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9FWFBJUkVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9FWFBJUkVEJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZVN0cmluZztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZXNGaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlTmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZFJlc3BvbnNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXNwb25zZXMnLFxuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVzcG9uc2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkUmVzcG9uc2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZWRSZXNwb25zZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZWRSZXNwb25zZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJyxcbiAgICAgICAgJ2lubGluZWRSZXNwb25zZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVkaWN0aW9uc0Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2djc0Rlc3RpbmF0aW9uJyxcbiAgICAgICAgJ291dHB1dFVyaVByZWZpeCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpZ3F1ZXJ5RGVzdGluYXRpb24nLFxuICAgICAgICAnb3V0cHV0VXJpJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JEZXN0aW5hdGlvblRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWRpY3Rpb25zRm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NEZXN0aW5hdGlvbicsICdvdXRwdXRVcmlQcmVmaXgnXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmlncXVlcnlVcmknXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5RGVzdGluYXRpb24nLCAnb3V0cHV0VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlTmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZWRSZXNwb25zZXMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRSZXNwb25zZXMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2Rpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YScsICdzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdEpvYlN0YXRlKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2NyZWF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2VuZFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ3VwZGF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJywgJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnLCAnb3V0cHV0J10pO1xuICAgIGlmIChmcm9tRGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc3QnXSwgYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldih0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZnJvbURlc3QpKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdEpvYlN0YXRlKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lucHV0Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3JjJ10sIGJhdGNoSm9iU291cmNlRnJvbVZlcnRleChmcm9tU3JjKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRDb25maWcnXSk7XG4gICAgaWYgKGZyb21EZXN0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzdCddLCBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleCh0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZnJvbURlc3QpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wbGV0aW9uU3RhdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb21wbGV0aW9uU3RhdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29tcGxldGlvblN0YXRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcGxldGlvblN0YXRzJ10sIGZyb21Db21wbGV0aW9uU3RhdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYlNvdXJjZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5zdGFuY2VzRm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NTb3VyY2UnLCAndXJpcyddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmlncXVlcnlTb3VyY2UnLFxuICAgICAgICAnaW5wdXRVcmknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2djc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiaWdxdWVyeVVyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmlncXVlcnlVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKTtcbiAgICBpZiAoZnJvbUZpbGVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZU5hbWUnXSwgZnJvbUZpbGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRSZXF1ZXN0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXF1ZXN0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVxdWVzdHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUlubGluZWRSZXF1ZXN0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmxpbmVkUmVxdWVzdFRvTWxkZXYoYXBpQ2xpZW50LCBpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzJywgJ3JlcXVlc3RzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzRm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NTb3VyY2UnLCAndXJpcyddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiaWdxdWVyeVVyaSddKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlTb3VyY2UnLCAnaW5wdXRVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lZFJlcXVlc3RzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmxpbmVkUmVxdWVzdHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50J10pO1xuICAgIGlmIChmcm9tQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnQnXSwgZnJvbUNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxKGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5UmF0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaXRhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NpdGF0aW9uU291cmNlcyddKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2l0YXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDQoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2JhdGNoJywgJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc3QnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnb3V0cHV0Q29uZmlnJ10sIGJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleCh0QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoJywgJ2lucHV0Q29uZmlnJ10sIGJhdGNoSm9iU291cmNlVG9NbGRldihhcGlDbGllbnQsIHRCYXRjaEpvYlNvdXJjZShhcGlDbGllbnQsIGZyb21TcmMpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lucHV0Q29uZmlnJ10sIGJhdGNoSm9iU291cmNlVG9WZXJ0ZXgodEJhdGNoSm9iU291cmNlKGFwaUNsaWVudCwgZnJvbVNyYykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmF0Y2gnLCAnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3JjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcmMnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaCcsICdpbnB1dENvbmZpZyddLCBlbWJlZGRpbmdzQmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbVNyYykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJlc291cmNlSm9iRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJlc291cmNlSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRCYXRjaFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzRm9yRW1iZWQoYXBpQ2xpZW50LCBmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3JlcXVlc3QnLCAnY29udGVudCddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfc2VsZiddLCBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2JDEoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICAgICAgbW92ZVZhbHVlQnlQYXRoKHRvT2JqZWN0LCB7ICdyZXF1ZXN0c1tdLionOiAncmVxdWVzdHNbXS5yZXF1ZXN0LionIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0YXNrVHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW1lVHlwZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dG9UcnVuY2F0ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZGRpbmdzQmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKTtcbiAgICBpZiAoZnJvbUZpbGVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZV9uYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkUmVxdWVzdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmxpbmVkUmVxdWVzdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5saW5lZFJlcXVlc3RzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHMnXSwgZW1iZWRDb250ZW50QmF0Y2hUb01sZGV2KGFwaUNsaWVudCwgZnJvbUlubGluZWRSZXF1ZXN0cykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRpYWxBcmdzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0aWFsQXJncyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3aWxsQ29udGludWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpbGxDb250aW51ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQ0KHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgdFNjaGVtYShmcm9tUmVzcG9uc2VTY2hlbWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdXRpbmdDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxTZWxlY3Rpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsU2VsZWN0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQ0KHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldiQyKGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DYWNoZWRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NhY2hlZENvbnRlbnQnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbUNhY2hlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgdFNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdWRpb1RpbWVzdGFtcCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21JbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10sIGltYWdlQ29uZmlnVG9NbGRldiQxKGZyb21JbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVFbmhhbmNlZENpdmljQW5zd2VycycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzJ10sIGZyb21FbmFibGVFbmhhbmNlZENpdmljQW5zd2Vycyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVGcm9tTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10pO1xuICAgIGlmIChmcm9tTW9kZWxWZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10sIGZyb21Nb2RlbFZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0RmVlZGJhY2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRGZWVkYmFjaycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRGZWVkYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdEZlZWRiYWNrJ10sIGZyb21Qcm9tcHRGZWVkYmFjayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZUlkJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSwgZnJvbVJlc3BvbnNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVXaWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddKTtcbiAgICBpZiAoZnJvbUVuYWJsZVdpZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddLCBmcm9tRW5hYmxlV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydibG9ja2luZ0NvbmZpZGVuY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NraW5nQ29uZmlkZW5jZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBmcm9tVGltZVJhbmdlRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAoZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwZXJzb25HZW5lcmF0aW9uJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwZXJzb25HZW5lcmF0aW9uIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dE1pbWVUeXBlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRNaW1lVHlwZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbmxpbmVkUmVxdWVzdFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0JywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkNChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnLCAnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYkMShhcGlDbGllbnQsIGZyb21Db25maWcsIGdldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnXSwge30pKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGlubGluZWRSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiQxKGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdEJhdGNoSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RCYXRjaEpvYnNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhdGNoSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3BlcmF0aW9ucyddKTtcbiAgICBpZiAoZnJvbUJhdGNoSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQmF0Y2hKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoSm9iRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2hKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXRjaEpvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiYXRjaFByZWRpY3Rpb25Kb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJhdGNoSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQmF0Y2hKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoSm9iRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQ0KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldiQ0KGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQ0KGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5U2V0dGluZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcnkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhdGVnb3J5J10pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcnkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yeSddLCBmcm9tQ2F0ZWdvcnkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRob2QnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aHJlc2hvbGQnXSk7XG4gICAgaWYgKGZyb21UaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aHJlc2hvbGQnXSwgZnJvbVRocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgZnJvbVJldHJpZXZhbENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMihmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVNlYXJjaCddLCBmcm9tRmlsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb01sZGV2JDQoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYkNChmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG52YXIgUGFnZWRJdGVtO1xuKGZ1bmN0aW9uIChQYWdlZEl0ZW0pIHtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0JBVENIX0pPQlNcIl0gPSBcImJhdGNoSm9ic1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fTU9ERUxTXCJdID0gXCJtb2RlbHNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX1RVTklOR19KT0JTXCJdID0gXCJ0dW5pbmdKb2JzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9GSUxFU1wiXSA9IFwiZmlsZXNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UU1wiXSA9IFwiY2FjaGVkQ29udGVudHNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0ZJTEVfU0VBUkNIX1NUT1JFU1wiXSA9IFwiZmlsZVNlYXJjaFN0b3Jlc1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fRE9DVU1FTlRTXCJdID0gXCJkb2N1bWVudHNcIjtcbn0pKFBhZ2VkSXRlbSB8fCAoUGFnZWRJdGVtID0ge30pKTtcbi8qKlxuICogUGFnZXIgY2xhc3MgZm9yIGl0ZXJhdGluZyB0aHJvdWdoIHBhZ2luYXRlZCByZXN1bHRzLlxuICovXG5jbGFzcyBQYWdlciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcmVxdWVzdCwgcmVzcG9uc2UsIHBhcmFtcykge1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbCA9IFtdO1xuICAgICAgICB0aGlzLnBhcmFtc0ludGVybmFsID0ge307XG4gICAgICAgIHRoaXMucmVxdWVzdEludGVybmFsID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5pbml0KG5hbWUsIHJlc3BvbnNlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBpbml0KG5hbWUsIHJlc3BvbnNlLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5uYW1lSW50ZXJuYWwgPSBuYW1lO1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbCA9IHJlc3BvbnNlW3RoaXMubmFtZUludGVybmFsXSB8fCBbXTtcbiAgICAgICAgdGhpcy5zZGtIdHRwUmVzcG9uc2VJbnRlcm5hbCA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuaWR4SW50ZXJuYWwgPSAwO1xuICAgICAgICBsZXQgcmVxdWVzdFBhcmFtcyA9IHsgY29uZmlnOiB7fSB9O1xuICAgICAgICBpZiAoIXBhcmFtcyB8fCBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHsgY29uZmlnOiB7fSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zWydjb25maWcnXVsncGFnZVRva2VuJ10gPSByZXNwb25zZVsnbmV4dFBhZ2VUb2tlbiddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyYW1zSW50ZXJuYWwgPSByZXF1ZXN0UGFyYW1zO1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbFNpemUgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gcmVxdWVzdFBhcmFtc1snY29uZmlnJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsncGFnZVNpemUnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5wYWdlSW50ZXJuYWwubGVuZ3RoO1xuICAgIH1cbiAgICBpbml0TmV4dFBhZ2UocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5pbml0KHRoaXMubmFtZUludGVybmFsLCByZXNwb25zZSwgdGhpcy5wYXJhbXNJbnRlcm5hbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGFnZSwgd2hpY2ggaXMgYSBsaXN0IG9mIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZmlyc3QgcGFnZSBpcyByZXRyaWV2ZWQgd2hlbiB0aGUgcGFnZXIgaXMgY3JlYXRlZC4gVGhlIHJldHVybmVkIGxpc3Qgb2ZcbiAgICAgKiBpdGVtcyBjb3VsZCBiZSBhIHN1YnNldCBvZiB0aGUgZW50aXJlIGxpc3QuXG4gICAgICovXG4gICAgZ2V0IHBhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBwYWdlZCBpdGVtIChmb3IgZXhhbXBsZSwgYGBiYXRjaF9qb2JzYGApLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgcGFnZSBmZXRjaGVkIGVhY2ggdGltZSBieSB0aGlzIHBhZ2VyLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBwYWdlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGFnZSBsZW5ndGguXG4gICAgICovXG4gICAgZ2V0IHBhZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWxTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWFkZXJzIG9mIHRoZSBBUEkgcmVzcG9uc2UuXG4gICAgICovXG4gICAgZ2V0IHNka0h0dHBSZXNwb25zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2RrSHR0cFJlc3BvbnNlSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmFtZXRlcnMgd2hlbiBtYWtpbmcgdGhlIEFQSSByZXF1ZXN0IGZvciB0aGUgbmV4dCBwYWdlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBQYXJhbWV0ZXJzIGNvbnRhaW4gYSBzZXQgb2Ygb3B0aW9uYWwgY29uZmlncyB0aGF0IGNhbiBiZVxuICAgICAqIHVzZWQgdG8gY3VzdG9taXplIHRoZSBBUEkgcmVxdWVzdC4gRm9yIGV4YW1wbGUsIHRoZSBgcGFnZVRva2VuYCBwYXJhbWV0ZXJcbiAgICAgKiBjb250YWlucyB0aGUgdG9rZW4gdG8gcmVxdWVzdCB0aGUgbmV4dCBwYWdlLlxuICAgICAqL1xuICAgIGdldCBwYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtc0ludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGN1cnJlbnQgcGFnZS5cbiAgICAgKi9cbiAgICBnZXQgcGFnZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXRlbSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0SXRlbShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWxbaW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yIHRoYXQgc3VwcG9ydCBpdGVyYXRpbmcgdGhyb3VnaCBhbGwgaXRlbXNcbiAgICAgKiByZXRyaWV2ZWQgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgaXRlcmF0b3Igd2lsbCBhdXRvbWF0aWNhbGx5IGZldGNoIHRoZSBuZXh0IHBhZ2UgaWYgdGhlcmUgYXJlIG1vcmUgaXRlbXNcbiAgICAgKiB0byBmZXRjaCBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBwYWdlciA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzoge3BhZ2VTaXplOiAxMH19KTtcbiAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgcGFnZXIpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWR4SW50ZXJuYWwgPj0gdGhpcy5wYWdlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubmV4dFBhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5nZXRJdGVtKHRoaXMuaWR4SW50ZXJuYWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuaWR4SW50ZXJuYWwgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBuZXh0IHBhZ2Ugb2YgaXRlbXMuIFRoaXMgbWFrZXMgYSBuZXcgQVBJIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgYXJlIG5vIG1vcmUgcGFnZXMgdG8gZmV0Y2guXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBwYWdlciA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzoge3BhZ2VTaXplOiAxMH19KTtcbiAgICAgKiBsZXQgcGFnZSA9IHBhZ2VyLnBhZ2U7XG4gICAgICogd2hpbGUgKHRydWUpIHtcbiAgICAgKiAgIGZvciAoY29uc3QgZmlsZSBvZiBwYWdlKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogICB9XG4gICAgICogICBpZiAoIXBhZ2VyLmhhc05leHRQYWdlKCkpIHtcbiAgICAgKiAgICAgYnJlYWs7XG4gICAgICogICB9XG4gICAgICogICBwYWdlID0gYXdhaXQgcGFnZXIubmV4dFBhZ2UoKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgbmV4dFBhZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1vcmUgcGFnZXMgdG8gZmV0Y2guJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3RJbnRlcm5hbCh0aGlzLnBhcmFtcyk7XG4gICAgICAgIHRoaXMuaW5pdE5leHRQYWdlKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBtb3JlIHBhZ2VzIHRvIGZldGNoIGZyb20gdGhlIEFQSS5cbiAgICAgKi9cbiAgICBoYXNOZXh0UGFnZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMucGFyYW1zWydjb25maWcnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWydwYWdlVG9rZW4nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQmF0Y2hlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGJhdGNoIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiAtIEEgcGFnZXIgb2YgYmF0Y2ggam9icy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgYmF0Y2hKb2JzID0gYXdhaXQgYWkuYmF0Y2hlcy5saXN0KHtjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoSm9iIG9mIGJhdGNoSm9icykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGJhdGNoSm9iKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9CQVRDSF9KT0JTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuYmF0Y2hlcy5jcmVhdGUoe1xuICAgICAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICAgICAqICAgc3JjOiB7Z2NzVXJpOiAnZ3M6Ly9idWNrZXQvcGF0aC90by9maWxlLmpzb25sJywgZm9ybWF0OiAnanNvbmwnfSxcbiAgICAgICAgICogICBjb25maWc6IHtcbiAgICAgICAgICogICAgIGRlc3Q6IHtnY3NVcmk6ICdnczovL2J1Y2tldC9wYXRoL291dHB1dC9kaXJlY3RvcnknLCBmb3JtYXQ6ICdqc29ubCd9LFxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgZGVzdGluYXRpb24gaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgLy8gQ2FzdCBwYXJhbXMuc3JjIGFzIFZlcnRleCBBSSBwYXRoIGRvZXMgbm90IGhhbmRsZSBJbmxpbmVkUmVxdWVzdFtdXG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZyA9IHRoaXMuZm9ybWF0RGVzdGluYXRpb24ocGFyYW1zLnNyYywgcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogKipFeHBlcmltZW50YWwqKiBDcmVhdGVzIGFuIGVtYmVkZGluZyBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGVtYmVkZGluZyBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuYmF0Y2hlcy5jcmVhdGVFbWJlZGRpbmdzKHtcbiAgICAgICAgICogICBtb2RlbDogJ3RleHQtZW1iZWRkaW5nLTAwNCcsXG4gICAgICAgICAqICAgc3JjOiB7ZmlsZU5hbWU6ICdmaWxlcy9teV9lbWJlZGRpbmdfaW5wdXQnfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUVtYmVkZGluZ3MgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2JhdGNoZXMuY3JlYXRlRW1iZWRkaW5ncygpIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSB3aXRob3V0IG5vdGljZS4nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBBSSBkb2VzIG5vdCBzdXBwb3J0IGJhdGNoZXMuY3JlYXRlRW1iZWRkaW5ncy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVtYmVkZGluZ3NJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gaGFuZGxlIGlubGluZWQgZ2VuZXJhdGUgY29udGVudCByZXF1ZXN0c1xuICAgIGNyZWF0ZUlubGluZWRHZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgLy8gVXNlIGluc3RhbmNlIGFwaUNsaWVudFxuICAgICAgICBwYXJhbXMpO1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBib2R5WydfdXJsJ107XG4gICAgICAgIGNvbnN0IHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hHZW5lcmF0ZUNvbnRlbnQnLCB1cmxQYXJhbXMpO1xuICAgICAgICBjb25zdCBiYXRjaCA9IGJvZHlbJ2JhdGNoJ107XG4gICAgICAgIGNvbnN0IGlucHV0Q29uZmlnID0gYmF0Y2hbJ2lucHV0Q29uZmlnJ107XG4gICAgICAgIGNvbnN0IHJlcXVlc3RzV3JhcHBlciA9IGlucHV0Q29uZmlnWydyZXF1ZXN0cyddO1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IHJlcXVlc3RzV3JhcHBlclsncmVxdWVzdHMnXTtcbiAgICAgICAgY29uc3QgbmV3UmVxdWVzdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0RGljdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpOyAvLyBDbG9uZVxuICAgICAgICAgICAgaWYgKHJlcXVlc3REaWN0WydzeXN0ZW1JbnN0cnVjdGlvbiddKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3lzdGVtSW5zdHJ1Y3Rpb25WYWx1ZSA9IHJlcXVlc3REaWN0WydzeXN0ZW1JbnN0cnVjdGlvbiddO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0Q29udGVudCA9IHJlcXVlc3REaWN0WydyZXF1ZXN0J107XG4gICAgICAgICAgICAgICAgcmVxdWVzdENvbnRlbnRbJ3N5c3RlbUluc3RydWN0aW9uJ10gPSBzeXN0ZW1JbnN0cnVjdGlvblZhbHVlO1xuICAgICAgICAgICAgICAgIHJlcXVlc3REaWN0WydyZXF1ZXN0J10gPSByZXF1ZXN0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1JlcXVlc3RzLnB1c2gocmVxdWVzdERpY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RzV3JhcHBlclsncmVxdWVzdHMnXSA9IG5ld1JlcXVlc3RzO1xuICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgcmV0dXJuIHsgcGF0aCwgYm9keSB9O1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBmaXJzdCBHQ1MgVVJJXG4gICAgZ2V0R2NzVXJpKHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuc3RhcnRzV2l0aCgnZ3M6Ly8nKSA/IHNyYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSAmJiBzcmMuZ2NzVXJpICYmIHNyYy5nY3NVcmkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5nY3NVcmlbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgQmlnUXVlcnkgVVJJXG4gICAgZ2V0QmlncXVlcnlVcmkoc3JjKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5zdGFydHNXaXRoKCdicTovLycpID8gc3JjIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLmJpZ3F1ZXJ5VXJpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEZ1bmN0aW9uIHRvIGZvcm1hdCB0aGUgZGVzdGluYXRpb24gY29uZmlndXJhdGlvbiBmb3IgVmVydGV4IEFJXG4gICAgZm9ybWF0RGVzdGluYXRpb24oc3JjLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgbmV3Q29uZmlnID0gY29uZmlnID8gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSA6IHt9O1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBTdHIgPSBEYXRlLm5vdygpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghbmV3Q29uZmlnLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICBuZXdDb25maWcuZGlzcGxheU5hbWUgPSBgZ2VuYWlCYXRjaEpvYl8ke3RpbWVzdGFtcFN0cn1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDb25maWcuZGVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBnY3NVcmkgPSB0aGlzLmdldEdjc1VyaShzcmMpO1xuICAgICAgICAgICAgY29uc3QgYmlncXVlcnlVcmkgPSB0aGlzLmdldEJpZ3F1ZXJ5VXJpKHNyYyk7XG4gICAgICAgICAgICBpZiAoZ2NzVXJpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdjc1VyaS5lbmRzV2l0aCgnLmpzb25sJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIC5qc29ubCBmaWxlcywgcmVtb3ZlIHN1ZmZpeCBhbmQgYWRkIC9kZXN0XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5kZXN0ID0gYCR7Z2NzVXJpLnNsaWNlKDAsIC02KX0vZGVzdGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBmb3Igb3RoZXIgR0NTIFVSSXNcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29uZmlnLmRlc3QgPSBgJHtnY3NVcml9X2Rlc3RfJHt0aW1lc3RhbXBTdHJ9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaWdxdWVyeVVyaSkge1xuICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5kZXN0ID0gYCR7YmlncXVlcnlVcml9X2Rlc3RfJHt0aW1lc3RhbXBTdHJ9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc291cmNlIGZvciBWZXJ0ZXggQUk6IE5vIEdDUyBvciBCaWdRdWVyeSBVUkkgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0NvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpiYXRjaEdlbmVyYXRlQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVtYmVkZGluZ3NJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmFzeW5jQmF0Y2hFbWJlZENvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYmF0Y2ggam9iIGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuZ2V0KHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjYW5jZWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuY2FuY2VsKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icy97bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzL3tuYW1lfTpjYW5jZWwnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RCYXRjaEpvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuYmF0Y2hlcy5kZWxldGUoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVSZXNvdXJjZUpvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVSZXNvdXJjZUpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYmxvYlRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYkMyh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldiQxKGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ttc0tleU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ttc0tleU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgdENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgZnJvbVRvb2xDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tS21zS2V5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsna21zS2V5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUttc0tleU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZW5jcnlwdGlvbl9zcGVjJywgJ2ttc0tleU5hbWUnXSwgZnJvbUttc0tleU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0Q2FjaGVzTW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdENhY2hlc01vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0aWFsQXJncyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGlhbEFyZ3MgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2lsbENvbnRpbnVlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aWxsQ29udGludWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlaGF2aW9yIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVXaWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddKTtcbiAgICBpZiAoZnJvbUVuYWJsZVdpZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddLCBmcm9tRW5hYmxlV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydibG9ja2luZ0NvbmZpZGVuY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NraW5nQ29uZmlkZW5jZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBmcm9tVGltZVJhbmdlRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVkQ29udGVudHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhY2hlZENvbnRlbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQzKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldiQzKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQzKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCBmcm9tUmV0cmlldmFsQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQxKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlU2VhcmNoJ10sIGZyb21GaWxlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYkMyhmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQzKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VudGVycHJpc2VXZWJTZWFyY2gnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSwgZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGZyb21Hb29nbGVNYXBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGZyb21Hb29nbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBDYWNoZXMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBjYWNoZWQgY29udGVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiAtIEEgcGFnZXIgb2YgY2FjaGVkIGNvbnRlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBjYWNoZWRDb250ZW50cyA9IGF3YWl0IGFpLmNhY2hlcy5saXN0KHtjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNhY2hlZENvbnRlbnQgb2YgY2FjaGVkQ29udGVudHMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhjYWNoZWRDb250ZW50KTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9DQUNIRURfQ09OVEVOVFMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhY2hlZCBjb250ZW50cyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQ29udGV4dCBjYWNoaW5nIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBzcGVjaWZpYyBtb2RlbHMuIFNlZSBbR2VtaW5pXG4gICAgICogRGV2ZWxvcGVyIEFQSSByZWZlcmVuY2VdKGh0dHBzOi8vYWkuZ29vZ2xlLmRldi9nZW1pbmktYXBpL2RvY3MvY2FjaGluZz9sYW5nPW5vZGUvY29udGV4dC1jYWMpXG4gICAgICogYW5kIFtWZXJ0ZXggQUkgcmVmZXJlbmNlXShodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2dlbmVyYXRpdmUtYWkvZG9jcy9jb250ZXh0LWNhY2hlL2NvbnRleHQtY2FjaGUtb3ZlcnZpZXcjc3VwcG9ydGVkX21vZGVscylcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNyZWF0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgY2FjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY29udGVudHMgPSAuLi47IC8vIEluaXRpYWxpemUgdGhlIGNvbnRlbnQgdG8gY2FjaGUuXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5jYWNoZXMuY3JlYXRlKHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgJ2NvbnRlbnRzJzogY29udGVudHMsXG4gICAgICogICAgJ2Rpc3BsYXlOYW1lJzogJ3Rlc3QgY2FjaGUnLFxuICAgICAqICAgICdzeXN0ZW1JbnN0cnVjdGlvbic6ICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIHR3byBwZGZzPycsXG4gICAgICogICAgJ3R0bCc6ICc4NjQwMHMnLFxuICAgICAqICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhY2hlZCBjb250ZW50IGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY2FjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuY2FjaGVzLmdldCh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2FjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkZWxldGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmNhY2hlcy5kZWxldGUoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjYWNoZWQgY29udGVudCBjb25maWd1cmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHVwZGF0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgY2FjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5jYWNoZXMudXBkYXRlKHtcbiAgICAgKiAgIG5hbWU6ICcuLi4nLCAgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiAgIGNvbmZpZzogeyd0dGwnOiAnNzYwMHMnfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wsIEl0ZXJhdG9yICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlc3BvbnNlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAocmVzcG9uc2UuY2FuZGlkYXRlcyA9PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UuY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gKF9hID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkQ29udGVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudC5wYXJ0cyA9PT0gdW5kZWZpbmVkIHx8IGNvbnRlbnQucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQucGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnQgPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhwYXJ0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBoaXN0b3J5IGNvbnRhaW5zIHRoZSBjb3JyZWN0IHJvbGVzLlxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHVzZXIgdHVybi5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgY29udGFpbnMgYW4gaW52YWxpZCByb2xlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSkge1xuICAgIC8vIEVtcHR5IGhpc3RvcnkgaXMgdmFsaWQuXG4gICAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250ZW50IG9mIGhpc3RvcnkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQucm9sZSAhPT0gJ3VzZXInICYmIGNvbnRlbnQucm9sZSAhPT0gJ21vZGVsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb2xlIG11c3QgYmUgdXNlciBvciBtb2RlbCwgYnV0IGdvdCAke2NvbnRlbnQucm9sZX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBjdXJhdGVkICh2YWxpZCkgaGlzdG9yeSBmcm9tIGEgY29tcHJlaGVuc2l2ZSBoaXN0b3J5LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgbW9kZWwgbWF5IHNvbWV0aW1lcyBnZW5lcmF0ZSBpbnZhbGlkIG9yIGVtcHR5IGNvbnRlbnRzKGUuZy4sIGR1ZSB0byBzYWZ0eVxuICogZmlsdGVycyBvciByZWNpdGF0aW9uKS4gRXh0cmFjdGluZyB2YWxpZCB0dXJucyBmcm9tIHRoZSBoaXN0b3J5XG4gKiBlbnN1cmVzIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBjb3VsZCBiZSBhY2NwZXRlZCBieSB0aGUgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDdXJhdGVkSGlzdG9yeShjb21wcmVoZW5zaXZlSGlzdG9yeSkge1xuICAgIGlmIChjb21wcmVoZW5zaXZlSGlzdG9yeSA9PT0gdW5kZWZpbmVkIHx8IGNvbXByZWhlbnNpdmVIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGN1cmF0ZWRIaXN0b3J5ID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0ucm9sZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wdXNoKGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gW107XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCAmJiBjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxPdXRwdXQucHVzaChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgJiYgIWlzVmFsaWRDb250ZW50KGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY3VyYXRlZEhpc3RvcnkucHVzaCguLi5tb2RlbE91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgdXNlciBpbnB1dCB3aGVuIG1vZGVsIGNvbnRlbnQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VyYXRlZEhpc3Rvcnk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBjcmVhdGUgYSBjaGF0IHNlc3Npb24uXG4gKi9cbmNsYXNzIENoYXRzIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbHNNb2R1bGUsIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgY29uZmlnIGluIHRoZSBwYXJhbXMgd2lsbCBiZSB1c2VkIGZvciBhbGwgcmVxdWVzdHMgd2l0aGluIHRoZSBjaGF0XG4gICAgICogc2Vzc2lvbiB1bmxlc3Mgb3ZlcnJpZGRlbiBieSBhIHBlci1yZXF1ZXN0IGBjb25maWdgIGluXG4gICAgICogQHNlZSB7QGxpbmsgdHlwZXMuU2VuZE1lc3NhZ2VQYXJhbWV0ZXJzI2NvbmZpZ30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNoYXQgPSBhaS5jaGF0cy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRlbXBlcmF0dXJlOiAwLjUsXG4gICAgICogICAgIG1heE91dHB1dFRva2VuczogMTAyNCxcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdCh0aGlzLmFwaUNsaWVudCwgdGhpcy5tb2RlbHNNb2R1bGUsIHBhcmFtcy5tb2RlbCwgcGFyYW1zLmNvbmZpZywgXG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHN0cnVjdHVyZWRDbG9uZShwYXJhbXMuaGlzdG9yeSkpO1xuICAgIH1cbn1cbi8qKlxuICogQ2hhdCBzZXNzaW9uIHRoYXQgZW5hYmxlcyBzZW5kaW5nIG1lc3NhZ2VzIHRvIHRoZSBtb2RlbCB3aXRoIHByZXZpb3VzXG4gKiBjb252ZXJzYXRpb24gY29udGV4dC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHNlc3Npb24gbWFpbnRhaW5zIGFsbCB0aGUgdHVybnMgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAqL1xuY2xhc3MgQ2hhdCB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBtb2RlbHNNb2R1bGUsIG1vZGVsLCBjb25maWcgPSB7fSwgaGlzdG9yeSA9IFtdKSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICAgICAgLy8gQSBwcm9taXNlIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgbWVzc2FnZSBiZWluZyBzZW50IHRvIHRoZVxuICAgICAgICAvLyBtb2RlbC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlU3RyZWFtfSBmb3Igc3RyZWFtaW5nIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gcGFyYW1ldGVycyBmb3Igc2VuZGluZyBtZXNzYWdlcyB3aXRoaW4gYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSAoX2IgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgQUZDIGlucHV0IGNvbnRhaW5zIHRoZSBlbnRpcmUgY3VyYXRlZCBjaGF0IGhpc3RvcnkgaW5cbiAgICAgICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBuZXcgdXNlciBpbnB1dCwgd2UgbmVlZCB0byB0cnVuY2F0ZSB0aGUgQUZDIGhpc3RvcnlcbiAgICAgICAgICAgIC8vIHRvIGRlZHVwbGljYXRlIHRoZSBleGlzdGluZyBjaGF0IGhpc3RvcnkuXG4gICAgICAgICAgICBjb25zdCBmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IHJlc3BvbnNlLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SGlzdG9yeSh0cnVlKS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgaWYgKGZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgKF9jID0gZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnkuc2xpY2UoaW5kZXgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gb3V0cHV0Q29udGVudCA/IFtvdXRwdXRDb250ZW50XSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRIaXN0b3J5KGlucHV0Q29udGVudCwgbW9kZWxPdXRwdXQsIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KSgpO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJlc2V0cyBzZW5kUHJvbWlzZSB0byBhdm9pZCBzdWJzZXF1ZW50IGNhbGxzIGZhaWxpbmdcbiAgICAgICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlIGluIGNodW5rcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgbWVzc2FnZSB0byBiZSBwcm9jZXNzZWQgYmVmb3JlXG4gICAgICogc2VuZGluZyB0aGUgbmV4dCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQ2hhdCNzZW5kTWVzc2FnZX0gZm9yIG5vbi1zdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIHRoZSBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZVN0cmVhbSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZSkge1xuICAgICAqICAgY29uc29sZS5sb2coY2h1bmsudGV4dCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFByb21pc2U7XG4gICAgICAgIGNvbnN0IGlucHV0Q29udGVudCA9IHRDb250ZW50KHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtUmVzcG9uc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIGludGVybmFsIHRyYWNraW5nIG9mIHNlbmQgY29tcGxldGlvbiBwcm9taXNlIC0gYHNlbmRQcm9taXNlYFxuICAgICAgICAvLyBmb3IgYm90aCBzdWNjZXNzIGFuZCBmYWlsdXJlIHJlc3BvbnNlLiBUaGUgYWN0dWFsIGZhaWx1cmUgaXMgc3RpbGxcbiAgICAgICAgLy8gcHJvcGFnYXRlZCBieSB0aGUgYGF3YWl0IHN0cmVhbVJlc3BvbnNlYC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IHN0cmVhbVJlc3BvbnNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdHJlYW1SZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UsIGlucHV0Q29udGVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYXQgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGhpc3RvcnkgaXMgYSBsaXN0IG9mIGNvbnRlbnRzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIGhpc3Rvcnk6XG4gICAgICogLSBUaGUgYGN1cmF0ZWQgaGlzdG9yeWAgY29udGFpbnMgb25seSB0aGUgdmFsaWQgdHVybnMgYmV0d2VlbiB1c2VyIGFuZFxuICAgICAqIG1vZGVsLCB3aGljaCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3RzIHNlbnQgdG8gdGhlIG1vZGVsLlxuICAgICAqIC0gVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGNvbnRhaW5zIGFsbCB0dXJucywgaW5jbHVkaW5nIGludmFsaWQgb3JcbiAgICAgKiAgIGVtcHR5IG1vZGVsIG91dHB1dHMsIHByb3ZpZGluZyBhIGNvbXBsZXRlIHJlY29yZCBvZiB0aGUgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIFRoZSBoaXN0b3J5IGlzIHVwZGF0ZWQgYWZ0ZXIgcmVjZWl2aW5nIHRoZSByZXNwb25zZSBmcm9tIHRoZSBtb2RlbCxcbiAgICAgKiBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlLCBpdCBtZWFucyByZWNlaXZpbmcgdGhlIGxhc3QgY2h1bmsgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGlzIHJldHVybmVkIGJ5IGRlZmF1bHQuIFRvIGdldCB0aGUgYGN1cmF0ZWRcbiAgICAgKiBoaXN0b3J5YCwgc2V0IHRoZSBgY3VyYXRlZGAgcGFyYW1ldGVyIHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJhdGVkIC0gd2hldGhlciB0byByZXR1cm4gdGhlIGN1cmF0ZWQgaGlzdG9yeSBvciB0aGUgY29tcHJlaGVuc2l2ZVxuICAgICAqICAgICBoaXN0b3J5LlxuICAgICAqIEByZXR1cm4gSGlzdG9yeSBjb250ZW50cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsIGZvciB0aGUgZW50aXJlXG4gICAgICogICAgIGNoYXQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBnZXRIaXN0b3J5KGN1cmF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0gY3VyYXRlZFxuICAgICAgICAgICAgPyBleHRyYWN0Q3VyYXRlZEhpc3RvcnkodGhpcy5oaXN0b3J5KVxuICAgICAgICAgICAgOiB0aGlzLmhpc3Rvcnk7XG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUoaGlzdG9yeSk7XG4gICAgfVxuICAgIHByb2Nlc3NTdHJlYW1SZXNwb25zZShzdHJlYW1SZXNwb25zZSwgaW5wdXRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHByb2Nlc3NTdHJlYW1SZXNwb25zZV8xKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgICAgIHZhciBfZCwgX2U7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRDb250ZW50ID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgc3RyZWFtUmVzcG9uc2VfMSA9IF9fYXN5bmNWYWx1ZXMoc3RyZWFtUmVzcG9uc2UpLCBzdHJlYW1SZXNwb25zZV8xXzE7IHN0cmVhbVJlc3BvbnNlXzFfMSA9IHlpZWxkIF9fYXdhaXQoc3RyZWFtUmVzcG9uc2VfMS5uZXh0KCkpLCBfYSA9IHN0cmVhbVJlc3BvbnNlXzFfMS5kb25lLCAhX2E7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IHN0cmVhbVJlc3BvbnNlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRSZXNwb25zZShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoX2UgPSAoX2QgPSBjaHVuay5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RbMF0pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dENvbnRlbnQucHVzaChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gc3RyZWFtUmVzcG9uc2VfMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoc3RyZWFtUmVzcG9uc2VfMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlY29yZEhpc3RvcnkoaW5wdXRDb250ZW50LCBvdXRwdXRDb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlY29yZEhpc3RvcnkodXNlcklucHV0LCBtb2RlbE91dHB1dCwgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSkge1xuICAgICAgICBsZXQgb3V0cHV0Q29udGVudHMgPSBbXTtcbiAgICAgICAgaWYgKG1vZGVsT3V0cHV0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIG1vZGVsT3V0cHV0LmV2ZXJ5KChjb250ZW50KSA9PiBjb250ZW50LnJvbGUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIG91dHB1dENvbnRlbnRzID0gbW9kZWxPdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBcHBlbmRzIGFuIGVtcHR5IGNvbnRlbnQgd2hlbiBtb2RlbCByZXR1cm5zIGVtcHR5IHJlc3BvbnNlLCBzbyB0aGF0IHRoZVxuICAgICAgICAgICAgLy8gaGlzdG9yeSBpcyBhbHdheXMgYWx0ZXJuYXRpbmcgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAgICAgICAgICAgIG91dHB1dENvbnRlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJvbGU6ICdtb2RlbCcsXG4gICAgICAgICAgICAgICAgcGFydHM6IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgJiZcbiAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2goLi4uZXh0cmFjdEN1cmF0ZWRIaXN0b3J5KGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKHVzZXJJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2goLi4ub3V0cHV0Q29udGVudHMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBBUEkgZXJyb3JzIHJhaXNlZCBieSB0aGUgR2VuQUkgQVBJLlxuICovXG5jbGFzcyBBcGlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBcGlFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBBcGlFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIEdvb2dsZSBHZW4gQUkgU0RLIGdlbmVyYXRvciBETyBOT1QgRURJVC5cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZSddKTtcbiAgICBpZiAoZnJvbUZpbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlJ10sIGZyb21GaWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdmaWxlJ10sIHRGaWxlTmFtZShmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEZpbGVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGUnXSwgdEZpbGVOYW1lKGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZXNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0RmlsZXNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZXMnXSk7XG4gICAgaWYgKGZyb21GaWxlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRmlsZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgRmlsZXMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBmaWxlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiBmaWxlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgZmlsZXMgPSBhd2FpdCBhaS5maWxlcy5saXN0KHtjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhmaWxlKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9GSUxFUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byB0aGUgR2VtaW5pIEFQSS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIGluIFZlcnRleCBBSS5cbiAgICAgKiBTdXBwb3J0ZWQgdXBsb2FkIHNvdXJjZXM6XG4gICAgICogLSBOb2RlLmpzOiBGaWxlIHBhdGggKHN0cmluZykgb3IgQmxvYiBvYmplY3QuXG4gICAgICogLSBCcm93c2VyOiBCbG9iIG9iamVjdCAoZS5nLiwgRmlsZSkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBgbWltZVR5cGVgIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIGBjb25maWdgIHBhcmFtZXRlci4gSWYgb21pdHRlZDpcbiAgICAgKiAgLSBGb3IgZmlsZSBwYXRoIChzdHJpbmcpIGlucHV0cywgdGhlIGBtaW1lVHlwZWAgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZVxuICAgICAqICAgICBmaWxlIGV4dGVuc2lvbi5cbiAgICAgKiAgLSBGb3IgQmxvYiBvYmplY3QgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIHNldCB0byB0aGUgQmxvYidzIGB0eXBlYFxuICAgICAqICAgICBwcm9wZXJ0eS5cbiAgICAgKiBTb21leCBlYW1wbGVzIGZvciBmaWxlIGV4dGVuc2lvbiB0byBtaW1lVHlwZSBtYXBwaW5nOlxuICAgICAqIC50eHQgLT4gdGV4dC9wbGFpblxuICAgICAqIC5qc29uIC0+IGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAuanBnICAtPiBpbWFnZS9qcGVnXG4gICAgICogLnBuZyAtPiBpbWFnZS9wbmdcbiAgICAgKiAubXAzIC0+IGF1ZGlvL21wZWdcbiAgICAgKiAubXA0IC0+IHZpZGVvL21wNFxuICAgICAqXG4gICAgICogVGhpcyBzZWN0aW9uIGNhbiBjb250YWluIG11bHRpcGxlIHBhcmFncmFwaHMgYW5kIGNvZGUgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlXG4gICAgICogICAgICAgIGB0eXBlcy5VcGxvYWRGaWxlUGFyYW1ldGVyc2AgaW50ZXJmYWNlLlxuICAgICAqICAgICAgICAgQHNlZSB7QGxpbmsgdHlwZXMuVXBsb2FkRmlsZVBhcmFtZXRlcnMjY29uZmlnfSBmb3IgdGhlIG9wdGlvbmFsXG4gICAgICogICAgICAgICBjb25maWcgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGB0eXBlcy5GaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqIHRoZSBgbWltZVR5cGVgIGNhbiBiZSBwcm92aWRlZCBpbiB0aGUgYHBhcmFtcy5jb25maWdgIHBhcmFtZXRlci5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIG9jY3VycyBpZiBhIHN1aXRhYmxlIHVwbG9hZCBsb2NhdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSB1cGxvYWRzIGEgZmlsZSB0byBHZW1pbmkgQVBJLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBmaWxlID0gYXdhaXQgYWkuZmlsZXMudXBsb2FkKHtmaWxlOiAnZmlsZS50eHQnLCBjb25maWc6IHtcbiAgICAgKiAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICogfX0pO1xuICAgICAqIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBBSSBkb2VzIG5vdCBzdXBwb3J0IHVwbG9hZGluZyBmaWxlcy4gWW91IGNhbiBzaGFyZSBmaWxlcyB0aHJvdWdoIGEgR0NTIGJ1Y2tldC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgIC51cGxvYWRGaWxlKHBhcmFtcy5maWxlLCBwYXJhbXMuY29uZmlnKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgcmVtb3RlbHkgc3RvcmVkIGZpbGUgYXN5bmNocm9ub3VzbHkgdG8gYSBsb2NhdGlvbiBzcGVjaWZpZWQgaW5cbiAgICAgKiB0aGUgYHBhcmFtc2Agb2JqZWN0LiBUaGlzIG1ldGhvZCBvbmx5IHdvcmtzIG9uIE5vZGUgZW52aXJvbm1lbnQsIHRvXG4gICAgICogZG93bmxvYWQgZmlsZXMgaW4gdGhlIGJyb3dzZXIsIHVzZSBhIGJyb3dzZXIgY29tcGxpYW50IG1ldGhvZCBsaWtlIGFuIDxhPlxuICAgICAqIHRhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRvd25sb2FkIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBkb3dubG9hZHMgYW4gZXhhbXBsZSBmaWxlIG5hbWVkIFwiZmlsZXMvbWVob3pweGY4NzdkXCIgYXNcbiAgICAgKiBcImZpbGUudHh0XCIuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmZpbGVzLmRvd25sb2FkKHtmaWxlOiBmaWxlLm5hbWUsIGRvd25sb2FkUGF0aDogJ2ZpbGUudHh0J30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRvd25sb2FkKHBhcmFtcykge1xuICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5kb3dubG9hZEZpbGUocGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0RmlsZXNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEZpbGVzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEvZmlsZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNyZWF0ZUZpbGVSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENyZWF0ZUZpbGVSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWxlIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdFxuICAgICAqIEByZXR1cm4gVGhlIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHlwZXMuRmlsZSBvYmplY3QgcmVxdWVzdGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbmZpZzogR2V0RmlsZVBhcmFtZXRlcnMgPSB7XG4gICAgICogICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgKiB9O1xuICAgICAqIGZpbGUgPSBhd2FpdCBhaS5maWxlcy5nZXQoY29uZmlnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlcy97ZmlsZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHJlbW90ZWx5IHN0b3JlZCBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgRGVsZXRlRmlsZVJlc3BvbnNlLCB0aGUgcmVzcG9uc2UgZm9yIHRoZSBkZWxldGUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgZGVsZXRlcyBhbiBleGFtcGxlIGZpbGUgbmFtZWQgXCJmaWxlcy9tZWhvenB4Zjg3N2RcIi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuZmlsZXMuZGVsZXRlKHtuYW1lOiBmaWxlLm5hbWV9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMve2ZpbGV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVGaWxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBibG9iVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0aWFsQXJncyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGlhbEFyZ3MgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2lsbENvbnRpbnVlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aWxsQ29udGludWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmVoYXZpb3IgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0aW9uQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtb2RlbFNlbGVjdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsQ29uZmlnJ10sIGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9UaW1lc3RhbXAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1RpbWVzdGFtcCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1RpbWVzdGFtcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10sIGZyb21BdWRpb1RpbWVzdGFtcCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIGZyb21SZXNwb25zZVNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb3V0aW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncm91dGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Sb3V0aW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm91dGluZ0NvbmZpZyddLCBmcm9tUm91dGluZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgZnJvbVNwZWVjaENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZVdpZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10pO1xuICAgIGlmIChmcm9tRW5hYmxlV2lkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10sIGZyb21FbmFibGVXaWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jsb2NraW5nQ29uZmlkZW5jZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tpbmdDb25maWRlbmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnXSwgZnJvbUdlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzcGVlY2hDb25maWcnXSwgdExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQyKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDIodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiQxKGZyb21TZXNzaW9uUmVzdW1wdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9hY3Rpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvYWN0aXZpdHknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9hY3Rpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdwcm9hY3Rpdml0eSddLCBmcm9tUHJvYWN0aXZpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBsaWNpdFZhZFNpZ25hbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwbGljaXRWYWRTaWduYWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGlvbkNvbmZpZ1RvVmVydGV4JDEoZnJvbUdlbmVyYXRpb25Db25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgdENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgkMSh0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgZnJvbVNlc3Npb25SZXN1bXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlYWx0aW1lSW5wdXRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdyZWFsdGltZUlucHV0Q29uZmlnJ10sIGZyb21SZWFsdGltZUlucHV0Q29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJ10sIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvYWN0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2FjdGl2aXR5J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvYWN0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncHJvYWN0aXZpdHknXSwgZnJvbVByb2FjdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGxpY2l0VmFkU2lnbmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhwbGljaXRWYWRTaWduYWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwbGljaXRWYWRTaWduYWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZXhwbGljaXRWYWRTaWduYWwnXSwgZnJvbUV4cGxpY2l0VmFkU2lnbmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2JDEoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljU2V0Q29uZmlnUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211c2ljR2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXNpY0dlbmVyYXRpb25Db25maWcnXSwgZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21XZWlnaHRlZFByb21wdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd3ZWlnaHRlZFByb21wdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tV2VpZ2h0ZWRQcm9tcHRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21XZWlnaHRlZFByb21wdHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3dlaWdodGVkUHJvbXB0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lZGlhJ10pO1xuICAgIGlmIChmcm9tTWVkaWEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEJsb2JzKGZyb21NZWRpYSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvYlRvTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhQ2h1bmtzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW8nXSk7XG4gICAgaWYgKGZyb21BdWRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvJ10sIGJsb2JUb01sZGV2JDIodEF1ZGlvQmxvYihmcm9tQXVkaW8pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1N0cmVhbUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvU3RyZWFtRW5kJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvU3RyZWFtRW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9TdHJlYW1FbmQnXSwgZnJvbUF1ZGlvU3RyZWFtRW5kKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgYmxvYlRvTWxkZXYkMih0SW1hZ2VCbG9iKGZyb21WaWRlbykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eVN0YXJ0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlTdGFydCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eVN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlTdGFydCddLCBmcm9tQWN0aXZpdHlTdGFydCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10sIGZyb21BY3Rpdml0eUVuZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lZGlhJ10pO1xuICAgIGlmIChmcm9tTWVkaWEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEJsb2JzKGZyb21NZWRpYSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhQ2h1bmtzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW8nXSk7XG4gICAgaWYgKGZyb21BdWRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvJ10sIHRBdWRpb0Jsb2IoZnJvbUF1ZGlvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1N0cmVhbUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvU3RyZWFtRW5kJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvU3RyZWFtRW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9TdHJlYW1FbmQnXSwgZnJvbUF1ZGlvU3RyZWFtRW5kKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdEltYWdlQmxvYihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eVN0YXJ0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlTdGFydCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eVN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlTdGFydCddLCBmcm9tQWN0aXZpdHlTdGFydCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10sIGZyb21BY3Rpdml0eUVuZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2V0dXBDb21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NldHVwQ29tcGxldGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2V0dXBDb21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwQ29tcGxldGUnXSwgZnJvbVNldHVwQ29tcGxldGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmVyQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZlckNvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VydmVyQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZlckNvbnRlbnQnXSwgZnJvbVNlcnZlckNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDYWxsJ10pO1xuICAgIGlmIChmcm9tVG9vbENhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbCddLCBmcm9tVG9vbENhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sQ2FsbENhbmNlbGxhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xDYWxsQ2FuY2VsbGF0aW9uJ10sIGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChmcm9tVXNhZ2VNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29Bd2F5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb0F3YXknXSk7XG4gICAgaWYgKGZyb21Hb0F3YXkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb0F3YXknXSwgZnJvbUdvQXdheSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2Vzc2lvblJlc3VtcHRpb25VcGRhdGUnXSwgZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQWN0aXZpdHlEZXRlY3Rpb25TaWduYWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2b2ljZUFjdGl2aXR5RGV0ZWN0aW9uU2lnbmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZvaWNlQWN0aXZpdHlEZXRlY3Rpb25TaWduYWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUFjdGl2aXR5RGV0ZWN0aW9uU2lnbmFsJ10sIGZyb21Wb2ljZUFjdGl2aXR5RGV0ZWN0aW9uU2lnbmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkMihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMihmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2hhbmRsZSddKTtcbiAgICBpZiAoZnJvbUhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2hhbmRsZSddLCBmcm9tSGFuZGxlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhbnNwYXJlbnQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zcGFyZW50IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVNlYXJjaCddLCBmcm9tRmlsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb01sZGV2JDIoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYkMihmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbnRlcnByaXNlV2ViU2VhcmNoJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10sIGZyb21FbnRlcnByaXNlV2ViU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBmcm9tR29vZ2xlTWFwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBmcm9tR29vZ2xlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdFRva2VuQ291bnQnXSwgZnJvbVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50J10sIGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2VuQ291bnQnXSwgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2VuQ291bnQnXSwgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRzVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0c1Rva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0c1Rva2VuQ291bnQnXSwgZnJvbVRob3VnaHRzVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b3RhbFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbkNvdW50J10sIGZyb21Ub3RhbFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZXNUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhZmZpY1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYWZmaWNUeXBlJ10pO1xuICAgIGlmIChmcm9tVHJhZmZpY1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmFmZmljVHlwZSddLCBmcm9tVHJhZmZpY1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5kaWRhdGVGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnQnXSk7XG4gICAgaWYgKGZyb21Db250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudCddLCBmcm9tQ29udGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaXRhdGlvbk1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2l0YXRpb25NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbk1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25NZXRhZGF0YSddLCBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2KGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5UmF0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2l0YXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaXRhdGlvblNvdXJjZXMnXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNpdGF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbnNJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbnNJbmZvJ10pO1xuICAgIGlmIChmcm9tVG9rZW5zSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9rZW5zSW5mbztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5zSW5mbyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmFsdWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2YWx1ZXMnXSk7XG4gICAgaWYgKGZyb21WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWx1ZXMnXSwgZnJvbVZhbHVlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0aXN0aWNzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0aXN0aWNzJ10pO1xuICAgIGlmIChmcm9tU3RhdGlzdGljcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRpc3RpY3MnXSwgY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4KGZyb21TdGF0aXN0aWNzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHJ1bmNhdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cnVuY2F0ZWQnXSk7XG4gICAgaWYgKGZyb21UcnVuY2F0ZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cnVuY2F0ZWQnXSwgZnJvbVRydW5jYXRlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbl9jb3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udHJvbFJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250cm9sVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udHJvbFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250cm9sVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRyb2xUeXBlJ10sIGZyb21Db250cm9sVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZUNvbnRyb2wnXSwgZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzeXN0ZW1JbnN0cnVjdGlvbiBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9vbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGlvbkNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgdENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGlvbkNvbmZpZ1RvVmVydGV4KGZyb21HZW5lcmF0aW9uQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNvdW50VG9rZW5zQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50J10sIGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVkaXRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRWRpdE1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VkaXRNb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRWRpdE1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0TW9kZSddLCBmcm9tRWRpdE1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVN0ZXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlU3RlcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXNlU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0Q29uZmlnJywgJ2Jhc2VTdGVwcyddLCBmcm9tQmFzZVN0ZXBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlZGl0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXNrVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFza1R5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UYXNrVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3Rhc2tUeXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dERpbWVuc2lvbmFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnb3V0cHV0RGltZW5zaW9uYWxpdHknXSwgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dG9UcnVuY2F0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0b1RydW5jYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhc2tUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXNrVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRhc2tUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ3Rhc2tfdHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0RGltZW5zaW9uYWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXREaW1lbnNpb25hbGl0eSddLCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1dG9UcnVuY2F0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0b1RydW5jYXRlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXV0b1RydW5jYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXV0b1RydW5jYXRlJ10sIGZyb21BdXRvVHJ1bmNhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnY29udGVudCddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHNbXScsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzW10nLCAnY29udGVudCddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBlbWJlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW1iZWRkaW5ncyddKTtcbiAgICBpZiAoZnJvbUVtYmVkZGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUVtYmVkZGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VtYmVkZGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zW10nLFxuICAgICAgICAnZW1iZWRkaW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbWJlZGRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbWJlZGRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbmRwb2ludEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZHBvaW50J10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVwbG95ZWRNb2RlbElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVwbG95ZWRNb2RlbElkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURlcGxveWVkTW9kZWxJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlcGxveWVkTW9kZWxJZCddLCBmcm9tRGVwbG95ZWRNb2RlbElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0aWFsQXJncyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGlhbEFyZ3MgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2lsbENvbnRpbnVlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aWxsQ29udGludWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhbGxvd2VkRnVuY3Rpb25OYW1lcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJ10sIGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmVoYXZpb3IgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQxKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgdFNjaGVtYShmcm9tUmVzcG9uc2VTY2hlbWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdXRpbmdDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxTZWxlY3Rpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsU2VsZWN0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzYWZldHlTZXR0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMSh0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgdG9vbENvbmZpZ1RvTWxkZXYoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCB0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1ZGlvVGltZXN0YW1wIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VDb25maWcnXSwgaW1hZ2VDb25maWdUb01sZGV2KGZyb21JbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVFbmhhbmNlZENpdmljQW5zd2VycycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzJ10sIGZyb21FbmFibGVFbmhhbmNlZENpdmljQW5zd2Vycyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCB0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgdFNjaGVtYShmcm9tUmVzcG9uc2VTY2hlbWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb3V0aW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncm91dGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Sb3V0aW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm91dGluZ0NvbmZpZyddLCBmcm9tUm91dGluZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21vZGVsU2VsZWN0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxDb25maWcnXSwgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleCh0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgZnJvbVRvb2xDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2FjaGVkQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjYWNoZWRDb250ZW50J10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21DYWNoZWRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHRTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9UaW1lc3RhbXAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1RpbWVzdGFtcCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1RpbWVzdGFtcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10sIGZyb21BdWRpb1RpbWVzdGFtcCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VDb25maWcnXSwgaW1hZ2VDb25maWdUb1ZlcnRleChmcm9tSW1hZ2VDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VJZCddLCBmcm9tUmVzcG9uc2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYW5kaWRhdGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VJZCddLCBmcm9tUmVzcG9uc2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0R2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25lZ2F0aXZlUHJvbXB0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWdhdGl2ZVByb21wdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlZWQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUZpbHRlckxldmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5RmlsdGVyTGV2ZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYWZldHlTZXR0aW5nJ10sIGZyb21TYWZldHlGaWx0ZXJMZXZlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnXSwgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVSYWlSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlUmFpUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUluY2x1ZGVSYWlSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlUmFpUmVhc29uJ10sIGZyb21JbmNsdWRlUmFpUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhbmd1YWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbGFuZ3VhZ2UnXSwgZnJvbUxhbmd1YWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkZFdhdGVybWFyayddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkV2F0ZXJtYXJrIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5oYW5jZVByb21wdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW5oYW5jZVByb21wdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVJbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZWaWRlb3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZWaWRlb3MpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dEdjc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZwcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHVyYXRpb25TZWNvbmRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHVyYXRpb25TZWNvbmRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUR1cmF0aW9uU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2R1cmF0aW9uU2Vjb25kcyddLCBmcm9tRHVyYXRpb25TZWNvbmRzKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VlZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb2x1dGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdyZXNvbHV0aW9uJ10sIGZyb21SZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHVic3ViVG9waWMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1YnN1YlRvcGljIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZWdhdGl2ZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25lZ2F0aXZlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5lZ2F0aXZlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbmVnYXRpdmVQcm9tcHQnXSwgZnJvbU5lZ2F0aXZlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2VuZXJhdGVBdWRpbyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGVBdWRpbyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFzdEZyYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXN0RnJhbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYXN0RnJhbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2xhc3RGcmFtZSddLCBpbWFnZVRvTWxkZXYoZnJvbUxhc3RGcmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncmVmZXJlbmNlSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2snXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hc2sgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHJlc3Npb25RdWFsaXR5J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb21wcmVzc2lvblF1YWxpdHkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OdW1iZXJPZlZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mVmlkZW9zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mVmlkZW9zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHVyYXRpb25TZWNvbmRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHVyYXRpb25TZWNvbmRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUR1cmF0aW9uU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2R1cmF0aW9uU2Vjb25kcyddLCBmcm9tRHVyYXRpb25TZWNvbmRzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvbHV0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Jlc29sdXRpb24nXSwgZnJvbVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHVic3ViVG9waWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3B1YnN1YlRvcGljJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHVic3ViVG9waWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwdWJzdWJUb3BpYyddLCBmcm9tUHVic3ViVG9waWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVBdWRpbycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0ZUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ2VuZXJhdGVBdWRpbyddLCBmcm9tR2VuZXJhdGVBdWRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYXN0RnJhbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhc3RGcmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhc3RGcmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnbGFzdEZyYW1lJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUxhc3RGcmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3JlZmVyZW5jZUltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFzayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFzayddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1hc2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ21hc2snXSwgdmlkZW9HZW5lcmF0aW9uTWFza1RvVmVydGV4KGZyb21NYXNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21Db21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlJyxcbiAgICAgICAgJ2dlbmVyYXRlVmlkZW9SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3ZpZGVvJ10sIHZpZGVvVG9NbGRldihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb01sZGV2KGZyb21Tb3VyY2UsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVWaWRlb3NDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3ZpZGVvJ10sIHZpZGVvVG9WZXJ0ZXgoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlVmlkZW9zU291cmNlVG9WZXJ0ZXgoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVkU2FtcGxlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlb3MnXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb01sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3ZpZGVvJ10sIHZpZGVvVG9NbGRldihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub1ZlcnRleChmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkSW1hZ2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VGcm9tTWxkZXYoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlGaWx0ZXJlZFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaUZpbHRlcmVkUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaUZpbHRlcmVkUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpRmlsdGVyZWRSZWFzb24nXSwgZnJvbVJhaUZpbHRlcmVkUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihmcm9tU2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VGcm9tVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlGaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlGaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaUZpbHRlcmVkUmVhc29uJ10sIGZyb21SYWlGaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21TYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlZFByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tRW5oYW5jZWRQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmhhbmNlZFByb21wdCddLCBmcm9tRW5oYW5jZWRQcm9tcHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZU1hc2tGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NYXNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbU1hc2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrJ10sIGltYWdlRnJvbVZlcnRleChmcm9tTWFzaykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUxhYmVscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbU1sZGV2KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tVmVydGV4KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0aW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbW9kZWxTZWxlY3Rpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbENvbmZpZyddLCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvVGltZXN0YW1wID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9UaW1lc3RhbXAnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9UaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddLCBmcm9tQXVkaW9UaW1lc3RhbXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCBmcm9tUmVzcG9uc2VTY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm91dGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JvdXRpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUm91dGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSwgZnJvbVJvdXRpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIGZyb21TcGVlY2hDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0aENvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlV2lkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVXaWRnZXQnXSk7XG4gICAgaWYgKGZyb21FbmFibGVXaWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVXaWRnZXQnXSwgZnJvbUVuYWJsZVdpZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmxvY2tpbmdDb25maWRlbmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdibG9ja2luZ0NvbmZpZGVuY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgZnJvbVRpbWVSYW5nZUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BlcnNvbkdlbmVyYXRpb24nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BlcnNvbkdlbmVyYXRpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0TWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dE1pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eSddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAoZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlT3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlT3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUJ5dGVzJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VCeXRlcyddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUXVlcnlCYXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydxdWVyeUJhc2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21RdWVyeUJhc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3VybCcsICdtb2RlbHNfdXJsJ10sIHRNb2RlbHNVcmwoYXBpQ2xpZW50LCBmcm9tUXVlcnlCYXNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21RdWVyeUJhc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3F1ZXJ5QmFzZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVF1ZXJ5QmFzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfdXJsJywgJ21vZGVsc191cmwnXSwgdE1vZGVsc1VybChhcGlDbGllbnQsIGZyb21RdWVyeUJhc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21Nb2RlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEV4dHJhY3RNb2RlbHMoZnJvbU1vZGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21Nb2RlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEV4dHJhY3RNb2RlbHMoZnJvbU1vZGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWFza01vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tNb2RlJ10pO1xuICAgIGlmIChmcm9tTWFza01vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrTW9kZSddLCBmcm9tTWFza01vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VnbWVudGF0aW9uQ2xhc3NlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlZ21lbnRhdGlvbkNsYXNzZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VnbWVudGF0aW9uQ2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tDbGFzc2VzJ10sIGZyb21TZWdtZW50YXRpb25DbGFzc2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tEaWxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza0RpbGF0aW9uJ10pO1xuICAgIGlmIChmcm9tTWFza0RpbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlsYXRpb24nXSwgZnJvbU1hc2tEaWxhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbVZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZXJzaW9uJ10sIGZyb21WZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbEluZm8nXSwgdHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYoZnJvbVR1bmVkTW9kZWxJbmZvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dFRva2VuTGltaXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dFRva2VuTGltaXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5wdXRUb2tlbkxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRUb2tlbkxpbWl0J10sIGZyb21JbnB1dFRva2VuTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VG9rZW5MaW1pdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dFRva2VuTGltaXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3V0cHV0VG9rZW5MaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFRva2VuTGltaXQnXSwgZnJvbU91dHB1dFRva2VuTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3VwcG9ydGVkQWN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1cHBvcnRlZEdlbmVyYXRpb25NZXRob2RzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1cHBvcnRlZEFjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBwb3J0ZWRBY3Rpb25zJ10sIGZyb21TdXBwb3J0ZWRBY3Rpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4VGVtcGVyYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4VGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhUZW1wZXJhdHVyZSddLCBmcm9tTWF4VGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhpbmtpbmcnXSk7XG4gICAgaWYgKGZyb21UaGlua2luZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nJ10sIGZyb21UaGlua2luZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnNpb25JZCddKTtcbiAgICBpZiAoZnJvbVZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZXJzaW9uJ10sIGZyb21WZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZHBvaW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVwbG95ZWRNb2RlbHMnXSk7XG4gICAgaWYgKGZyb21FbmRwb2ludHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUVuZHBvaW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRwb2ludEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbEluZm8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbEluZm8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsSW5mbyddLCB0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgoZnJvbVR1bmVkTW9kZWxJbmZvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0Q2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVmYXVsdENoZWNrcG9pbnRJZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EZWZhdWx0Q2hlY2twb2ludElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVmYXVsdENoZWNrcG9pbnRJZCddLCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaGVja3BvaW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2hlY2twb2ludHMnXSk7XG4gICAgaWYgKGZyb21DaGVja3BvaW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2hlY2twb2ludHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDEoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb01sZGV2JDEoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDEoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcm9kdWN0SW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvZHVjdEltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9kdWN0SW1hZ2UnXSk7XG4gICAgaWYgKGZyb21Qcm9kdWN0SW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21Qcm9kdWN0SW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhc2VTdGVwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZVN0ZXBzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmFzZVN0ZXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYmFzZVN0ZXBzJ10sIGZyb21CYXNlU3RlcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUZpbHRlckxldmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5RmlsdGVyTGV2ZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYWZldHlTZXR0aW5nJ10sIGZyb21TYWZldHlGaWx0ZXJMZXZlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BZGRXYXRlcm1hcmsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkZFdhdGVybWFyayddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFkZFdhdGVybWFyayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FkZFdhdGVybWFyayddLCBmcm9tQWRkV2F0ZXJtYXJrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ21pbWVUeXBlJ10sIGZyb21PdXRwdXRNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgcmVjb250ZXh0SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHJlY29udGV4dEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwZXJzb25JbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwZXJzb25JbWFnZScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21QZXJzb25JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvZHVjdEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb2R1Y3RJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvZHVjdEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvZHVjdEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kdWN0SW1hZ2VUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvZHVjdEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWZlcmVuY2VJbWFnZUFQSUludGVybmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VJbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21SZWZlcmVuY2VJbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JlZmVyZW5jZUlkJ10pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VJZCddLCBmcm9tUmVmZXJlbmNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZVR5cGUnXSwgZnJvbVJlZmVyZW5jZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza0ltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWFza0ltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1hc2tJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tJbWFnZUNvbmZpZyddLCBtYXNrUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU1hc2tJbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udHJvbEltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udHJvbEltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvbnRyb2xJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRyb2xJbWFnZUNvbmZpZyddLCBjb250cm9sUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbnRyb2xJbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3R5bGVJbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0eWxlSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3R5bGVJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0eWxlSW1hZ2VDb25maWcnXSwgZnJvbVN0eWxlSW1hZ2VDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3ViamVjdEltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3ViamVjdEltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1YmplY3RJbWFnZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1YmplY3RJbWFnZUNvbmZpZyddLCBmcm9tU3ViamVjdEltYWdlQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DYXRlZ29yaWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdjYXRlZ29yaWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhdGVnb3JpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yaWVzJ10sIGZyb21DYXRlZ29yaWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNjb3JlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnc2NvcmVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNjb3JlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Njb3JlcyddLCBmcm9tU2NvcmVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50VHlwZSddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudFR5cGUnXSwgZnJvbUNvbnRlbnRUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5U2V0dGluZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzY3JpYmJsZUltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByZWRpY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4UHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4UHJlZGljdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtYXhQcmVkaWN0aW9ucyddLCBmcm9tTWF4UHJlZGljdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZGVuY2VUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2NvbmZpZGVuY2VUaHJlc2hvbGQnXSwgZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza0RpbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrRGlsYXRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXNrRGlsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdtYXNrRGlsYXRpb24nXSwgZnJvbU1hc2tEaWxhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaW5hcnlDb2xvclRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpbmFyeUNvbG9yVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYmluYXJ5Q29sb3JUaHJlc2hvbGQnXSwgZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc2VnbWVudEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZWdtZW50SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkTWFza3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ByZWRpY3Rpb25zJ10pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkTWFza3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZE1hc2tzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRNYXNrcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY3JpYmJsZUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2NyaWJibGVJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TY3JpYmJsZUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdzY3JpYmJsZSddLCBzY3JpYmJsZUltYWdlVG9WZXJ0ZXgoZnJvbVNjcmliYmxlSW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgZnJvbVJldHJpZXZhbENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSwgZnJvbUZpbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9NbGRldiQxKGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDEoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VudGVycHJpc2VXZWJTZWFyY2gnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSwgZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBmcm9tR29vZ2xlTWFwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBmcm9tR29vZ2xlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsSW5mb0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuZWRNb2RlbEluZm9Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsYWJlbHMnLFxuICAgICAgICAnZ29vZ2xlLXZlcnRleC1sbG0tdHVuaW5nLWJhc2UtbW9kZWwtaWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVmYXVsdENoZWNrcG9pbnRJZCddLCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0Q2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVmYXVsdENoZWNrcG9pbnRJZCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZWZhdWx0Q2hlY2twb2ludElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2RlZmF1bHRDaGVja3BvaW50SWQnXSwgZnJvbURlZmF1bHRDaGVja3BvaW50SWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVNb2RlbENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU1vZGVsQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cHNjYWxlSW1hZ2VBUElDb25maWdJbnRlcm5hbFRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUZpbHRlckxldmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5RmlsdGVyTGV2ZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYWZldHlTZXR0aW5nJ10sIGZyb21TYWZldHlGaWx0ZXJMZXZlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZUlucHV0SW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlSW5wdXRJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlSW5wdXRJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAnZW5oYW5jZUlucHV0SW1hZ2UnXSwgZnJvbUVuaGFuY2VJbnB1dEltYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3InLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICd1cHNjYWxlQ29uZmlnJywgJ2ltYWdlUHJlc2VydmF0aW9uRmFjdG9yJ10sIGZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3Rvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwc2NhbGVJbWFnZUFQSVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcHNjYWxlRmFjdG9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXBzY2FsZUZhY3RvcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcHNjYWxlRmFjdG9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycycsICd1cHNjYWxlQ29uZmlnJywgJ3Vwc2NhbGVGYWN0b3InXSwgZnJvbVVwc2NhbGVGYWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cHNjYWxlSW1hZ2VBUElDb25maWdJbnRlcm5hbFRvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kZWRWaWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kaW5nJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9CeXRlcyddLCB0Qnl0ZXMoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9HZW5lcmF0aW9uTWFza1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ19zZWxmJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza01vZGUnXSk7XG4gICAgaWYgKGZyb21NYXNrTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tNb2RlJ10sIGZyb21NYXNrTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvTWxkZXYoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlVHlwZSddLCBmcm9tUmVmZXJlbmNlVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VUeXBlJ10sIGZyb21SZWZlcmVuY2VUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Ub01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5jb2RlZFZpZGVvJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmNvZGluZyddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBjcmVhdGVGaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVGaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JjZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZvcmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmb3JjZSddLCBmcm9tRm9yY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBkZWxldGVGaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0RmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ3VzdG9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjdXN0b21NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DdXN0b21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ3VzdG9tTWV0YWRhdGE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjdXN0b21NZXRhZGF0YSddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2h1bmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjaHVua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DaHVua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjaHVua2luZ0NvbmZpZyddLCBmcm9tQ2h1bmtpbmdDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgaW1wb3J0RmlsZVJlc3BvbnNlRnJvbU1sZGV2KGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaWxlU2VhcmNoU3RvcmVOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGVfc2VhcmNoX3N0b3JlX25hbWUnXSwgZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlTmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBpbXBvcnRGaWxlQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltcG9ydEZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyZW50J10pO1xuICAgIGlmIChmcm9tUGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyZW50J10sIGZyb21QYXJlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9jdW1lbnROYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb2N1bWVudE5hbWUnXSk7XG4gICAgaWYgKGZyb21Eb2N1bWVudE5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb2N1bWVudE5hbWUnXSwgZnJvbURvY3VtZW50TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlU2VhcmNoU3RvcmVzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlU2VhcmNoU3RvcmVzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdEZpbGVTZWFyY2hTdG9yZXNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2hTdG9yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaWxlU2VhcmNoU3RvcmVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2hTdG9yZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZpbGVTZWFyY2hTdG9yZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2hTdG9yZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3VzdG9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjdXN0b21NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DdXN0b21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ3VzdG9tTWV0YWRhdGE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjdXN0b21NZXRhZGF0YSddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2h1bmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjaHVua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DaHVua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjaHVua2luZ0NvbmZpZyddLCBmcm9tQ2h1bmtpbmdDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZmlsZVNlYXJjaFN0b3JlTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdmaWxlX3NlYXJjaF9zdG9yZV9uYW1lJ10sIGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXN1bWFibGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBDT05URU5UX1RZUEVfSEVBREVSID0gJ0NvbnRlbnQtVHlwZSc7XG5jb25zdCBTRVJWRVJfVElNRU9VVF9IRUFERVIgPSAnWC1TZXJ2ZXItVGltZW91dCc7XG5jb25zdCBVU0VSX0FHRU5UX0hFQURFUiA9ICdVc2VyLUFnZW50JztcbmNvbnN0IEdPT0dMRV9BUElfQ0xJRU5UX0hFQURFUiA9ICd4LWdvb2ctYXBpLWNsaWVudCc7XG5jb25zdCBTREtfVkVSU0lPTiA9ICcxLjM1LjAnOyAvLyB4LXJlbGVhc2UtcGxlYXNlLXZlcnNpb25cbmNvbnN0IExJQlJBUllfTEFCRUwgPSBgZ29vZ2xlLWdlbmFpLXNkay8ke1NES19WRVJTSU9OfWA7XG5jb25zdCBWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiA9ICd2MWJldGExJztcbmNvbnN0IEdPT0dMRV9BSV9BUElfREVGQVVMVF9WRVJTSU9OID0gJ3YxYmV0YSc7XG4vKipcbiAqIFRoZSBBcGlDbGllbnQgY2xhc3MgaXMgdXNlZCB0byBzZW5kIHJlcXVlc3RzIHRvIHRoZSBHZW1pbmkgQVBJIG9yIFZlcnRleCBBSVxuICogZW5kcG9pbnRzLlxuICovXG5jbGFzcyBBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBwcm9qZWN0OiBvcHRzLnByb2plY3QsIGxvY2F0aW9uOiBvcHRzLmxvY2F0aW9uLCBhcGlLZXk6IG9wdHMuYXBpS2V5LCB2ZXJ0ZXhhaTogb3B0cy52ZXJ0ZXhhaSB9KTtcbiAgICAgICAgY29uc3QgaW5pdEh0dHBPcHRpb25zID0ge307XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVkVSVEVYX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IHRoaXMuYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplQXV0aFBhcmFtZXRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdlbWluaSBBUElcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS9gO1xuICAgICAgICB9XG4gICAgICAgIGluaXRIdHRwT3B0aW9ucy5oZWFkZXJzID0gdGhpcy5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSBpbml0SHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRzLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnMoaW5pdEh0dHBPcHRpb25zLCBvcHRzLmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBiYXNlIFVSTCBmb3IgVmVydGV4IEFJIGJhc2VkIG9uIHByb2plY3QgYW5kIGxvY2F0aW9uLlxuICAgICAqIFVzZXMgdGhlIGdsb2JhbCBlbmRwb2ludCBpZiBsb2NhdGlvbiBpcyAnZ2xvYmFsJyBvciBpZiBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICogYXJlIG5vdCBzcGVjaWZpZWQgKGltcGx5aW5nIEFQSSBrZXkgdXNhZ2UpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gIT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICAvLyBSZWdpb25hbCBlbmRwb2ludFxuICAgICAgICAgICAgcmV0dXJuIGBodHRwczovLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufS1haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2xvYmFsIGVuZHBvaW50IChjb3ZlcnMgJ2dsb2JhbCcgbG9jYXRpb24gYW5kIEFQSSBrZXkgdXNhZ2UpXG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYXV0aGVudGljYXRpb24gcGFyYW1ldGVycyBmb3IgVmVydGV4IEFJLlxuICAgICAqIElmIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBwcm92aWRlZCwgQVBJIGtleSBpcyBjbGVhcmVkLlxuICAgICAqIElmIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBub3QgcHJvdmlkZWQgKGltcGx5aW5nIEFQSSBrZXkgdXNhZ2UpLFxuICAgICAqIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBjbGVhcmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm9ybWFsaXplQXV0aFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJiB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIHByb2plY3QvbG9jYXRpb24gZm9yIGF1dGgsIGNsZWFyIHBvdGVudGlhbCBBUEkga2V5XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzaW5nIEFQSSBrZXkgZm9yIGF1dGggKG9yIG5vIGF1dGggcHJvdmlkZWQgeWV0KSwgY2xlYXIgcHJvamVjdC9sb2NhdGlvblxuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpc1ZlcnRleEFJKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLnByb2plY3Q7XG4gICAgfVxuICAgIGdldExvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uO1xuICAgIH1cbiAgICBhc3luYyBnZXRBdXRoSGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50T3B0aW9ucy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgZ2V0QXBpVmVyc2lvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmFwaVZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5hcGlWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQVBJIHZlcnNpb24gaXMgbm90IHNldC4nKTtcbiAgICB9XG4gICAgZ2V0QmFzZVVybCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFzZSBVUkwgaXMgbm90IHNldC4nKTtcbiAgICB9XG4gICAgZ2V0UmVxdWVzdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVxdWVzdFVybEludGVybmFsKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyk7XG4gICAgfVxuICAgIGdldEhlYWRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5oZWFkZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGVhZGVycyBhcmUgbm90IHNldC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXF1ZXN0VXJsSW50ZXJuYWwoaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFodHRwT3B0aW9ucyB8fFxuICAgICAgICAgICAgaHR0cE9wdGlvbnMuYmFzZVVybCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBodHRwT3B0aW9ucy5hcGlWZXJzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSFRUUCBvcHRpb25zIGFyZSBub3QgY29ycmVjdGx5IHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlVXJsID0gaHR0cE9wdGlvbnMuYmFzZVVybC5lbmRzV2l0aCgnLycpXG4gICAgICAgICAgICA/IGh0dHBPcHRpb25zLmJhc2VVcmwuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICA6IGh0dHBPcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIGNvbnN0IHVybEVsZW1lbnQgPSBbYmFzZVVybF07XG4gICAgICAgIGlmIChodHRwT3B0aW9ucy5hcGlWZXJzaW9uICYmIGh0dHBPcHRpb25zLmFwaVZlcnNpb24gIT09ICcnKSB7XG4gICAgICAgICAgICB1cmxFbGVtZW50LnB1c2goaHR0cE9wdGlvbnMuYXBpVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybEVsZW1lbnQuam9pbignLycpO1xuICAgIH1cbiAgICBnZXRCYXNlUmVzb3VyY2VQYXRoKCkge1xuICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7dGhpcy5jbGllbnRPcHRpb25zLnByb2plY3R9L2xvY2F0aW9ucy8ke3RoaXMuY2xpZW50T3B0aW9ucy5sb2NhdGlvbn1gO1xuICAgIH1cbiAgICBnZXRBcGlLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5O1xuICAgIH1cbiAgICBnZXRXZWJzb2NrZXRCYXNlVXJsKCkge1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gdGhpcy5nZXRCYXNlVXJsKCk7XG4gICAgICAgIGNvbnN0IHVybFBhcnRzID0gbmV3IFVSTChiYXNlVXJsKTtcbiAgICAgICAgdXJsUGFydHMucHJvdG9jb2wgPSB1cmxQYXJ0cy5wcm90b2NvbCA9PSAnaHR0cDonID8gJ3dzJyA6ICd3c3MnO1xuICAgICAgICByZXR1cm4gdXJsUGFydHMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc2V0QmFzZVVybCh1cmwpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmwgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUVFAgb3B0aW9ucyBhcmUgbm90IGNvcnJlY3RseSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0VXJsKHBhdGgsIGh0dHBPcHRpb25zLCBwcmVwZW5kUHJvamVjdExvY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IHVybEVsZW1lbnQgPSBbdGhpcy5nZXRSZXF1ZXN0VXJsSW50ZXJuYWwoaHR0cE9wdGlvbnMpXTtcbiAgICAgICAgaWYgKHByZXBlbmRQcm9qZWN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaCh0aGlzLmdldEJhc2VSZXNvdXJjZVBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggIT09ICcnKSB7XG4gICAgICAgICAgICB1cmxFbGVtZW50LnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt1cmxFbGVtZW50LmpvaW4oJy8nKX1gKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2xpZW50T3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0LnBhdGguc3RhcnRzV2l0aCgncHJvamVjdHMvJykpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSB0aGUgcGF0aCBhbHJlYWR5IHN0YXJ0cyB3aXRoXG4gICAgICAgICAgICAvLyBgcHJvamVjdHMvPHByb2plY3Q+L2xvY2F0aW9uLzxsb2NhdGlvbj5gLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBNZXRob2QgPT09ICdHRVQnICYmXG4gICAgICAgICAgICByZXF1ZXN0LnBhdGguc3RhcnRzV2l0aCgncHVibGlzaGVycy9nb29nbGUvbW9kZWxzJykpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIHBhdGhzIGFyZSB1c2VkIGJ5IFZlcnRleCdzIG1vZGVscy5nZXQgYW5kIG1vZGVscy5saXN0XG4gICAgICAgICAgICAvLyBjYWxscy4gRm9yIGJhc2UgbW9kZWxzIFZlcnRleCBkb2VzIG5vdCBhY2NlcHQgYSBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICAgICAgICAvLyBwcmVmaXggKGZvciB0dW5lZCBtb2RlbCB0aGUgcHJlZml4IGlzIHJlcXVpcmVkKS5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGxldCBwYXRjaGVkSHR0cE9wdGlvbnMgPSB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnModGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLCByZXF1ZXN0Lmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwZW5kUHJvamVjdExvY2F0aW9uID0gdGhpcy5zaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuY29uc3RydWN0VXJsKHJlcXVlc3QucGF0aCwgcGF0Y2hlZEh0dHBPcHRpb25zLCBwcmVwZW5kUHJvamVjdExvY2F0aW9uKTtcbiAgICAgICAgaWYgKHJlcXVlc3QucXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlcXVlc3QucXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxdWVzdEluaXQgPSB7fTtcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmJvZHkgJiYgcmVxdWVzdC5ib2R5ICE9PSAne30nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IGJvZHkgc2hvdWxkIGJlIGVtcHR5IGZvciBHRVQgcmVxdWVzdCwgYnV0IGdvdCBub24gZW1wdHkgcmVxdWVzdCBib2R5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0SW5pdC5ib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RJbml0ID0gYXdhaXQgdGhpcy5pbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIHBhdGNoZWRIdHRwT3B0aW9ucywgdXJsLnRvU3RyaW5nKCksIHJlcXVlc3QuYWJvcnRTaWduYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy51bmFyeUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgcmVxdWVzdC5odHRwTWV0aG9kKTtcbiAgICB9XG4gICAgcGF0Y2hIdHRwT3B0aW9ucyhiYXNlSHR0cE9wdGlvbnMsIHJlcXVlc3RIdHRwT3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXRjaGVkSHR0cE9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGJhc2VIdHRwT3B0aW9ucykpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXF1ZXN0SHR0cE9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvLyBSZWNvcmRzIGNvbXBpbGUgdG8gb2JqZWN0cy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUzIzNDVUUzcwNTM6IEVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZVxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZXhwcmVzc2lvbiBvZiB0eXBlICdzdHJpbmcnIGNhbid0IGJlIHVzZWQgdG8gaW5kZXggdHlwZVxuICAgICAgICAgICAgICAgIC8vICdIdHRwT3B0aW9ucycuXG4gICAgICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zW2tleV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhdGNoZWRIdHRwT3B0aW9uc1trZXldKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMyMzQ1VFM3MDUzOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGV4cHJlc3Npb24gb2YgdHlwZSAnc3RyaW5nJyBjYW4ndCBiZSB1c2VkIHRvIGluZGV4IHR5cGVcbiAgICAgICAgICAgICAgICAvLyAnSHR0cE9wdGlvbnMnLlxuICAgICAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGNoZWRIdHRwT3B0aW9ucztcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdFN0cmVhbShyZXF1ZXN0KSB7XG4gICAgICAgIGxldCBwYXRjaGVkSHR0cE9wdGlvbnMgPSB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChyZXF1ZXN0Lmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnModGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLCByZXF1ZXN0Lmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwZW5kUHJvamVjdExvY2F0aW9uID0gdGhpcy5zaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuY29uc3RydWN0VXJsKHJlcXVlc3QucGF0aCwgcGF0Y2hlZEh0dHBPcHRpb25zLCBwcmVwZW5kUHJvamVjdExvY2F0aW9uKTtcbiAgICAgICAgaWYgKCF1cmwuc2VhcmNoUGFyYW1zLmhhcygnYWx0JykgfHwgdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2FsdCcpICE9PSAnc3NlJykge1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2FsdCcsICdzc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxdWVzdEluaXQgPSB7fTtcbiAgICAgICAgcmVxdWVzdEluaXQuYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgcmVxdWVzdEluaXQgPSBhd2FpdCB0aGlzLmluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgcGF0Y2hlZEh0dHBPcHRpb25zLCB1cmwudG9TdHJpbmcoKSwgcmVxdWVzdC5hYm9ydFNpZ25hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgcmVxdWVzdC5odHRwTWV0aG9kKTtcbiAgICB9XG4gICAgYXN5bmMgaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBodHRwT3B0aW9ucywgdXJsLCBhYm9ydFNpZ25hbCkge1xuICAgICAgICBpZiAoKGh0dHBPcHRpb25zICYmIGh0dHBPcHRpb25zLnRpbWVvdXQpIHx8IGFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICAgICAgaWYgKGh0dHBPcHRpb25zLnRpbWVvdXQgJiYgKGh0dHBPcHRpb25zID09PSBudWxsIHx8IGh0dHBPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwT3B0aW9ucy50aW1lb3V0KSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgaHR0cE9wdGlvbnMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRIYW5kbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRpbWVvdXRIYW5kbGUudW5yZWYgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgdW5yZWYgdG8gcHJldmVudCBub2RlanMgcHJvY2VzcyBmcm9tIGhhbmdpbmcsIHNlZVxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3RpbWVvdXR1bnJlZlxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SGFuZGxlLnVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdEluaXQuc2lnbmFsID0gc2lnbmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChodHRwT3B0aW9ucyAmJiBodHRwT3B0aW9ucy5leHRyYUJvZHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBodHRwT3B0aW9ucy5leHRyYUJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RJbml0LmhlYWRlcnMgPSBhd2FpdCB0aGlzLmdldEhlYWRlcnNJbnRlcm5hbChodHRwT3B0aW9ucywgdXJsKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RJbml0O1xuICAgIH1cbiAgICBhc3luYyB1bmFyeUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgaHR0cE1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGlDYWxsKHVybC50b1N0cmluZygpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RJbml0KSwgeyBtZXRob2Q6IGh0dHBNZXRob2QgfSkpXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSHR0cFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtQXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCBodHRwTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNhbGwodXJsLnRvU3RyaW5nKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluaXQpLCB7IG1ldGhvZDogaHR0cE1ldGhvZCB9KSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhyb3dFcnJvcklmTm90T0socmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHByb2Nlc3NTdHJlYW1SZXNwb25zZV8xKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgICAgICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgYm9keSBpcyBlbXB0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVByZWZpeCA9ICdkYXRhOic7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsaW1pdGVycyA9IFsnXFxuXFxuJywgJ1xcclxccicsICdcXHJcXG5cXHJcXG4nXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSB5aWVsZCBfX2F3YWl0KHJlYWRlci5yZWFkKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wbGV0ZSBKU09OIHNlZ21lbnQgYXQgdGhlIGVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtTdHJpbmcgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuZCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgY2h1bmsgY29udGFpbnMgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua0pzb24gPSBKU09OLnBhcnNlKGNodW5rU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnZXJyb3InIGluIGNodW5rSnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ySnNvbiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY2h1bmtKc29uWydlcnJvciddKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZXJyb3JKc29uWydzdGF0dXMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gZXJyb3JKc29uWydjb2RlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYGdvdCBzdGF0dXM6ICR7c3RhdHVzfS4gJHtKU09OLnN0cmluZ2lmeShjaHVua0pzb24pfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gNDAwICYmIGNvZGUgPCA2MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXBpRXJyb3IgPSBuZXcgQXBpRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYXBpRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0FwaUVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IGNodW5rU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsaW1pdGVySW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGltaXRlckxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVsaW1pdGVyIG9mIGRlbGltaXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGJ1ZmZlci5pbmRleE9mKGRlbGltaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGVsaW1pdGVySW5kZXggPT09IC0xIHx8IGluZGV4IDwgZGVsaW1pdGVySW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlckxlbmd0aCA9IGRlbGltaXRlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGltaXRlckluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBObyBjb21wbGV0ZSBldmVudCBpbiBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50U3RyaW5nID0gYnVmZmVyLnN1YnN0cmluZygwLCBkZWxpbWl0ZXJJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc3Vic3RyaW5nKGRlbGltaXRlckluZGV4ICsgZGVsaW1pdGVyTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRFdmVudCA9IGV2ZW50U3RyaW5nLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmltbWVkRXZlbnQuc3RhcnRzV2l0aChkYXRhUHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZENodW5rU3RyaW5nID0gdHJpbW1lZEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoZGF0YVByZWZpeC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHByb2Nlc3NlZENodW5rU3RyaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChuZXcgSHR0cFJlc3BvbnNlKHBhcnRpYWxSZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4Y2VwdGlvbiBwYXJzaW5nIHN0cmVhbSBjaHVuayAke3Byb2Nlc3NlZENodW5rU3RyaW5nfS4gJHtlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgYXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0KSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwsIHJlcXVlc3RJbml0KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleGNlcHRpb24gJHtlfSBzZW5kaW5nIHJlcXVlc3RgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERlZmF1bHRIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGNvbnN0IHZlcnNpb25IZWFkZXJWYWx1ZSA9IExJQlJBUllfTEFCRUwgKyAnICcgKyB0aGlzLmNsaWVudE9wdGlvbnMudXNlckFnZW50RXh0cmE7XG4gICAgICAgIGhlYWRlcnNbVVNFUl9BR0VOVF9IRUFERVJdID0gdmVyc2lvbkhlYWRlclZhbHVlO1xuICAgICAgICBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0gPSB2ZXJzaW9uSGVhZGVyVmFsdWU7XG4gICAgICAgIGhlYWRlcnNbQ09OVEVOVF9UWVBFX0hFQURFUl0gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBhc3luYyBnZXRIZWFkZXJzSW50ZXJuYWwoaHR0cE9wdGlvbnMsIHVybCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKGh0dHBPcHRpb25zICYmIGh0dHBPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGh0dHBPcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBlbmQgYSB0aW1lb3V0IGhlYWRlciBpZiBpdCBpcyBzZXQsIG5vdGUgdGhhdCB0aGUgdGltZW91dCBvcHRpb24gaXNcbiAgICAgICAgICAgIC8vIGluIG1pbGxpc2Vjb25kcyBidXQgdGhlIGhlYWRlciBpcyBpbiBzZWNvbmRzLlxuICAgICAgICAgICAgaWYgKGh0dHBPcHRpb25zLnRpbWVvdXQgJiYgaHR0cE9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChTRVJWRVJfVElNRU9VVF9IRUFERVIsIFN0cmluZyhNYXRoLmNlaWwoaHR0cE9wdGlvbnMudGltZW91dCAvIDEwMDApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnRPcHRpb25zLmF1dGguYWRkQXV0aEhlYWRlcnMoaGVhZGVycywgdXJsKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGdldEZpbGVOYW1lKGZpbGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZmlsZU5hbWUgPSAnJztcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBmaWxlLnJlcGxhY2UoL1svXFxcXF0rJC8sICcnKTtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gKF9hID0gZmlsZU5hbWUuc3BsaXQoL1svXFxcXF0vKS5wb3AoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB1c2luZyBHZW1pbmkgQVBJIG9ubHksIHRoaXMgaXMgbm90IHN1cHBvcnRlZFxuICAgICAqIGluIFZlcnRleCBBSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBzdHJpbmcgcGF0aCB0byB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZCBvciBhIEJsb2Igb2JqZWN0LlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlIGBVcGxvYWRGaWxlQ29uZmlnYFxuICAgICAqICAgICBpbnRlcmZhY2UuIEBzZWUge0BsaW5rIHR5cGVzLlVwbG9hZEZpbGVDb25maWd9XG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZEZpbGUoZmlsZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZmlsZVRvVXBsb2FkID0ge307XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm1pbWVUeXBlID0gY29uZmlnLm1pbWVUeXBlO1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm5hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5kaXNwbGF5TmFtZSA9IGNvbmZpZy5kaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZVRvVXBsb2FkLm5hbWUgJiYgIWZpbGVUb1VwbG9hZC5uYW1lLnN0YXJ0c1dpdGgoJ2ZpbGVzLycpKSB7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubmFtZSA9IGBmaWxlcy8ke2ZpbGVUb1VwbG9hZC5uYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBsb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMudXBsb2FkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVTdGF0ID0gYXdhaXQgdXBsb2FkZXIuc3RhdChmaWxlKTtcbiAgICAgICAgZmlsZVRvVXBsb2FkLnNpemVCeXRlcyA9IFN0cmluZyhmaWxlU3RhdC5zaXplKTtcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubWltZVR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpbGVTdGF0LnR5cGU7XG4gICAgICAgIGlmIChtaW1lVHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1pbWVUeXBlID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGRldGVybWluZSBtaW1lVHlwZS4gUGxlYXNlIHByb3ZpZGUgbWltZVR5cGUgaW4gdGhlIGNvbmZpZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBmaWxlVG9VcGxvYWQubWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGVUb1VwbG9hZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKGZpbGUpO1xuICAgICAgICBjb25zdCBwYXRoID0gZm9ybWF0TWFwKCd1cGxvYWQvdjFiZXRhL2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgY29uc3QgdXBsb2FkVXJsID0gYXdhaXQgdGhpcy5mZXRjaFVwbG9hZFVybChwYXRoLCBmaWxlVG9VcGxvYWQuc2l6ZUJ5dGVzLCBmaWxlVG9VcGxvYWQubWltZVR5cGUsIGZpbGVOYW1lLCBib2R5LCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuaHR0cE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdXBsb2FkZXIudXBsb2FkKGZpbGUsIHVwbG9hZFVybCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIHRvIGEgZ2l2ZW4gZmlsZSBzZWFyY2ggc3RvcmUgYXN5bmNocm9ub3VzbHkgdXNpbmcgR2VtaW5pIEFQSSBvbmx5LCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgKiBpbiBWZXJ0ZXggQUkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVNlYXJjaFN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSBzZWFyY2ggc3RvcmUgdG8gdXBsb2FkIHRoZSBmaWxlIHRvLlxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBzdHJpbmcgcGF0aCB0byB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZCBvciBhIEJsb2Igb2JqZWN0LlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlIGBVcGxvYWRGaWxlQ29uZmlnYFxuICAgICAqICAgICBpbnRlcmZhY2UuIEBzZWUge0BsaW5rIFVwbG9hZEZpbGVDb25maWd9XG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZEZpbGVUb0ZpbGVTZWFyY2hTdG9yZShmaWxlU2VhcmNoU3RvcmVOYW1lLCBmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB1cGxvYWRlciA9IHRoaXMuY2xpZW50T3B0aW9ucy51cGxvYWRlcjtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSBhd2FpdCB1cGxvYWRlci5zdGF0KGZpbGUpO1xuICAgICAgICBjb25zdCBzaXplQnl0ZXMgPSBTdHJpbmcoZmlsZVN0YXQuc2l6ZSk7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLm1pbWVUeXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWxlU3RhdC50eXBlO1xuICAgICAgICBpZiAobWltZVR5cGUgPT09IHVuZGVmaW5lZCB8fCBtaW1lVHlwZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBkZXRlcm1pbmUgbWltZVR5cGUuIFBsZWFzZSBwcm92aWRlIG1pbWVUeXBlIGluIHRoZSBjb25maWcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IGB1cGxvYWQvdjFiZXRhLyR7ZmlsZVNlYXJjaFN0b3JlTmFtZX06dXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVgO1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZ2V0RmlsZU5hbWUoZmlsZSk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYoY29uZmlnLCBib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSBhd2FpdCB0aGlzLmZldGNoVXBsb2FkVXJsKHBhdGgsIHNpemVCeXRlcywgbWltZVR5cGUsIGZpbGVOYW1lLCBib2R5LCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuaHR0cE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdXBsb2FkZXIudXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUoZmlsZSwgdXBsb2FkVXJsLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW1zIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZG93bmxvYWQgcmVxdWVzdCwgc2VlIHtAbGlua1xuICAgICAqIHR5cGVzLkRvd25sb2FkRmlsZVBhcmFtZXRlcnN9XG4gICAgICovXG4gICAgYXN5bmMgZG93bmxvYWRGaWxlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBkb3dubG9hZGVyID0gdGhpcy5jbGllbnRPcHRpb25zLmRvd25sb2FkZXI7XG4gICAgICAgIGF3YWl0IGRvd25sb2FkZXIuZG93bmxvYWQocGFyYW1zLCB0aGlzKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hVcGxvYWRVcmwocGF0aCwgc2l6ZUJ5dGVzLCBtaW1lVHlwZSwgZmlsZU5hbWUsIGJvZHksIGNvbmZpZ0h0dHBPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGh0dHBPcHRpb25zID0ge307XG4gICAgICAgIGlmIChjb25maWdIdHRwT3B0aW9ucykge1xuICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWdIdHRwT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGh0dHBPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGFwaVZlcnNpb246ICcnLCAvLyBhcGktdmVyc2lvbiBpcyBzZXQgaW4gdGhlIHBhdGguXG4gICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ3Jlc3VtYWJsZScsICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiAnc3RhcnQnLCAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1MZW5ndGgnOiBgJHtzaXplQnl0ZXN9YCwgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtVHlwZSc6IGAke21pbWVUeXBlfWAgfSwgKGZpbGVOYW1lID8geyAnWC1Hb29nLVVwbG9hZC1GaWxlLU5hbWUnOiBmaWxlTmFtZSB9IDoge30pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaHR0cFJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFodHRwUmVzcG9uc2UgfHwgIShodHRwUmVzcG9uc2UgPT09IG51bGwgfHwgaHR0cFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwUmVzcG9uc2UuaGVhZGVycykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIGRpZCBub3QgcmV0dXJuIGFuIEh0dHBSZXNwb25zZSBvciB0aGUgcmV0dXJuZWQgSHR0cFJlc3BvbnNlIGRpZCBub3QgaGF2ZSBoZWFkZXJzLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwbG9hZFVybCA9IChfYSA9IGh0dHBSZXNwb25zZSA9PT0gbnVsbCB8fCBodHRwUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0dHBSZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJ3gtZ29vZy11cGxvYWQtdXJsJ107XG4gICAgICAgIGlmICh1cGxvYWRVcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHVwbG9hZCB1cmwuIFNlcnZlciBkaWQgbm90IHJldHVybiB0aGUgeC1nb29nbGUtdXBsb2FkLXVybCBpbiB0aGUgaGVhZGVycycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGxvYWRVcmw7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdGhyb3dFcnJvcklmTm90T0socmVzcG9uc2UpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNwb25zZSBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgIGxldCBlcnJvckJvZHk7XG4gICAgICAgIGlmICgoX2EgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgICBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvckJvZHkgPSB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYXdhaXQgcmVzcG9uc2UudGV4dCgpLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShlcnJvckJvZHkpO1xuICAgICAgICBpZiAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA2MDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEFwaUVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGFwaUVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIH1cbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgdXBkYXRlcyB0aGUgYHJlcXVlc3RJbml0LmJvZHlgIHdpdGggdmFsdWVzIGZyb20gYW4gYGV4dHJhQm9keWAgb2JqZWN0LlxuICpcbiAqIElmIGByZXF1ZXN0SW5pdC5ib2R5YCBpcyBhIHN0cmluZywgaXQncyBhc3N1bWVkIHRvIGJlIEpTT04gYW5kIHdpbGwgYmUgcGFyc2VkLlxuICogVGhlIGBleHRyYUJvZHlgIGlzIHRoZW4gZGVlcGx5IG1lcmdlZCBpbnRvIHRoaXMgcGFyc2VkIG9iamVjdC5cbiAqIElmIGByZXF1ZXN0SW5pdC5ib2R5YCBpcyBhIEJsb2IsIGBleHRyYUJvZHlgIHdpbGwgYmUgaWdub3JlZCwgYW5kIGEgd2FybmluZyBsb2dnZWQsXG4gKiBhcyBtZXJnaW5nIHN0cnVjdHVyZWQgZGF0YSBpbnRvIGFuIG9wYXF1ZSBCbG9iIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogVGhlIGZ1bmN0aW9uIGRvZXMgbm90IGVuZm9yY2UgdGhhdCB1cGRhdGVkIHZhbHVlcyBmcm9tIGBleHRyYUJvZHlgIGhhdmUgdGhlXG4gKiBzYW1lIHR5cGUgYXMgZXhpc3RpbmcgdmFsdWVzIGluIGByZXF1ZXN0SW5pdC5ib2R5YC4gVHlwZSBtaXNtYXRjaGVzIGR1cmluZ1xuICogdGhlIG1lcmdlIHdpbGwgcmVzdWx0IGluIGEgd2FybmluZywgYnV0IHRoZSB2YWx1ZSBmcm9tIGBleHRyYUJvZHlgIHdpbGwgb3ZlcndyaXRlXG4gKiB0aGUgb3JpZ2luYWwuIGBleHRyYUJvZHlgIHVzZXJzIGFyZSByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgYGV4dHJhQm9keWAgaGFzIHRoZSBjb3JyZWN0IHN0cnVjdHVyZS5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdEluaXQgVGhlIFJlcXVlc3RJbml0IG9iamVjdCB3aG9zZSBib2R5IHdpbGwgYmUgdXBkYXRlZC5cbiAqIEBwYXJhbSBleHRyYUJvZHkgVGhlIG9iamVjdCBjb250YWluaW5nIHVwZGF0ZXMgdG8gYmUgbWVyZ2VkIGludG8gYHJlcXVlc3RJbml0LmJvZHlgLlxuICovXG5mdW5jdGlvbiBpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgZXh0cmFCb2R5KSB7XG4gICAgaWYgKCFleHRyYUJvZHkgfHwgT2JqZWN0LmtleXMoZXh0cmFCb2R5KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdEluaXQuYm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdDogZXh0cmFCb2R5IHByb3ZpZGVkIGJ1dCBjdXJyZW50IHJlcXVlc3QgYm9keSBpcyBhIEJsb2IuIGV4dHJhQm9keSB3aWxsIGJlIGlnbm9yZWQgYXMgbWVyZ2luZyBpcyBub3Qgc3VwcG9ydGVkIGZvciBCbG9iIGJvZGllcy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY3VycmVudEJvZHlPYmplY3QgPSB7fTtcbiAgICAvLyBJZiBhZGRpbmcgbmV3IHR5cGUgdG8gSHR0cFJlcXVlc3QuYm9keSwgcGxlYXNlIGNoZWNrIHRoZSBjb2RlIGJlbG93IHRvXG4gICAgLy8gc2VlIGlmIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBsb2dpYy5cbiAgICBpZiAodHlwZW9mIHJlcXVlc3RJbml0LmJvZHkgPT09ICdzdHJpbmcnICYmIHJlcXVlc3RJbml0LmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQm9keSA9IEpTT04ucGFyc2UocmVxdWVzdEluaXQuYm9keSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlZEJvZHkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgcGFyc2VkQm9keSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHBhcnNlZEJvZHkpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJvZHlPYmplY3QgPSBwYXJzZWRCb2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdDogT3JpZ2luYWwgcmVxdWVzdCBib2R5IGlzIHZhbGlkIEpTT04gYnV0IG5vdCBhIG5vbi1hcnJheSBvYmplY3QuIFNraXAgYXBwbHlpbmcgZXh0cmFCb2R5IHRvIHRoZSByZXF1ZXN0IGJvZHkuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdDogT3JpZ2luYWwgcmVxdWVzdCBib2R5IGlzIG5vdCB2YWxpZCBKU09OLiBTa2lwIGFwcGx5aW5nIGV4dHJhQm9keSB0byB0aGUgcmVxdWVzdCBib2R5LicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZXBNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IG91dHB1dFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc291cmNlVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHNvdXJjZVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0VmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IGRlZXBNZXJnZSh0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFZhbHVlICE9PSB0eXBlb2Ygc291cmNlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6ZGVlcE1lcmdlOiBUeXBlIG1pc21hdGNoIGZvciBrZXkgXCIke2tleX1cIi4gT3JpZ2luYWwgdHlwZTogJHt0eXBlb2YgdGFyZ2V0VmFsdWV9LCBOZXcgdHlwZTogJHt0eXBlb2Ygc291cmNlVmFsdWV9LiBPdmVyd3JpdGluZy5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IHNvdXJjZVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBjb25zdCBtZXJnZWRCb2R5ID0gZGVlcE1lcmdlKGN1cnJlbnRCb2R5T2JqZWN0LCBleHRyYUJvZHkpO1xuICAgIHJlcXVlc3RJbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShtZXJnZWRCb2R5KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gVE9ETzogYi80MTYwNDEyMjkgLSBEZXRlcm1pbmUgaG93IHRvIHJldHJpZXZlIHRoZSBNQ1AgcGFja2FnZSB2ZXJzaW9uLlxuY29uc3QgTUNQX0xBQkVMID0gJ21jcF91c2VkL3Vua25vd24nO1xuLy8gV2hldGhlciBNQ1AgdG9vbCB1c2FnZSBpcyBkZXRlY3RlZCBmcm9tIG1jcFRvVG9vbC4gVGhpcyBpcyB1c2VkIGZvclxuLy8gdGVsZW1ldHJ5LlxubGV0IGhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2wgPSBmYWxzZTtcbi8vIENoZWNrcyB3aGV0aGVyIHRoZSBsaXN0IG9mIHRvb2xzIGNvbnRhaW5zIGFueSBNQ1AgdG9vbHMuXG5mdW5jdGlvbiBoYXNNY3BUb29sVXNhZ2UodG9vbHMpIHtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICAgICAgaWYgKGlzTWNwQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvb2wgPT09ICdvYmplY3QnICYmICdpbnB1dFNjaGVtYScgaW4gdG9vbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2w7XG59XG4vLyBTZXRzIHRoZSBNQ1AgdmVyc2lvbiBsYWJlbCBpbiB0aGUgR29vZ2xlIEFQSSBjbGllbnQgaGVhZGVyLlxuZnVuY3Rpb24gc2V0TWNwVXNhZ2VIZWFkZXIoaGVhZGVycykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBleGlzdGluZ0hlYWRlciA9IChfYSA9IGhlYWRlcnNbR09PR0xFX0FQSV9DTElFTlRfSEVBREVSXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgaGVhZGVyc1tHT09HTEVfQVBJX0NMSUVOVF9IRUFERVJdID0gKGV4aXN0aW5nSGVhZGVyICsgYCAke01DUF9MQUJFTH1gKS50cmltU3RhcnQoKTtcbn1cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgTUNQIENhbGxhYmxlVG9vbCwgb3RoZXJ3aXNlIGZhbHNlLlxuZnVuY3Rpb24gaXNNY3BDYWxsYWJsZVRvb2wob2JqZWN0KSB7XG4gICAgcmV0dXJuIChvYmplY3QgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb2JqZWN0IGluc3RhbmNlb2YgTWNwQ2FsbGFibGVUb29sKTtcbn1cbi8vIExpc3QgYWxsIHRvb2xzIGZyb20gdGhlIE1DUCBjbGllbnQuXG5mdW5jdGlvbiBsaXN0QWxsVG9vbHMobWNwQ2xpZW50XzEpIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBsaXN0QWxsVG9vbHNfMShtY3BDbGllbnQsIG1heFRvb2xzID0gMTAwKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBudW1Ub29scyA9IDA7XG4gICAgICAgIHdoaWxlIChudW1Ub29scyA8IG1heFRvb2xzKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0geWllbGQgX19hd2FpdChtY3BDbGllbnQubGlzdFRvb2xzKHsgY3Vyc29yIH0pKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiB0LnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0b29sKTtcbiAgICAgICAgICAgICAgICBudW1Ub29scysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0Lm5leHRDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnNvciA9IHQubmV4dEN1cnNvcjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBNY3BDYWxsYWJsZVRvb2wgY2FuIGJlIHVzZWQgZm9yIG1vZGVsIGluZmVyZW5jZSBhbmQgaW52b2tpbmcgTUNQIGNsaWVudHMgd2l0aFxuICogZ2l2ZW4gZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpbiBmdXR1cmVcbiAqIHZlcnNpb25zLlxuICovXG5jbGFzcyBNY3BDYWxsYWJsZVRvb2wge1xuICAgIGNvbnN0cnVjdG9yKG1jcENsaWVudHMgPSBbXSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMubWNwVG9vbHMgPSBbXTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCA9IHt9O1xuICAgICAgICB0aGlzLm1jcENsaWVudHMgPSBtY3BDbGllbnRzO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1jcENhbGxhYmxlVG9vbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKG1jcENsaWVudHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IE1jcENhbGxhYmxlVG9vbChtY3BDbGllbnRzLCBjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGZ1bmN0aW9uIG5hbWVzIGFyZSBub3QgZHVwbGljYXRlIGFuZCBpbml0aWFsaXplIHRoZSBmdW5jdGlvblxuICAgICAqIG5hbWUgdG8gTUNQIGNsaWVudCBtYXBwaW5nLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBNQ1AgdG9vbHMgZnJvbSB0aGUgTUNQIGNsaWVudHMgaGF2ZSBkdXBsaWNhdGUgdG9vbFxuICAgICAqICAgICBuYW1lcy5cbiAgICAgKi9cbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICBpZiAodGhpcy5tY3BUb29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25NYXAgPSB7fTtcbiAgICAgICAgY29uc3QgbWNwVG9vbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtY3BDbGllbnQgb2YgdGhpcy5tY3BDbGllbnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgX2UgPSAoZV8xID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKGxpc3RBbGxUb29scyhtY3BDbGllbnQpKSksIF9mOyBfZiA9IGF3YWl0IF9lLm5leHQoKSwgX2EgPSBfZi5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtY3BUb29sID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIG1jcFRvb2xzLnB1c2gobWNwVG9vbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1jcFRvb2xOYW1lID0gbWNwVG9vbC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25NYXBbbWNwVG9vbE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBmdW5jdGlvbiBuYW1lICR7bWNwVG9vbE5hbWV9IGZvdW5kIGluIE1DUCB0b29scy4gUGxlYXNlIGVuc3VyZSBmdW5jdGlvbiBuYW1lcyBhcmUgdW5pcXVlLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTWFwW21jcFRvb2xOYW1lXSA9IG1jcENsaWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1jcFRvb2xzID0gbWNwVG9vbHM7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQgPSBmdW5jdGlvbk1hcDtcbiAgICB9XG4gICAgYXN5bmMgdG9vbCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiBtY3BUb29sc1RvR2VtaW5pVG9vbCh0aGlzLm1jcFRvb2xzLCB0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGxUb29sKGZ1bmN0aW9uQ2FsbHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvbkNhbGwgb2YgZnVuY3Rpb25DYWxscykge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5uYW1lIGluIHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtY3BDbGllbnQgPSB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50W2Z1bmN0aW9uQ2FsbC5uYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYi80MjQyMzg2NTQgLSBBZGQgc3VwcG9ydCBmb3IgZmluZXIgZ3JhaW5lZCB0aW1lb3V0IGNvbnRyb2wuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLmNvbmZpZy50aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsVG9vbFJlc3BvbnNlID0gYXdhaXQgbWNwQ2xpZW50LmNhbGxUb29sKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25DYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogZnVuY3Rpb25DYWxsLmFyZ3MsXG4gICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSByZXN1bHQgc2NoZW1hIHRvIHVuZGVmaW5lZCB0byBhbGxvdyBNQ1AgdG8gcmVseSBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHNjaGVtYS5cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBjYWxsVG9vbFJlc3BvbnNlLmlzRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgZXJyb3I6IGNhbGxUb29sUmVzcG9uc2UgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2FsbFRvb2xSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cztcbiAgICB9XG59XG5mdW5jdGlvbiBpc01jcENsaWVudChjbGllbnQpIHtcbiAgICByZXR1cm4gKGNsaWVudCAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnbGlzdFRvb2xzJyBpbiBjbGllbnQgJiZcbiAgICAgICAgdHlwZW9mIGNsaWVudC5saXN0VG9vbHMgPT09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgTWNwQ2FsbGFibGVUb29sIGZyb20gTUNQIGNsaWVudHMgYW5kIGFuIG9wdGlvbmFsIGNvbmZpZy5cbiAqXG4gKiBUaGUgY2FsbGFibGUgdG9vbCBjYW4gaW52b2tlIHRoZSBNQ1AgY2xpZW50cyB3aXRoIGdpdmVuIGZ1bmN0aW9uIGNhbGxcbiAqIGFyZ3VtZW50cy4gKG9mdGVuIGZvciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZykuXG4gKiBVc2UgdGhlIGNvbmZpZyB0byBtb2RpZnkgdG9vbCBwYXJhbWV0ZXJzIHN1Y2ggYXMgYmVoYXZpb3IuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpbiBmdXR1cmVcbiAqIHZlcnNpb25zLlxuICovXG5mdW5jdGlvbiBtY3BUb1Rvb2woLi4uYXJncykge1xuICAgIC8vIFNldCBNQ1AgdXNhZ2UgZm9yIHRlbGVtZXRyeS5cbiAgICBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sID0gdHJ1ZTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBNQ1AgY2xpZW50cyBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBjb25zdCBtYXliZUNvbmZpZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNNY3BDbGllbnQobWF5YmVDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBNY3BDYWxsYWJsZVRvb2wuY3JlYXRlKGFyZ3MsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIE1jcENhbGxhYmxlVG9vbC5jcmVhdGUoYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpLCBtYXliZUNvbmZpZyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogSGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgaW5jb21pbmcgbWVzc2FnZXMsIHRyYW5zZm9ybWluZyB0aGVtXG4gKiBpbnRvIExpdmVNdXNpY1NlcnZlck1lc3NhZ2UsIGFuZCB0aGVuIGNhbGxpbmcgdGhlIG9ubWVzc2FnZSBjYWxsYmFjay5cbiAqIE5vdGUgdGhhdCB0aGUgZmlyc3QgbWVzc2FnZSB3aGljaCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgYVxuICogc2V0dXBDb21wbGV0ZSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBhcGlDbGllbnQgVGhlIEFwaUNsaWVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvbm1lc3NhZ2UgVGhlIHVzZXItcHJvdmlkZWQgb25tZXNzYWdlIGNhbGxiYWNrIChpZiBhbnkpLlxuICogQHBhcmFtIGV2ZW50IFRoZSBNZXNzYWdlRXZlbnQgZnJvbSB0aGUgV2ViU29ja2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlJDEoYXBpQ2xpZW50LCBvbm1lc3NhZ2UsIGV2ZW50KSB7XG4gICAgY29uc3Qgc2VydmVyTWVzc2FnZSA9IG5ldyBMaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlKCk7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKGV2ZW50LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGF3YWl0IGV2ZW50LmRhdGEudGV4dCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIGRhdGEpO1xuICAgIG9ubWVzc2FnZShzZXJ2ZXJNZXNzYWdlKTtcbn1cbi8qKlxuICAgTGl2ZU11c2ljIGNsYXNzIGVuY2Fwc3VsYXRlcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgbGl2ZSBtdXNpY1xuICAgZ2VuZXJhdGlvbiB2aWEgTHlyaWEgTGl2ZSBtb2RlbHMuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmVNdXNpYyB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBhdXRoLCB3ZWJTb2NrZXRGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLndlYlNvY2tldEZhY3RvcnkgPSB3ZWJTb2NrZXRGYWN0b3J5O1xuICAgIH1cbiAgICAvKipcbiAgICAgICBFc3RhYmxpc2hlcyBhIGNvbm5lY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBtb2RlbCBhbmQgcmV0dXJucyBhXG4gICAgICAgTGl2ZU11c2ljU2Vzc2lvbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoYXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgICBAcmVtYXJrc1xuICBcbiAgICAgICBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVzdGFibGlzaGluZyBhIGNvbm5lY3Rpb24gdG8gdGhlIG1vZGVsLlxuICAgICAgIEByZXR1cm4gQSBsaXZlIHNlc3Npb24uXG4gIFxuICAgICAgIEBleGFtcGxlXG4gICAgICAgYGBgdHNcbiAgICAgICBsZXQgbW9kZWwgPSAnbW9kZWxzL2x5cmlhLXJlYWx0aW1lLWV4cCc7XG4gICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGFpLmxpdmUubXVzaWMuY29ubmVjdCh7XG4gICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgb25tZXNzYWdlOiAoZTogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyOiAlc1xcbicsIGRlYnVnKGUuZGF0YSkpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmVycm9yOiAoZTogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZDogJXNcXG4nLCBkZWJ1ZyhlLmVycm9yKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uY2xvc2U6IChlOiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gY2xvc2VkLicpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgfSxcbiAgICAgICB9KTtcbiAgICAgICBgYGBcbiAgICAgICovXG4gICAgYXN5bmMgY29ubmVjdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaXZlIG11c2ljIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oJ0xpdmUgbXVzaWMgZ2VuZXJhdGlvbiBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLicpO1xuICAgICAgICBjb25zdCB3ZWJzb2NrZXRCYXNlVXJsID0gdGhpcy5hcGlDbGllbnQuZ2V0V2Vic29ja2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCBhcGlWZXJzaW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpVmVyc2lvbigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWFwVG9IZWFkZXJzJDEodGhpcy5hcGlDbGllbnQuZ2V0RGVmYXVsdEhlYWRlcnMoKSk7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaUtleSgpO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuYWkuZ2VuZXJhdGl2ZWxhbmd1YWdlLiR7YXBpVmVyc2lvbn0uR2VuZXJhdGl2ZVNlcnZpY2UuQmlkaUdlbmVyYXRlTXVzaWM/a2V5PSR7YXBpS2V5fWA7XG4gICAgICAgIGxldCBvbm9wZW5SZXNvbHZlID0gKCkgPT4geyB9O1xuICAgICAgICBjb25zdCBvbm9wZW5Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gcGFyYW1zLmNhbGxiYWNrcztcbiAgICAgICAgY29uc3Qgb25vcGVuQXdhaXRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb25vcGVuUmVzb2x2ZSh7fSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICBjb25zdCB3ZWJzb2NrZXRDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBvbm9wZW46IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayxcbiAgICAgICAgICAgIG9ubWVzc2FnZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdm9pZCBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlJDEoYXBpQ2xpZW50LCBjYWxsYmFja3Mub25tZXNzYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lcnJvcjogKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbG9zZTogKF9iID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uID0gdGhpcy53ZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZSh1cmwsIGhlYWRlcnNUb01hcCQxKGhlYWRlcnMpLCB3ZWJzb2NrZXRDYWxsYmFja3MpO1xuICAgICAgICBjb25uLmNvbm5lY3QoKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdlYnNvY2tldCB0byBvcGVuIGJlZm9yZSBzZW5kaW5nIHJlcXVlc3RzLlxuICAgICAgICBhd2FpdCBvbm9wZW5Qcm9taXNlO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRNb2RlbCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zLm1vZGVsKTtcbiAgICAgICAgY29uc3Qgc2V0dXAgPSB7IG1vZGVsIH07XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB7IHNldHVwIH07XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgTGl2ZU11c2ljU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxufVxuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlTXVzaWNTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2V0cyBpbnB1dHMgdG8gc3RlZXIgbXVzaWMgZ2VuZXJhdGlvbi4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIHdlaWdodGVkIHByb21wdHMuXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIG9uZSBwcm9wZXJ0eSwgYHdlaWdodGVkUHJvbXB0c2AuXG4gIFxuICAgICAgICAtIGB3ZWlnaHRlZFByb21wdHNgIHRvIHNlbmQgdG8gdGhlIG1vZGVsOyB3ZWlnaHRzIGFyZSBub3JtYWxpemVkIHRvXG4gICAgICAgICAgc3VtIHRvIDEuMC5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgc2V0V2VpZ2h0ZWRQcm9tcHRzKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy53ZWlnaHRlZFByb21wdHMgfHxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcy53ZWlnaHRlZFByb21wdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWlnaHRlZCBwcm9tcHRzIG11c3QgYmUgc2V0IGFuZCBjb250YWluIGF0IGxlYXN0IG9uZSBlbnRyeS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRDb250ZW50ID0gbGl2ZU11c2ljU2V0V2VpZ2h0ZWRQcm9tcHRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoeyBjbGllbnRDb250ZW50IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZXRzIGEgY29uZmlndXJhdGlvbiB0byB0aGUgbW9kZWwuIFVwZGF0ZXMgdGhlIHNlc3Npb24ncyBjdXJyZW50XG4gICAgICBtdXNpYyBnZW5lcmF0aW9uIGNvbmZpZy5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgb25lIHByb3BlcnR5LCBgbXVzaWNHZW5lcmF0aW9uQ29uZmlnYC5cbiAgXG4gICAgICAgIC0gYG11c2ljR2VuZXJhdGlvbkNvbmZpZ2AgdG8gc2V0IGluIHRoZSBtb2RlbC4gUGFzc2luZyBhbiBlbXB0eSBvclxuICAgICAgdW5kZWZpbmVkIGNvbmZpZyB0byB0aGUgbW9kZWwgd2lsbCByZXNldCB0aGUgY29uZmlnIHRvIGRlZmF1bHRzLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBzZXRNdXNpY0dlbmVyYXRpb25Db25maWcocGFyYW1zKSB7XG4gICAgICAgIGlmICghcGFyYW1zLm11c2ljR2VuZXJhdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgcGFyYW1zLm11c2ljR2VuZXJhdGlvbkNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNldENvbmZpZ1BhcmFtZXRlcnMgPSBsaXZlTXVzaWNTZXRDb25maWdQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShzZXRDb25maWdQYXJhbWV0ZXJzKSk7XG4gICAgfVxuICAgIHNlbmRQbGF5YmFja0NvbnRyb2wocGxheWJhY2tDb250cm9sKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB7IHBsYXliYWNrQ29udHJvbCB9O1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBtdXNpYyBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgcGxheSgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5QTEFZKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJpbHkgaGFsdCB0aGUgbXVzaWMgc3RyZWFtLiBVc2UgYHBsYXlgIHRvIHJlc3VtZSBmcm9tIHRoZSBjdXJyZW50XG4gICAgICogcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuUEFVU0UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBtdXNpYyBzdHJlYW0gYW5kIHJlc2V0IHRoZSBzdGF0ZS4gUmV0YWlucyB0aGUgY3VycmVudCBwcm9tcHRzXG4gICAgICogYW5kIGNvbmZpZy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlNUT1ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGNvbnRleHQgb2YgdGhlIG11c2ljIGdlbmVyYXRpb24gd2l0aG91dCBzdG9wcGluZyBpdC5cbiAgICAgKiBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHMgYW5kIGNvbmZpZy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICByZXNldENvbnRleHQoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuUkVTRVRfQ09OVEVYVCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIFRlcm1pbmF0ZXMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgIH1cbn1cbi8vIENvbnZlcnRzIGFuIGhlYWRlcnMgb2JqZWN0IHRvIGEgXCJtYXBcIiBvYmplY3QgYXMgZXhwZWN0ZWQgYnkgdGhlIFdlYlNvY2tldFxuLy8gY29uc3RydWN0b3IuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0c1xuLy8gd2hpbGUgdGhlIFdlYlNvY2tldCBjb25zdHJ1Y3RvciB0YWtlcyBhIG1hcC5cbmZ1bmN0aW9uIGhlYWRlcnNUb01hcCQxKGhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJNYXAgPSB7fTtcbiAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaGVhZGVyTWFwW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyTWFwO1xufVxuLy8gQ29udmVydHMgYSBcIm1hcFwiIG9iamVjdCB0byBhIGhlYWRlcnMgb2JqZWN0LiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aFxuLy8gaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzIHdoaWxlIHRoZSBBUEkgY2xpZW50IGRlZmF1bHQgaGVhZGVyc1xuLy8gcmV0dXJucyBhIG1hcC5cbmZ1bmN0aW9uIG1hcFRvSGVhZGVycyQxKG1hcCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1hcCkpIHtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBGVU5DVElPTl9SRVNQT05TRV9SRVFVSVJFU19JRCA9ICdGdW5jdGlvblJlc3BvbnNlIHJlcXVlc3QgbXVzdCBoYXZlIGFuIGBpZGAgZmllbGQgZnJvbSB0aGUgcmVzcG9uc2Ugb2YgYSBUb29sQ2FsbC5GdW5jdGlvbmFsQ2FsbHMgaW4gR29vZ2xlIEFJLic7XG4vKipcbiAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgV2ViU29ja2V0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIGluY29taW5nIG1lc3NhZ2VzLCB0cmFuc2Zvcm1pbmcgdGhlbVxuICogaW50byBMaXZlU2VydmVyTWVzc2FnZXMsIGFuZCB0aGVuIGNhbGxpbmcgdGhlIG9ubWVzc2FnZSBjYWxsYmFjay4gTm90ZSB0aGF0XG4gKiB0aGUgZmlyc3QgbWVzc2FnZSB3aGljaCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgYSBzZXR1cENvbXBsZXRlXG4gKiBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBhcGlDbGllbnQgVGhlIEFwaUNsaWVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvbm1lc3NhZ2UgVGhlIHVzZXItcHJvdmlkZWQgb25tZXNzYWdlIGNhbGxiYWNrIChpZiBhbnkpLlxuICogQHBhcmFtIGV2ZW50IFRoZSBNZXNzYWdlRXZlbnQgZnJvbSB0aGUgV2ViU29ja2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlKGFwaUNsaWVudCwgb25tZXNzYWdlLCBldmVudCkge1xuICAgIGNvbnN0IHNlcnZlck1lc3NhZ2UgPSBuZXcgTGl2ZVNlcnZlck1lc3NhZ2UoKTtcbiAgICBsZXQganNvbkRhdGE7XG4gICAgaWYgKGV2ZW50LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGpzb25EYXRhID0gYXdhaXQgZXZlbnQuZGF0YS50ZXh0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50LmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBqc29uRGF0YSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShldmVudC5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGpzb25EYXRhID0gZXZlbnQuZGF0YTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbkRhdGEpO1xuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgoZGF0YSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2VydmVyTWVzc2FnZSwgcmVzcCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByZXNwID0gZGF0YTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2ZXJNZXNzYWdlLCByZXNwKTtcbiAgICB9XG4gICAgb25tZXNzYWdlKHNlcnZlck1lc3NhZ2UpO1xufVxuLyoqXG4gICBMaXZlIGNsYXNzIGVuY2Fwc3VsYXRlcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgbGl2ZSBpbnRlcmFjdGlvbiB3aXRoIHRoZVxuICAgR2VuZXJhdGl2ZSBMYW5ndWFnZSBBUEkuIEl0IGVtYmVkcyBBcGlDbGllbnQgZm9yIGdlbmVyYWwgQVBJIHNldHRpbmdzLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIGF1dGgsIHdlYlNvY2tldEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMud2ViU29ja2V0RmFjdG9yeSA9IHdlYlNvY2tldEZhY3Rvcnk7XG4gICAgICAgIHRoaXMubXVzaWMgPSBuZXcgTGl2ZU11c2ljKHRoaXMuYXBpQ2xpZW50LCB0aGlzLmF1dGgsIHRoaXMud2ViU29ja2V0RmFjdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIEVzdGFibGlzaGVzIGEgY29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIG1vZGVsIHdpdGggdGhlIGdpdmVuXG4gICAgICAgY29uZmlndXJhdGlvbiBhbmQgcmV0dXJucyBhIFNlc3Npb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGF0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWwgQnVpbHQtaW4gTUNQIHN1cHBvcnQgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUsIG1heSBjaGFuZ2UgaW5cbiAgICAgICBmdXR1cmUgdmVyc2lvbnMuXG4gIFxuICAgICAgIEByZW1hcmtzXG4gIFxuICAgICAgIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbiB0byB0aGUgbW9kZWwuXG4gICAgICAgQHJldHVybiBBIGxpdmUgc2Vzc2lvbi5cbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbDogc3RyaW5nO1xuICAgICAgIGlmIChHT09HTEVfR0VOQUlfVVNFX1ZFUlRFWEFJKSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktMi4wLWZsYXNoLWxpdmUtcHJldmlldy0wNC0wOSc7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS1saXZlLTIuNS1mbGFzaC1wcmV2aWV3JztcbiAgICAgICB9XG4gICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGFpLmxpdmUuY29ubmVjdCh7XG4gICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dLFxuICAgICAgICAgfSxcbiAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICBvbm9wZW46ICgpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGVkIHRvIHRoZSBzb2NrZXQuJyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9ubWVzc2FnZTogKGU6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlcjogJXNcXG4nLCBkZWJ1ZyhlLmRhdGEpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25lcnJvcjogKGU6IEVycm9yRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3Igb2NjdXJyZWQ6ICVzXFxuJywgZGVidWcoZS5lcnJvcikpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmNsb3NlOiAoZTogQ2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIGNsb3NlZC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgIH0sXG4gICAgICAgfSk7XG4gICAgICAgYGBgXG4gICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAvLyBUT0RPOiBiLzQwNDk0Njc0NiAtIFN1cHBvcnQgcGVyIHJlcXVlc3QgSFRUUCBvcHRpb25zLlxuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJiBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBMaXZlIG1vZHVsZSBkb2VzIG5vdCBzdXBwb3J0IGh0dHBPcHRpb25zIGF0IHJlcXVlc3QtbGV2ZWwgaW4nICtcbiAgICAgICAgICAgICAgICAnIExpdmVDb25uZWN0Q29uZmlnIHlldC4gUGxlYXNlIHVzZSB0aGUgY2xpZW50LWxldmVsIGh0dHBPcHRpb25zJyArXG4gICAgICAgICAgICAgICAgJyBjb25maWd1cmF0aW9uIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2Vic29ja2V0QmFzZVVybCA9IHRoaXMuYXBpQ2xpZW50LmdldFdlYnNvY2tldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbiA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaVZlcnNpb24oKTtcbiAgICAgICAgbGV0IHVybDtcbiAgICAgICAgY29uc3QgY2xpZW50SGVhZGVycyA9IHRoaXMuYXBpQ2xpZW50LmdldEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKHBhcmFtcy5jb25maWcgJiZcbiAgICAgICAgICAgIHBhcmFtcy5jb25maWcudG9vbHMgJiZcbiAgICAgICAgICAgIGhhc01jcFRvb2xVc2FnZShwYXJhbXMuY29uZmlnLnRvb2xzKSkge1xuICAgICAgICAgICAgc2V0TWNwVXNhZ2VIZWFkZXIoY2xpZW50SGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1hcFRvSGVhZGVycyhjbGllbnRIZWFkZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdXJsID0gYCR7d2Vic29ja2V0QmFzZVVybH0vd3MvZ29vZ2xlLmNsb3VkLmFpcGxhdGZvcm0uJHthcGlWZXJzaW9ufS5MbG1CaWRpU2VydmljZS9CaWRpR2VuZXJhdGVDb250ZW50YDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aC5hZGRBdXRoSGVhZGVycyhoZWFkZXJzLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpS2V5KCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gJ0JpZGlHZW5lcmF0ZUNvbnRlbnQnO1xuICAgICAgICAgICAgbGV0IGtleU5hbWUgPSAna2V5JztcbiAgICAgICAgICAgIGlmIChhcGlLZXkgPT09IG51bGwgfHwgYXBpS2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlLZXkuc3RhcnRzV2l0aCgnYXV0aF90b2tlbnMvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IEVwaGVtZXJhbCB0b2tlbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGFwaVZlcnNpb24gIT09ICd2MWFscGhhJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBUaGUgU0RLJ3MgZXBoZW1lcmFsIHRva2VuIHN1cHBvcnQgaXMgaW4gdjFhbHBoYSBvbmx5LiBQbGVhc2UgdXNlIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6IHRva2VuLm5hbWUsIGh0dHBPcHRpb25zOiB7IGFwaVZlcnNpb246ICd2MWFscGhhJyB9fSk7IGJlZm9yZSBzZXNzaW9uIGNvbm5lY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnQmlkaUdlbmVyYXRlQ29udGVudENvbnN0cmFpbmVkJztcbiAgICAgICAgICAgICAgICBrZXlOYW1lID0gJ2FjY2Vzc190b2tlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuYWkuZ2VuZXJhdGl2ZWxhbmd1YWdlLiR7YXBpVmVyc2lvbn0uR2VuZXJhdGl2ZVNlcnZpY2UuJHttZXRob2R9PyR7a2V5TmFtZX09JHthcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcyk7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBjYWxsYmFja3Mub25tZXNzYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lcnJvcjogKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbG9zZTogKF9iID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uID0gdGhpcy53ZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZSh1cmwsIGhlYWRlcnNUb01hcChoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IHRoaXMuYXBpQ2xpZW50LmdldFByb2plY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwgPVxuICAgICAgICAgICAgICAgIGBwcm9qZWN0cy8ke3Byb2plY3R9L2xvY2F0aW9ucy8ke2xvY2F0aW9ufS9gICsgdHJhbnNmb3JtZWRNb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xpZW50TWVzc2FnZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmXG4gICAgICAgICAgICAoKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc3BvbnNlTW9kYWxpdGllcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IGRlZmF1bHQgdG8gQVVESU8gdG8gYWxpZ24gd2l0aCBNTERldiBBUEkuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZyA9IHsgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnLnJlc3BvbnNlTW9kYWxpdGllcyA9IFtNb2RhbGl0eS5BVURJT107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5nZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyBSYWlzZSBkZXByZWNhdGlvbiB3YXJuaW5nIGZvciBnZW5lcmF0aW9uQ29uZmlnLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdTZXR0aW5nIGBMaXZlQ29ubmVjdENvbmZpZy5nZW5lcmF0aW9uX2NvbmZpZ2AgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHNldCB0aGUgZmllbGRzIG9uIGBMaXZlQ29ubmVjdENvbmZpZ2AgZGlyZWN0bHkuIFRoaXMgd2lsbCBiZWNvbWUgYW4gZXJyb3IgaW4gYSBmdXR1cmUgdmVyc2lvbiAobm90IGJlZm9yZSBRMyAyMDI1KS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFRvb2xzID0gKF9mID0gKF9lID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvb2xzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBbXTtcbiAgICAgICAgY29uc3QgY29udmVydGVkVG9vbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIGlucHV0VG9vbHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRUb29scy5wdXNoKGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVkVG9vbHMucHVzaCh0b29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udmVydGVkVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyA9IGNvbnZlcnRlZFRvb2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpdmVDb25uZWN0UGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIG1vZGVsOiB0cmFuc2Zvcm1lZE1vZGVsLFxuICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBwYXJhbXMuY2FsbGJhY2tzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGxpdmVDb25uZWN0UGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY2xpZW50TWVzc2FnZVsnY29uZmlnJ107XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxuICAgIC8vIFRPRE86IGIvNDE2MDQxMjI5IC0gQWJzdHJhY3QgdGhpcyBtZXRob2QgdG8gYSBjb21tb24gcGxhY2UuXG4gICAgaXNDYWxsYWJsZVRvb2wodG9vbCkge1xuICAgICAgICByZXR1cm4gJ2NhbGxUb29sJyBpbiB0b29sICYmIHR5cGVvZiB0b29sLmNhbGxUb29sID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyA9IHtcbiAgICB0dXJuQ29tcGxldGU6IHRydWUsXG59O1xuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIHRMaXZlQ2xpZW50Q29udGVudChhcGlDbGllbnQsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnR1cm5zICE9PSBudWxsICYmIHBhcmFtcy50dXJucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudHMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSB0Q29udGVudHMocGFyYW1zLnR1cm5zKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5tYXAoKGl0ZW0pID0+IGNvbnRlbnRUb01sZGV2JDEoaXRlbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIGNsaWVudCBjb250ZW50IFwidHVybnNcIiwgdHlwZTogJyR7dHlwZW9mIHBhcmFtcy50dXJuc30nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsaWVudENvbnRlbnQ6IHsgdHVybnM6IGNvbnRlbnRzLCB0dXJuQ29tcGxldGU6IHBhcmFtcy50dXJuQ29tcGxldGUgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudENvbnRlbnQ6IHsgdHVybkNvbXBsZXRlOiBwYXJhbXMudHVybkNvbXBsZXRlIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZShhcGlDbGllbnQsIHBhcmFtcykge1xuICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICAgICAgaWYgKHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uUmVzcG9uc2VzIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMpKSB7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcyA9IFtwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZXMgPSBwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmN0aW9uUmVzcG9uc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvblJlc3BvbnNlcyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2Ugb2YgZnVuY3Rpb25SZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgISgnbmFtZScgaW4gZnVuY3Rpb25SZXNwb25zZSkgfHxcbiAgICAgICAgICAgICAgICAhKCdyZXNwb25zZScgaW4gZnVuY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBmdW5jdGlvbiByZXNwb25zZSwgdHlwZSAnJHt0eXBlb2YgZnVuY3Rpb25SZXNwb25zZX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmICEoJ2lkJyBpbiBmdW5jdGlvblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihGVU5DVElPTl9SRVNQT05TRV9SRVFVSVJFU19JRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHRvb2xSZXNwb25zZTogeyBmdW5jdGlvblJlc3BvbnNlczogZnVuY3Rpb25SZXNwb25zZXMgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsaWVudE1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgdHdvICoqb3B0aW9uYWwqKiBwcm9wZXJ0aWVzLCBgdHVybnNgIGFuZFxuICAgICAgICAgIGB0dXJuQ29tcGxldGVgLlxuICBcbiAgICAgICAgLSBgdHVybnNgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYENvbnRlbnRbXWBcbiAgICAgICAgLSBgdHVybkNvbXBsZXRlOiB0cnVlYCBbZGVmYXVsdF0gaW5kaWNhdGVzIHRoYXQgeW91IGFyZSBkb25lIHNlbmRpbmdcbiAgICAgICAgICBjb250ZW50IGFuZCBleHBlY3QgYSByZXNwb25zZS4gSWYgYHR1cm5Db21wbGV0ZTogZmFsc2VgLCB0aGUgc2VydmVyXG4gICAgICAgICAgd2lsbCB3YWl0IGZvciBhZGRpdGlvbmFsIG1lc3NhZ2VzIGJlZm9yZSBzdGFydGluZyBnZW5lcmF0aW9uLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVGhlcmUgYXJlIHR3byB3YXlzIHRvIHNlbmQgbWVzc2FnZXMgdG8gdGhlIGxpdmUgQVBJOlxuICAgICAgYHNlbmRDbGllbnRDb250ZW50YCBhbmQgYHNlbmRSZWFsdGltZUlucHV0YC5cbiAgXG4gICAgICBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGFyZSBhZGRlZCB0byB0aGUgbW9kZWwgY29udGV4dCAqKmluIG9yZGVyKiouXG4gICAgICBIYXZpbmcgYSBjb252ZXJzYXRpb24gdXNpbmcgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBpcyByb3VnaGx5XG4gICAgICBlcXVpdmFsZW50IHRvIHVzaW5nIHRoZSBgQ2hhdC5zZW5kTWVzc2FnZVN0cmVhbWAsIGV4Y2VwdCB0aGF0IHRoZSBzdGF0ZSBvZlxuICAgICAgdGhlIGBjaGF0YCBoaXN0b3J5IGlzIHN0b3JlZCBvbiB0aGUgQVBJIHNlcnZlciBpbnN0ZWFkIG9mIGxvY2FsbHkuXG4gIFxuICAgICAgQmVjYXVzZSBvZiBgc2VuZENsaWVudENvbnRlbnRgJ3Mgb3JkZXIgZ3VhcmFudGVlLCB0aGUgbW9kZWwgY2Fubm90IHJlc3BvbnNcbiAgICAgIGFzIHF1aWNrbHkgdG8gYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBhcyB0byBgc2VuZFJlYWx0aW1lSW5wdXRgXG4gICAgICBtZXNzYWdlcy4gVGhpcyBtYWtlcyB0aGUgYmlnZ2VzdCBkaWZmZXJlbmNlIHdoZW4gc2VuZGluZyBvYmplY3RzIHRoYXQgaGF2ZVxuICAgICAgc2lnbmlmaWNhbnQgcHJlcHJvY2Vzc2luZyB0aW1lICh0eXBpY2FsbHkgaW1hZ2VzKS5cbiAgXG4gICAgICBUaGUgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlIHNlbmRzIGEgYENvbnRlbnRbXWBcbiAgICAgIHdoaWNoIGhhcyBtb3JlIG9wdGlvbnMgdGhhbiB0aGUgYEJsb2JgIHNlbnQgYnkgYHNlbmRSZWFsdGltZUlucHV0YC5cbiAgXG4gICAgICBTbyB0aGUgbWFpbiB1c2UtY2FzZXMgZm9yIGBzZW5kQ2xpZW50Q29udGVudGAgb3ZlciBgc2VuZFJlYWx0aW1lSW5wdXRgIGFyZTpcbiAgXG4gICAgICAtIFNlbmRpbmcgYW55dGhpbmcgdGhhdCBjYW4ndCBiZSByZXByZXNlbnRlZCBhcyBhIGBCbG9iYCAodGV4dCxcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudCh7dHVybnM9XCJIZWxsbz9cIn1gKSkuXG4gICAgICAtIE1hbmFnaW5nIHR1cm5zIHdoZW4gbm90IHVzaW5nIGF1ZGlvIGlucHV0IGFuZCB2b2ljZSBhY3Rpdml0eSBkZXRlY3Rpb24uXG4gICAgICAgIChgc2VuZENsaWVudENvbnRlbnQoe3R1cm5Db21wbGV0ZTp0cnVlfSlgIG9yIHRoZSBzaG9ydCBmb3JtXG4gICAgICBgc2VuZENsaWVudENvbnRlbnQoKWApXG4gICAgICAtIFByZWZpbGxpbmcgYSBjb252ZXJzYXRpb24gY29udGV4dFxuICAgICAgICBgYGBcbiAgICAgICAgc2VuZENsaWVudENvbnRlbnQoe1xuICAgICAgICAgICAgdHVybnM6IFtcbiAgICAgICAgICAgICAgQ29udGVudCh7cm9sZTp1c2VyLCBwYXJ0czouLi59KSxcbiAgICAgICAgICAgICAgQ29udGVudCh7cm9sZTp1c2VyLCBwYXJ0czouLi59KSxcbiAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICAgIGBgYFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHNlbmRDbGllbnRDb250ZW50KHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyksIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB0aGlzLnRMaXZlQ2xpZW50Q29udGVudCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNlbmQgYSByZWFsdGltZSBtZXNzYWdlIG92ZXIgdGhlIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24uXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIG9uZSBwcm9wZXJ0eSwgYG1lZGlhYC5cbiAgXG4gICAgICAgIC0gYG1lZGlhYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBCbG9iYFxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVXNlIGBzZW5kUmVhbHRpbWVJbnB1dGAgZm9yIHJlYWx0aW1lIGF1ZGlvIGNodW5rcyBhbmQgdmlkZW8gZnJhbWVzIChpbWFnZXMpLlxuICBcbiAgICAgIFdpdGggYHNlbmRSZWFsdGltZUlucHV0YCB0aGUgYXBpIHdpbGwgcmVzcG9uZCB0byBhdWRpbyBhdXRvbWF0aWNhbGx5XG4gICAgICBiYXNlZCBvbiB2b2ljZSBhY3Rpdml0eSBkZXRlY3Rpb24gKFZBRCkuXG4gIFxuICAgICAgYHNlbmRSZWFsdGltZUlucHV0YCBpcyBvcHRpbWl6ZWQgZm9yIHJlc3BvbnNpdm5lc3MgYXQgdGhlIGV4cGVuc2Ugb2ZcbiAgICAgIGRldGVybWluaXN0aWMgb3JkZXJpbmcgZ3VhcmFudGVlcy4gQXVkaW8gYW5kIHZpZGVvIHRva2VucyBhcmUgdG8gdGhlXG4gICAgICBjb250ZXh0IHdoZW4gdGhleSBiZWNvbWUgYXZhaWxhYmxlLlxuICBcbiAgICAgIE5vdGU6IFRoZSBDYWxsIHNpZ25hdHVyZSBleHBlY3RzIGEgYEJsb2JgIG9iamVjdCwgYnV0IG9ubHkgYSBzdWJzZXRcbiAgICAgIG9mIGF1ZGlvIGFuZCBpbWFnZSBtaW1ldHlwZXMgYXJlIGFsbG93ZWQuXG4gICAgICovXG4gICAgc2VuZFJlYWx0aW1lSW5wdXQocGFyYW1zKSB7XG4gICAgICAgIGxldCBjbGllbnRNZXNzYWdlID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgJ3JlYWx0aW1lSW5wdXQnOiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICdyZWFsdGltZUlucHV0JzogbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNlbmQgYSBmdW5jdGlvbiByZXNwb25zZSBtZXNzYWdlIG92ZXIgdGhlIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24uXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIHByb3BlcnR5IGBmdW5jdGlvblJlc3BvbnNlc2AuXG4gIFxuICAgICAgICAtIGBmdW5jdGlvblJlc3BvbnNlc2Agd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgZnVuY3Rpb25SZXNwb25zZXNbXWBcbiAgXG4gICAgICBAcmVtYXJrc1xuICAgICAgVXNlIGBzZW5kRnVuY3Rpb25SZXNwb25zZWAgdG8gcmVwbHkgdG8gYExpdmVTZXJ2ZXJUb29sQ2FsbGAgZnJvbSB0aGUgc2VydmVyLlxuICBcbiAgICAgIFVzZSB7QGxpbmsgdHlwZXMuTGl2ZUNvbm5lY3RDb25maWcjdG9vbHN9IHRvIGNvbmZpZ3VyZSB0aGUgY2FsbGFibGUgZnVuY3Rpb25zLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBzZW5kVG9vbFJlc3BvbnNlKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9vbCByZXNwb25zZSBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0gdGhpcy50TGl2ZUNsaWVudHRUb29sUmVzcG9uc2UodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgVGVybWluYXRlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbDogc3RyaW5nO1xuICAgICAgIGlmIChHT09HTEVfR0VOQUlfVVNFX1ZFUlRFWEFJKSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktMi4wLWZsYXNoLWxpdmUtcHJldmlldy0wNC0wOSc7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS1saXZlLTIuNS1mbGFzaC1wcmV2aWV3JztcbiAgICAgICB9XG4gICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGFpLmxpdmUuY29ubmVjdCh7XG4gICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dLFxuICAgICAgICAgfVxuICAgICAgIH0pO1xuICBcbiAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgYGBgXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgIH1cbn1cbi8vIENvbnZlcnRzIGFuIGhlYWRlcnMgb2JqZWN0IHRvIGEgXCJtYXBcIiBvYmplY3QgYXMgZXhwZWN0ZWQgYnkgdGhlIFdlYlNvY2tldFxuLy8gY29uc3RydWN0b3IuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0c1xuLy8gd2hpbGUgdGhlIFdlYlNvY2tldCBjb25zdHJ1Y3RvciB0YWtlcyBhIG1hcC5cbmZ1bmN0aW9uIGhlYWRlcnNUb01hcChoZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyTWFwID0ge307XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlck1hcFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlck1hcDtcbn1cbi8vIENvbnZlcnRzIGEgXCJtYXBcIiBvYmplY3QgdG8gYSBoZWFkZXJzIG9iamVjdC4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGhcbi8vIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0cyB3aGlsZSB0aGUgQVBJIGNsaWVudCBkZWZhdWx0IGhlYWRlcnNcbi8vIHJldHVybnMgYSBtYXAuXG5mdW5jdGlvbiBtYXBUb0hlYWRlcnMobWFwKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IERFRkFVTFRfTUFYX1JFTU9URV9DQUxMUyA9IDEwO1xuLyoqIFJldHVybnMgd2hldGhlciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyBpcyBkaXNhYmxlZC4gKi9cbmZ1bmN0aW9uIHNob3VsZERpc2FibGVBZmMoY29uZmlnKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgY2FsbGFibGVUb29sc1ByZXNlbnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9iID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnRvb2xzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgIGNhbGxhYmxlVG9vbHNQcmVzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2FsbGFibGVUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG1heENhbGxzID0gKF9jID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1heGltdW1SZW1vdGVDYWxscztcbiAgICBpZiAoKG1heENhbGxzICYmIChtYXhDYWxscyA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIobWF4Q2FsbHMpKSkgfHxcbiAgICAgICAgbWF4Q2FsbHMgPT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgbWF4aW11bVJlbW90ZUNhbGxzIHZhbHVlIHByb3ZpZGVkIGZvciBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZy4gRGlzYWJsZWQgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcuIFBsZWFzZSBwcm92aWRlIGEgdmFsaWQgaW50ZWdlciB2YWx1ZSBncmVhdGVyIHRoYW4gMC4gbWF4aW11bVJlbW90ZUNhbGxzIHByb3ZpZGVkOicsIG1heENhbGxzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ2FsbGFibGVUb29sKHRvb2wpIHtcbiAgICByZXR1cm4gJ2NhbGxUb29sJyBpbiB0b29sICYmIHR5cGVvZiB0b29sLmNhbGxUb29sID09PSAnZnVuY3Rpb24nO1xufVxuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGxpc3Qgb2YgdG9vbHMgY29udGFpbnMgYW55IENhbGxhYmxlVG9vbHMuIFdpbGwgcmV0dXJuIHRydWVcbi8vIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBDYWxsYWJsZVRvb2wuXG5mdW5jdGlvbiBoYXNDYWxsYWJsZVRvb2xzKHBhcmFtcykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zb21lKCh0b29sKSA9PiBpc0NhbGxhYmxlVG9vbCh0b29sKSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleGVzIG9mIHRoZSB0b29scyB0aGF0IGFyZSBub3QgY29tcGF0aWJsZSB3aXRoIEFGQy5cbiAqL1xuZnVuY3Rpb24gZmluZEFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzKHBhcmFtcykge1xuICAgIHZhciBfYTtcbiAgICAvLyBVc2UgbnVtYmVyW10gZm9yIGFuIGFycmF5IG9mIG51bWJlcnMgaW4gVHlwZVNjcmlwdFxuICAgIGNvbnN0IGFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzID0gW107XG4gICAgaWYgKCEoKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzKSkge1xuICAgICAgICByZXR1cm4gYWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXM7XG4gICAgfVxuICAgIHBhcmFtcy5jb25maWcudG9vbHMuZm9yRWFjaCgodG9vbCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2VtaW5pVG9vbCA9IHRvb2w7XG4gICAgICAgIGlmIChnZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zICYmXG4gICAgICAgICAgICBnZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdG8gYXBwZW5kIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIGhpc3RvcnkgdG8gdGhlXG4gKiByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkQXBwZW5kQWZjSGlzdG9yeShjb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlnbm9yZUNhbGxIaXN0b3J5KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTW9kZWxzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYW4gQVBJIHJlcXVlc3QgdG8gZ2VuZXJhdGUgY29udGVudCB3aXRoIGEgZ2l2ZW4gbW9kZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAndHVuZWRNb2RlbHMvMTIzNDU2Nzg5MDEyMzQ1Njc4OSdcbiAgICAgICAgICpcbiAgICAgICAgICogU29tZSBtb2RlbHMgc3VwcG9ydCBtdWx0aW1vZGFsIGlucHV0IGFuZCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIGdlbmVyYXRpbmcgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIGNvbnRlbnRzOiAnd2h5IGlzIHRoZSBza3kgYmx1ZT8nLFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgY2FuZGlkYXRlQ291bnQ6IDIsXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDb250ZW50ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5tYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoIWhhc0NhbGxhYmxlVG9vbHMocGFyYW1zKSB8fCBzaG91bGREaXNhYmxlQWZjKHBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5jb21wYXRpYmxlVG9vbEluZGV4ZXMgPSBmaW5kQWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMocGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChpbmNvbXBhdGlibGVUb29sSW5kZXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkSW5kZXhlcyA9IGluY29tcGF0aWJsZVRvb2xJbmRleGVzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGluZGV4KSA9PiBgdG9vbHNbJHtpbmRleH1dYClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyB3aXRoIENhbGxhYmxlVG9vbHMgKG9yIE1DUCBvYmplY3RzKSBhbmQgYmFzaWMgRnVuY3Rpb25EZWNsYXJhdGlvbnMgaXMgbm90IHlldCBzdXBwb3J0ZWQuIEluY29tcGF0aWJsZSB0b29scyBmb3VuZCBhdCAke2Zvcm1hdHRlZEluZGV4ZXN9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50O1xuICAgICAgICAgICAgY29uc3QgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IHRDb250ZW50cyh0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cyk7XG4gICAgICAgICAgICBjb25zdCBtYXhSZW1vdGVDYWxscyA9IChfYyA9IChfYiA9IChfYSA9IHRyYW5zZm9ybWVkUGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heGltdW1SZW1vdGVDYWxscykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTO1xuICAgICAgICAgICAgbGV0IHJlbW90ZUNhbGxzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChyZW1vdGVDYWxscyA8IG1heFJlbW90ZUNhbGxzKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudEludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMgfHwgcmVzcG9uc2UuZnVuY3Rpb25DYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudCA9IHJlc3BvbnNlLmNhbmRpZGF0ZXNbMF0uY29udGVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvblJlc3BvbnNlUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9lID0gKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRvb2xzKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGF3YWl0IGNhbGxhYmxlVG9vbC5jYWxsVG9vbChyZXNwb25zZS5mdW5jdGlvbkNhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cy5wdXNoKC4uLnBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdGVDYWxscysrO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiBmdW5jdGlvblJlc3BvbnNlUGFydHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cyA9IHRDb250ZW50cyh0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cyk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMucHVzaChyZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzLnB1c2goZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRBcHBlbmRBZmNIaXN0b3J5KHRyYW5zZm9ybWVkUGFyYW1zLmNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5wdXNoKHJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkucHVzaChmdW5jdGlvblJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEFwcGVuZEFmY0hpc3RvcnkodHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgPVxuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYW4gQVBJIHJlcXVlc3QgdG8gZ2VuZXJhdGUgY29udGVudCB3aXRoIGEgZ2l2ZW4gbW9kZWwgYW5kIHlpZWxkcyB0aGVcbiAgICAgICAgICogcmVzcG9uc2UgaW4gY2h1bmtzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgVmVydGV4IEFJIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgZnVsbCByZXNvdXJjZSBuYW1lIHN0YXJ0cyB3aXRoICdwcm9qZWN0cy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwcm9qZWN0cy9teS1wcm9qZWN0LWlkL2xvY2F0aW9ucy91cy1jZW50cmFsMS9wdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgcGFydGlhbCByZXNvdXJjZSBuYW1lIHdpdGggJ3B1Ymxpc2hlcnMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnIG9yXG4gICAgICAgICAqICAncHVibGlzaGVycy9tZXRhL21vZGVscy9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKiAtIGAvYCBzZXBhcmF0ZWQgcHVibGlzaGVyIGFuZCBtb2RlbCBuYW1lLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogJ2dvb2dsZS9nZW1pbmktMi4wLWZsYXNoJyBvciAnbWV0YS9sbGFtYS0zLjEtNDA1Yi1pbnN0cnVjdC1tYWFzJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGBtb2RlbGAgcGFyYW1ldGVyLCBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgR2VtaW5pIEFQSSBpbmNsdWRlOlxuICAgICAgICAgKiAtIFRoZSBHZW1pbmkgbW9kZWwgSUQsIGZvciBleGFtcGxlOiAnZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBUaGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAnbW9kZWxzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIEZvciB0dW5lZCBtb2RlbHMsIHRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICd0dW5lZE1vZGVscy8nLFxuICAgICAgICAgKiBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICd0dW5lZE1vZGVscy8xMjM0NTY3ODkwMTIzNDU2Nzg5J1xuICAgICAgICAgKlxuICAgICAgICAgKiBTb21lIG1vZGVscyBzdXBwb3J0IG11bHRpbW9kYWwgaW5wdXQgYW5kIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIGNvbnRlbnQgd2l0aCBzdHJlYW1pbmcgcmVzcG9uc2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICAgICAqICAgY29udGVudHM6ICd3aHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICAgICAqICAgY29uZmlnOiB7XG4gICAgICAgICAqICAgICBtYXhPdXRwdXRUb2tlbnM6IDIwMCxcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coY2h1bmspO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0gPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgdGhpcy5tYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRGlzYWJsZUFmYyhwYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluY29tcGF0aWJsZVRvb2xJbmRleGVzID0gZmluZEFmY0luY29tcGF0aWJsZVRvb2xJbmRleGVzKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoaW5jb21wYXRpYmxlVG9vbEluZGV4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZEluZGV4ZXMgPSBpbmNvbXBhdGlibGVUb29sSW5kZXhlc1xuICAgICAgICAgICAgICAgICAgICAubWFwKChpbmRleCkgPT4gYHRvb2xzWyR7aW5kZXh9XWApXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIHRvb2xzIGZvdW5kIGF0ICR7Zm9ybWF0dGVkSW5kZXhlc30uIEF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdpdGggQ2FsbGFibGVUb29scyAob3IgTUNQIG9iamVjdHMpIGFuZCBiYXNpYyBGdW5jdGlvbkRlY2xhcmF0aW9uc1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2l0aCB0b29sIGNvbXBhdGliaWxpdHkgY29uZmlybWVkLCB2YWxpZGF0ZSB0aGF0IHRoZSBjb25maWd1cmF0aW9uIGFyZVxuICAgICAgICAgICAgLy8gY29tcGF0aWJsZSB3aXRoIGVhY2ggb3RoZXIgYW5kIHJhaXNlIGFuIGVycm9yIGlmIGludmFsaWQuXG4gICAgICAgICAgICBjb25zdCBzdHJlYW1GdW5jdGlvbkNhbGwgPSAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbENvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cztcbiAgICAgICAgICAgIGNvbnN0IGRpc2FibGVBZmMgPSAoX2UgPSAoX2QgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZGlzYWJsZTtcbiAgICAgICAgICAgIGlmIChzdHJlYW1GdW5jdGlvbkNhbGwgJiYgIWRpc2FibGVBZmMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uaW5nIGluIHN0cmVhbWluZyBtb2RlIHdpdGggJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cycgZW5hYmxlZCwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAndGhpcyBmZWF0dXJlIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgKEFGQykuICcgK1xuICAgICAgICAgICAgICAgICAgICBcIlBsZWFzZSBzZXQgJ2NvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcuZGlzYWJsZScgdG8gdHJ1ZSB0byBkaXNhYmxlIEFGQyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwib3IgbGVhdmUgJ2NvbmZpZy50b29sQ29uZmlnLmZ1bmN0aW9uQ2FsbGluZ0NvbmZpZy5zdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMnIFwiICtcbiAgICAgICAgICAgICAgICAgICAgJ3RvIGJlIHVuZGVmaW5lZCBvciBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBzdHJlYW1pbmcgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgZmVhdHVyZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb2Nlc3NBZmNTdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyBhbiBpbWFnZSBiYXNlZCBvbiBhIHRleHQgZGVzY3JpcHRpb24gYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLmdlbmVyYXRlSW1hZ2VzKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTQuMC1nZW5lcmF0ZS0wMDEnLFxuICAgICAgICAgKiAgcHJvbXB0OiAnUm9ib3QgaG9sZGluZyBhIHJlZCBza2F0ZWJvYXJkJyxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlSW1hZ2VzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkSW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGFwaVJlc3BvbnNlID09PSBudWxsIHx8IGFwaVJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0ZWRJbWFnZSBvZiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRJbWFnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9hID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50VHlwZSkgPT09ICdQb3NpdGl2ZSBQcm9tcHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXMucHVzaChnZW5lcmF0ZWRJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlczogcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrSHR0cFJlc3BvbnNlOiBhcGlSZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEltYWdlczogZ2VuZXJhdGVkSW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrSHR0cFJlc3BvbnNlOiBhcGlSZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5QmFzZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcpLCBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb25maWc6IGFjdHVhbENvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3R1YWxQYXJhbXMuY29uZmlnLnF1ZXJ5QmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gYWN0dWFsUGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWx0ZXJpbmcgdHVuZWQgbW9kZWxzIGxpc3QgZm9yIFZlcnRleCBBSSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsUGFyYW1zLmNvbmZpZy5maWx0ZXIgPSAnbGFiZWxzLnR1bmUtdHlwZToqJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fTU9ERUxTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKGFjdHVhbFBhcmFtcyksIGFjdHVhbFBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZGl0cyBhbiBpbWFnZSBiYXNlZCBvbiBhIHByb21wdCwgbGlzdCBvZiByZWZlcmVuY2UgaW1hZ2VzLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlZGl0aW5nIGFuIGltYWdlLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy5lZGl0SW1hZ2Uoe1xuICAgICAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWNhcGFiaWxpdHktMDAxJyxcbiAgICAgICAgICogIHByb21wdDogJ0dlbmVyYXRlIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBtdWcgd2l0aCB0aGUgcHJvZHVjdCBsb2dvIFsxXSB2aXNpYmxlIG9uIHRoZSBzaWRlIG9mIHRoZSBtdWcuJyxcbiAgICAgICAgICogIHJlZmVyZW5jZUltYWdlczogW3N1YmplY3RSZWZlcmVuY2VJbWFnZV1cbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRJbWFnZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc0ludGVybmFsID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJhbXMubW9kZWwsXG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwYXJhbXMucHJvbXB0LFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlczogW10sXG4gICAgICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucmVmZXJlbmNlSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5yZWZlcmVuY2VJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zSW50ZXJuYWwucmVmZXJlbmNlSW1hZ2VzID0gcGFyYW1zLnJlZmVyZW5jZUltYWdlcy5tYXAoKGltZykgPT4gaW1nLnRvUmVmZXJlbmNlSW1hZ2VBUEkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZWRpdEltYWdlSW50ZXJuYWwocGFyYW1zSW50ZXJuYWwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBzY2FsZXMgYW4gaW1hZ2UgYmFzZWQgb24gYW4gaW1hZ2UsIHVwc2NhbGUgZmFjdG9yLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogT25seSBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJIGN1cnJlbnRseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB1cHNjYWxpbmcgYW4gaW1hZ2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLnVwc2NhbGVJbWFnZSh7XG4gICAgICAgICAqICBtb2RlbDogJ2ltYWdlbi00LjAtdXBzY2FsZS1wcmV2aWV3JyxcbiAgICAgICAgICogIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICogIHVwc2NhbGVGYWN0b3I6ICd4MicsXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwc2NhbGVJbWFnZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGxldCBhcGlDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICAgICAgICAgICAgbW9kZTogJ3Vwc2NhbGUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgYXBpQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcGlDb25maWcpLCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgICAgIGltYWdlOiBwYXJhbXMuaW1hZ2UsXG4gICAgICAgICAgICAgICAgdXBzY2FsZUZhY3RvcjogcGFyYW1zLnVwc2NhbGVGYWN0b3IsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBhcGlDb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBzY2FsZUltYWdlSW50ZXJuYWwoYXBpUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBHZW5lcmF0ZXMgdmlkZW9zIGJhc2VkIG9uIGEgdGV4dCBkZXNjcmlwdGlvbiBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIHZpZGVvcy5cbiAgICAgICAgICogQHJldHVybiBBIFByb21pc2U8R2VuZXJhdGVWaWRlb3NPcGVyYXRpb24+IHdoaWNoIGFsbG93cyB5b3UgdG8gdHJhY2sgdGhlIHByb2dyZXNzIGFuZCBldmVudHVhbGx5IHJldHJpZXZlIHRoZSBnZW5lcmF0ZWQgdmlkZW9zIHVzaW5nIHRoZSBvcGVyYXRpb25zLmdldCBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZVZpZGVvcyh7XG4gICAgICAgICAqICBtb2RlbDogJ3Zlby0yLjAtZ2VuZXJhdGUtMDAxJyxcbiAgICAgICAgICogIHNvdXJjZToge1xuICAgICAgICAgKiAgICBwcm9tcHQ6ICdBIG5lb24gaG9sb2dyYW0gb2YgYSBjYXQgZHJpdmluZyBhdCB0b3Agc3BlZWQnLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZlZpZGVvczogMVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogd2hpbGUgKCFvcGVyYXRpb24uZG9uZSkge1xuICAgICAgICAgKiAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwMCkpO1xuICAgICAgICAgKiAgIG9wZXJhdGlvbiA9IGF3YWl0IGFpLm9wZXJhdGlvbnMuZ2V0VmlkZW9zT3BlcmF0aW9uKHtvcGVyYXRpb246IG9wZXJhdGlvbn0pO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG9wZXJhdGlvbi5yZXNwb25zZT8uZ2VuZXJhdGVkVmlkZW9zPy5bMF0/LnZpZGVvPy51cmkpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVWaWRlb3MgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGlmICgocGFyYW1zLnByb21wdCB8fCBwYXJhbXMuaW1hZ2UgfHwgcGFyYW1zLnZpZGVvKSAmJiBwYXJhbXMuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIHByb21wdC9pbWFnZS92aWRlbyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLiBQbGVhc2Ugb25seSB1c2Ugc291cmNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2VtaW5pIEFQSSBkb2VzIG5vdCBzdXBwb3J0IHZpZGVvIGJ5dGVzLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHBhcmFtcy52aWRlbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVyaSkgJiYgKChfYiA9IHBhcmFtcy52aWRlbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZpZGVvQnl0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy52aWRlbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaTogcGFyYW1zLnZpZGVvLnVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJhbXMudmlkZW8ubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgoX2QgPSAoX2MgPSBwYXJhbXMuc291cmNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmlkZW8pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC51cmkpICYmXG4gICAgICAgICAgICAgICAgICAgICgoX2YgPSAoX2UgPSBwYXJhbXMuc291cmNlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudmlkZW8pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi52aWRlb0J5dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuc291cmNlLnZpZGVvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiBwYXJhbXMuc291cmNlLnZpZGVvLnVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJhbXMuc291cmNlLnZpZGVvLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlVmlkZW9zSW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBsb2dpYyBpcyBuZWVkZWQgZm9yIEdlbmVyYXRlQ29udGVudENvbmZpZyBvbmx5LlxuICAgICAqIFByZXZpb3VzbHkgd2UgbWFkZSBHZW5lcmF0ZUNvbnRlbnRDb25maWcucmVzcG9uc2VTY2hlbWEgZmllbGQgdG8gYWNjZXB0XG4gICAgICogdW5rbm93bi4gU2luY2UgdjEuOS4wLCB3ZSBzd2l0Y2ggdG8gdXNlIGJhY2tlbmQgSlNPTiBzY2hlbWEgc3VwcG9ydC5cbiAgICAgKiBUbyBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3ZSBtb3ZlIHRoZSBkYXRhIHRoYXQgd2FzIHRyZWF0ZWQgYXNcbiAgICAgKiBKU09OIHNjaGVtYSBmcm9tIHRoZSByZXNwb25zZVNjaGVtYSBmaWVsZCB0byB0aGUgcmVzcG9uc2VKc29uU2NoZW1hIGZpZWxkLlxuICAgICAqL1xuICAgIG1heWJlTW92ZVRvUmVzcG9uc2VKc29uU2NoZW0ocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmIHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWEpIHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmNvbmZpZy5yZXNwb25zZUpzb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYSkuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnLnJlc3BvbnNlSnNvblNjaGVtYSA9IHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIENhbGxhYmxlVG9vbHMgaW4gdGhlIHBhcmFtZXRlcnMgdG8gYmUgc2ltcGx5IFRvb2xzLCBpdFxuICAgICAqIGNvcGllcyB0aGUgcGFyYW1zIGludG8gYSBuZXcgb2JqZWN0IGFuZCByZXBsYWNlcyB0aGUgdG9vbHMsIGl0IGRvZXMgbm90XG4gICAgICogbW9kaWZ5IHRoZSBvcmlnaW5hbCBwYXJhbXMuIEFsc28gc2V0cyB0aGUgTUNQIHVzYWdlIGhlYWRlciBpZiB0aGVyZSBhcmVcbiAgICAgKiBNQ1AgdG9vbHMgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgYXN5bmMgcHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB0b29scyA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scztcbiAgICAgICAgaWYgKCF0b29scykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFRvb2xzID0gYXdhaXQgUHJvbWlzZS5hbGwodG9vbHMubWFwKGFzeW5jICh0b29sKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBjYWxsYWJsZVRvb2wudG9vbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0ge1xuICAgICAgICAgICAgbW9kZWw6IHBhcmFtcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBwYXJhbXMuY29udGVudHMsXG4gICAgICAgICAgICBjb25maWc6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLmNvbmZpZyksIHsgdG9vbHM6IHRyYW5zZm9ybWVkVG9vbHMgfSksXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BhcmFtcy5jb25maWcudG9vbHMgPSB0cmFuc2Zvcm1lZFRvb2xzO1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJlxuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyAmJlxuICAgICAgICAgICAgaGFzTWNwVG9vbFVzYWdlKHBhcmFtcy5jb25maWcudG9vbHMpKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gKF9jID0gKF9iID0gcGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlYWRlcnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9O1xuICAgICAgICAgICAgbGV0IG5ld0hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdIZWFkZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXdIZWFkZXJzID0gdGhpcy5hcGlDbGllbnQuZ2V0RGVmYXVsdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1jcFVzYWdlSGVhZGVyKG5ld0hlYWRlcnMpO1xuICAgICAgICAgICAgbmV3UGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucyksIHsgaGVhZGVyczogbmV3SGVhZGVycyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH1cbiAgICBhc3luYyBpbml0QWZjVG9vbHNNYXAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBhZmNUb29scyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbERlY2xhcmF0aW9uID0gYXdhaXQgY2FsbGFibGVUb29sLnRvb2woKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY2xhcmF0aW9uIG9mIChfYyA9IHRvb2xEZWNsYXJhdGlvbi5mdW5jdGlvbkRlY2xhcmF0aW9ucykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWNsYXJhdGlvbi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGRlY2xhcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFmY1Rvb2xzLmhhcyhkZWNsYXJhdGlvbi5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgdG9vbCBkZWNsYXJhdGlvbiBuYW1lOiAke2RlY2xhcmF0aW9uLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWZjVG9vbHMuc2V0KGRlY2xhcmF0aW9uLm5hbWUsIGNhbGxhYmxlVG9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZmNUb29scztcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0FmY1N0cmVhbShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1heFJlbW90ZUNhbGxzID0gKF9jID0gKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heGltdW1SZW1vdGVDYWxscykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTO1xuICAgICAgICBsZXQgd2VyZUZ1bmN0aW9uc0NhbGxlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVtb3RlQ2FsbENvdW50ID0gMDtcbiAgICAgICAgY29uc3QgYWZjVG9vbHNNYXAgPSBhd2FpdCB0aGlzLmluaXRBZmNUb29sc01hcChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChtb2RlbHMsIGFmY1Rvb2xzLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHZhciBfZCwgX2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlbW90ZUNhbGxDb3VudCA8IG1heFJlbW90ZUNhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3ZXJlRnVuY3Rpb25zQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVDYWxsQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlcmVGdW5jdGlvbnNDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IHlpZWxkIF9fYXdhaXQobW9kZWxzLnByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlKHBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIF9fYXdhaXQobW9kZWxzLmdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgcmVzcG9uc2VfMSA9IChlXzEgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMocmVzcG9uc2UpKSwgcmVzcG9uc2VfMV8xOyByZXNwb25zZV8xXzEgPSB5aWVsZCBfX2F3YWl0KHJlc3BvbnNlXzEubmV4dCgpKSwgX2EgPSByZXNwb25zZV8xXzEuZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IHJlc3BvbnNlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmNhbmRpZGF0ZXMgJiYgKChfZCA9IGNodW5rLmNhbmRpZGF0ZXNbMF0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRlbnRzLnB1c2goY2h1bmsuY2FuZGlkYXRlc1swXS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfZSA9IGNodW5rLmNhbmRpZGF0ZXNbMF0uY29udGVudC5wYXJ0cykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdGVDYWxsQ291bnQgPCBtYXhSZW1vdGVDYWxscyAmJiBwYXJ0LmZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFydC5mdW5jdGlvbkNhbGwubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGwgbmFtZSB3YXMgbm90IHJldHVybmVkIGJ5IHRoZSBtb2RlbC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmNUb29scy5oYXMocGFydC5mdW5jdGlvbkNhbGwubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyB3YXMgcmVxdWVzdGVkLCBidXQgbm90IGFsbCB0aGUgdG9vbHMgdGhlIG1vZGVsIHVzZWQgaW1wbGVtZW50IHRoZSBDYWxsYWJsZVRvb2wgaW50ZXJmYWNlLiBBdmFpbGFibGUgdG9vbHM6ICR7YWZjVG9vbHMua2V5cygpfSwgbWlzaW5nIHRvb2w6ICR7cGFydC5mdW5jdGlvbkNhbGwubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUGFydHMgPSB5aWVsZCBfX2F3YWl0KGFmY1Rvb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KHBhcnQuZnVuY3Rpb25DYWxsLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FsbFRvb2woW3BhcnQuZnVuY3Rpb25DYWxsXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcy5wdXNoKC4uLnJlc3BvbnNlUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gcmVzcG9uc2VfMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwocmVzcG9uc2VfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvblJlc3BvbnNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcG9uc2VDaHVuayA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRSZXNwb25zZUNodW5rLmNhbmRpZGF0ZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogZnVuY3Rpb25SZXNwb25zZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcG9uc2VDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudHMucHVzaCguLi5yZXNwb25zZUNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogZnVuY3Rpb25SZXNwb25zZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDb250ZW50cyA9IHRDb250ZW50cyhwYXJhbXMuY29udGVudHMpLmNvbmNhdChuZXdDb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY29udGVudHMgPSB1cGRhdGVkQ29udGVudHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSh0aGlzLCBhZmNUb29sc01hcCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Z2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpnZW5lcmF0ZUNvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpzdHJlYW1HZW5lcmF0ZUNvbnRlbnQ/YWx0PXNzZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhcGlDbGllbnQucmVxdWVzdFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oZnVuY3Rpb24gKGFwaVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBhcGlSZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhhcGlSZXNwb25zZSksIGFwaVJlc3BvbnNlXzFfMTsgYXBpUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChhcGlSZXNwb25zZV8xLm5leHQoKSksIF9hID0gYXBpUmVzcG9uc2VfMV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBhcGlSZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoKHlpZWxkIF9fYXdhaXQoY2h1bmsuanNvbigpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BbJ3Nka0h0dHBSZXNwb25zZSddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBjaHVuay5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQodHlwZWRSZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gYXBpUmVzcG9uc2VfMS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoYXBpUmVzcG9uc2VfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06c3RyZWFtR2VuZXJhdGVDb250ZW50P2FsdD1zc2UnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXBpQ2xpZW50LnJlcXVlc3RTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKGZ1bmN0aW9uIChhcGlSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBlXzMsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgYXBpUmVzcG9uc2VfMiA9IF9fYXN5bmNWYWx1ZXMoYXBpUmVzcG9uc2UpLCBhcGlSZXNwb25zZV8yXzE7IGFwaVJlc3BvbnNlXzJfMSA9IHlpZWxkIF9fYXdhaXQoYXBpUmVzcG9uc2VfMi5uZXh0KCkpLCBfYSA9IGFwaVJlc3BvbnNlXzJfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gYXBpUmVzcG9uc2VfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoKHlpZWxkIF9fYXdhaXQoY2h1bmsuanNvbigpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BbJ3Nka0h0dHBSZXNwb25zZSddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBjaHVuay5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQodHlwZWRSZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gYXBpUmVzcG9uc2VfMi5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoYXBpUmVzcG9uc2VfMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGVtYmVkZGluZ3MgZm9yIHRoZSBnaXZlbiBjb250ZW50cy4gT25seSB0ZXh0IGlzIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZW1iZWRkaW5nIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5lbWJlZENvbnRlbnQoe1xuICAgICAqICBtb2RlbDogJ3RleHQtZW1iZWRkaW5nLTAwNCcsXG4gICAgICogIGNvbnRlbnRzOiBbXG4gICAgICogICAgJ1doYXQgaXMgeW91ciBuYW1lPycsXG4gICAgICogICAgJ1doYXQgaXMgeW91ciBmYXZvcml0ZSBjb2xvcj8nLFxuICAgICAqICBdLFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBvdXRwdXREaW1lbnNpb25hbGl0eTogNjQsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGVtYmVkQ29udGVudChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRW1iZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpiYXRjaEVtYmVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVtYmVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGVkaXRpbmcgYW4gaW1hZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZWRpdEltYWdlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlZGl0SW1hZ2VQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVkaXRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVkaXRJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgdXBzY2FsaW5nIGFuIGltYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHVwc2NhbGVJbWFnZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB1cHNjYWxlSW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBVcHNjYWxlSW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb250ZXh0dWFsaXplcyBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgcmVjb250ZXh0dWFsaXphdGlvbiBjdXJyZW50bHkgc3VwcG9ydGVkOlxuICAgICAqIDEpIEltYWdlbiBQcm9kdWN0IFJlY29udGV4dCAtIEdlbmVyYXRlIGltYWdlcyBvZiBwcm9kdWN0cyBpbiBuZXcgc2NlbmVzXG4gICAgICogICAgYW5kIGNvbnRleHRzLlxuICAgICAqIDIpIFZpcnR1YWwgVHJ5LU9uOiBHZW5lcmF0ZSBpbWFnZXMgb2YgcGVyc29ucyBtb2RlbGluZyBmYXNoaW9uIHByb2R1Y3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciByZWNvbnRleHR1YWxpemluZyBhbiBpbWFnZS5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UxID0gYXdhaXQgYWkubW9kZWxzLnJlY29udGV4dEltYWdlKHtcbiAgICAgKiAgbW9kZWw6ICdpbWFnZW4tcHJvZHVjdC1yZWNvbnRleHQtcHJldmlldy0wNi0zMCcsXG4gICAgICogIHNvdXJjZToge1xuICAgICAqICAgIHByb21wdDogJ0luIGEgbW9kZXJuIGtpdGNoZW4gc2V0dGluZy4nLFxuICAgICAqICAgIHByb2R1Y3RJbWFnZXM6IFtwcm9kdWN0SW1hZ2VdLFxuICAgICAqICB9LFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZTE/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICpcbiAgICAgKiBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBhaS5tb2RlbHMucmVjb250ZXh0SW1hZ2Uoe1xuICAgICAqICBtb2RlbDogJ3ZpcnR1YWwtdHJ5LW9uLTAwMScsXG4gICAgICogIHNvdXJjZToge1xuICAgICAqICAgIHBlcnNvbkltYWdlOiBwZXJzb25JbWFnZSxcbiAgICAgKiAgICBwcm9kdWN0SW1hZ2VzOiBbcHJvZHVjdEltYWdlXSxcbiAgICAgKiAgfSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UyPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHJlY29udGV4dEltYWdlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gcmVjb250ZXh0SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlY29udGV4dEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VnbWVudHMgYW4gaW1hZ2UsIGNyZWF0aW5nIGEgbWFzayBvZiBhIHNwZWNpZmllZCBhcmVhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBzZWdtZW50aW5nIGFuIGltYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5zZWdtZW50SW1hZ2Uoe1xuICAgICAqICBtb2RlbDogJ2ltYWdlLXNlZ21lbnRhdGlvbi0wMDEnLFxuICAgICAqICBzb3VyY2U6IHtcbiAgICAgKiAgICBpbWFnZTogaW1hZ2UsXG4gICAgICogIH0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG1vZGU6ICdmb3JlZ3JvdW5kJyxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkTWFza3M/LlswXT8ubWFzaz8uaW1hZ2VCeXRlcyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VnbWVudEltYWdlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gc2VnbWVudEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBzZWdtZW50SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBTZWdtZW50SW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBpbmZvcm1hdGlvbiBhYm91dCBhIG1vZGVsIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgbW9kZWxJbmZvID0gYXdhaXQgYWkubW9kZWxzLmdldCh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0TW9kZWxzUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsc191cmx9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0TW9kZWxzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdE1vZGVsc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0TW9kZWxzUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWxzX3VybH0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RNb2RlbHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHR1bmVkIG1vZGVsIGJ5IGl0cyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB1cGRhdGluZyB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLnVwZGF0ZSh7XG4gICAgICogICBtb2RlbDogJ3R1bmVkLW1vZGVsLW5hbWUnLFxuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIGRpc3BsYXlOYW1lOiAnTmV3IGRpc3BsYXkgbmFtZScsXG4gICAgICogICAgIGRlc2NyaXB0aW9uOiAnTmV3IGRlc2NyaXB0aW9uJyxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSB0dW5lZCBtb2RlbCBieSBpdHMgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZGVsZXRpbmcgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5kZWxldGUoe21vZGVsOiAndHVuZWQtbW9kZWwtbmFtZSd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZU1vZGVsUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVNb2RlbFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGdpdmVuIGNvbnRlbnRzLiBNdWx0aW1vZGFsIGlucHV0IGlzXG4gICAgICogc3VwcG9ydGVkIGZvciBHZW1pbmkgbW9kZWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjb3VudGluZyB0b2tlbnMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmNvdW50VG9rZW5zKHtcbiAgICAgKiAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgY29udGVudHM6ICdUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLidcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY291bnRUb2tlbnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpjb3VudFRva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ291bnRUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y291bnRUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ291bnRUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIGNvbnRlbnRzLCByZXR1cm5zIGEgY29ycmVzcG9uZGluZyBUb2tlbnNJbmZvIGNvbnRhaW5pbmdcbiAgICAgKiB0aGUgbGlzdCBvZiB0b2tlbnMgYW5kIGxpc3Qgb2YgdG9rZW4gaWRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNvbXB1dGluZyB0b2tlbnMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmNvbXB1dGVUb2tlbnMoe1xuICAgICAqICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICBjb250ZW50czogJ1doYXQgaXMgeW91ciBuYW1lPydcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY29tcHV0ZVRva2VucyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmNvbXB1dGVUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgZ2VuZXJhdGluZyB2aWRlb3MuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVWaWRlb3NJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE9wZXJhdGlvbnMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXR1cyBvZiBhIGxvbmctcnVubmluZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCBvcGVyYXRpb24gcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSB1cGRhdGVkIE9wZXJhdGlvbiBvYmplY3QsIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgb3IgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFZpZGVvc09wZXJhdGlvbihwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHBhcmFtZXRlcnMub3BlcmF0aW9uO1xuICAgICAgICBjb25zdCBjb25maWcgPSBwYXJhbWV0ZXJzLmNvbmZpZztcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5uYW1lID09PSB1bmRlZmluZWQgfHwgb3BlcmF0aW9uLm5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBuYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IG9wZXJhdGlvbi5uYW1lLnNwbGl0KCcvb3BlcmF0aW9ucy8nKVswXTtcbiAgICAgICAgICAgIGxldCBodHRwT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb25maWcgJiYgJ2h0dHBPcHRpb25zJyBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9ucyA9IGNvbmZpZy5odHRwT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhd09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIHJlc291cmNlTmFtZTogcmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogeyBodHRwT3B0aW9uczogaHR0cE9wdGlvbnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIF9pc1ZlcnRleEFJOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIF9pc1ZlcnRleEFJOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXR1cyBvZiBhIGxvbmctcnVubmluZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCBvcGVyYXRpb24gcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSB1cGRhdGVkIE9wZXJhdGlvbiBvYmplY3QsIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgb3IgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHBhcmFtZXRlcnMub3BlcmF0aW9uO1xuICAgICAgICBjb25zdCBjb25maWcgPSBwYXJhbWV0ZXJzLmNvbmZpZztcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5uYW1lID09PSB1bmRlZmluZWQgfHwgb3BlcmF0aW9uLm5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBuYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IG9wZXJhdGlvbi5uYW1lLnNwbGl0KCcvb3BlcmF0aW9ucy8nKVswXTtcbiAgICAgICAgICAgIGxldCBodHRwT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb25maWcgJiYgJ2h0dHBPcHRpb25zJyBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9ucyA9IGNvbmZpZy5odHRwT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhd09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIHJlc291cmNlTmFtZTogcmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogeyBodHRwT3B0aW9uczogaHR0cE9wdGlvbnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIF9pc1ZlcnRleEFJOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIF9pc1ZlcnRleEFJOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tvcGVyYXRpb25OYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7cmVzb3VyY2VOYW1lfTpmZXRjaFByZWRpY3RPcGVyYXRpb24nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBibG9iVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQXV0aFRva2VuQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXdTZXNzaW9uRXhwaXJlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyduZXdTZXNzaW9uRXhwaXJlVGltZSddLCBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXNlcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVVzZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndXNlcyddLCBmcm9tVXNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGl2ZUNvbm5lY3RDb25zdHJhaW50cycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddLCBsaXZlQ29ubmVjdENvbnN0cmFpbnRzVG9NbGRldihhcGlDbGllbnQsIGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2NrQWRkaXRpb25hbEZpZWxkcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xvY2tBZGRpdGlvbmFsRmllbGRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2ZpZWxkTWFzayddLCBmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjcmVhdGVBdXRoVG9rZW5Db25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRpYWxBcmdzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0aWFsQXJncyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3aWxsQ29udGludWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpbGxDb250aW51ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVXaWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddKTtcbiAgICBpZiAoZnJvbUVuYWJsZVdpZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddLCBmcm9tRW5hYmxlV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmxvY2tpbmdDb25maWRlbmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdibG9ja2luZ0NvbmZpZGVuY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgZnJvbVRpbWVSYW5nZUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnXSwgZnJvbUdlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzcGVlY2hDb25maWcnXSwgdExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldih0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldih0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2KGZyb21TZXNzaW9uUmVzdW1wdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9hY3Rpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvYWN0aXZpdHknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9hY3Rpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdwcm9hY3Rpdml0eSddLCBmcm9tUHJvYWN0aXZpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBsaWNpdFZhZFNpZ25hbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwbGljaXRWYWRTaWduYWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25zdHJhaW50c1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb01sZGV2KGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydoYW5kbGUnXSk7XG4gICAgaWYgKGZyb21IYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydoYW5kbGUnXSwgZnJvbUhhbmRsZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYW5zcGFyZW50J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc3BhcmVudCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlU2VhcmNoJ10sIGZyb21GaWxlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGQgbWFza3MgZnJvbSBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gc2V0dXAgVGhlIG9iamVjdCB0byBleHRyYWN0IGZpZWxkIG1hc2tzIGZyb20uXG4gKiBAcmV0dXJuIEEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGQgbWFza3MuXG4gKi9cbmZ1bmN0aW9uIGdldEZpZWxkTWFza3Moc2V0dXApIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzZXR1cCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHVwLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNldHVwW2tleV07XG4gICAgICAgICAgICAvLyAybmQgbGF5ZXIsIHJlY3Vyc2l2ZWx5IGdldCBmaWVsZCBtYXNrcyBzZWUgVE9ETyhiLzQxODI5MDEwMClcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChraykgPT4gYCR7a2V5fS4ke2trfWApO1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKC4uLmZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGtleSk7IC8vIDFzdCBsYXllclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHMuam9pbignLCcpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAuXG4gKiBAcGFyYW0gcmVxdWVzdERpY3QgLSBUaGUgcmVxdWVzdCBkaWN0aW9uYXJ5LlxuICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqIEByZXR1cm4gLSBUaGUgbW9kaWZpZWQgcmVxdWVzdCBkaWN0aW9uYXJ5LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0QmlkaVNldHVwVG9Ub2tlblNldHVwKHJlcXVlc3REaWN0LCBjb25maWcpIHtcbiAgICAvLyBDb252ZXJ0IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCBmcm9tIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cC5zZXR1cC5cbiAgICBsZXQgc2V0dXBGb3JNYXNrR2VuZXJhdGlvbiA9IG51bGw7XG4gICAgY29uc3QgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgPSByZXF1ZXN0RGljdFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ107XG4gICAgaWYgKHR5cGVvZiBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgJ3NldHVwJyBpbiBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSkge1xuICAgICAgICAvLyBOb3cgd2Uga25vdyBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSBpcyBhbiBvYmplY3QgYW5kIGhhcyBhICdzZXR1cCdcbiAgICAgICAgLy8gcHJvcGVydHkuXG4gICAgICAgIGNvbnN0IGlubmVyU2V0dXAgPSBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZVxuICAgICAgICAgICAgLnNldHVwO1xuICAgICAgICBpZiAodHlwZW9mIGlubmVyU2V0dXAgPT09ICdvYmplY3QnICYmIGlubmVyU2V0dXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFZhbGlkIGlubmVyIHNldHVwIGZvdW5kLlxuICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddID0gaW5uZXJTZXR1cDtcbiAgICAgICAgICAgIHNldHVwRm9yTWFza0dlbmVyYXRpb24gPSBpbm5lclNldHVwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlLnNldHVwYCBpcyBub3QgYSB2YWxpZCBvYmplY3Q7IHRyZWF0IGFzXG4gICAgICAgICAgICAvLyBpZiBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAgaXMgaW52YWxpZC5cbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwYCBleGlzdHMgYnV0IG5vdCBpbiB0aGUgZXhwZWN0ZWRcbiAgICAgICAgLy8gc2hhcGUge3NldHVwOiB7Li4ufX07IHRyZWF0IGFzIGludmFsaWQuXG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ107XG4gICAgfVxuICAgIGNvbnN0IHByZUV4aXN0aW5nRmllbGRNYXNrID0gcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddO1xuICAgIC8vIEhhbmRsZSBtYXNrIGdlbmVyYXRpb24gc2V0dXAuXG4gICAgaWYgKHNldHVwRm9yTWFza0dlbmVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkTWFza0Zyb21CaWRpID0gZ2V0RmllbGRNYXNrcyhzZXR1cEZvck1hc2tHZW5lcmF0aW9uKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzKSAmJlxuICAgICAgICAgICAgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcy5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBDYXNlIDE6IGxvY2tBZGRpdGlvbmFsRmllbGRzIGlzIGFuIGVtcHR5IGFycmF5LiBMb2NrIG9ubHkgZmllbGRzIGZyb21cbiAgICAgICAgICAgIC8vIGJpZGkgc2V0dXAuXG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkTWFza0Zyb21CaWRpKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgbWFzayBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ10gPSBnZW5lcmF0ZWRNYXNrRnJvbUJpZGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddOyAvLyBJZiBtYXNrIGlzIGVtcHR5LCBlZmZlY3RpdmVseSBub1xuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIGZpZWxkcyBsb2NrZWQgYnkgYmlkaVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMpICYmXG4gICAgICAgICAgICBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgcHJlRXhpc3RpbmdGaWVsZE1hc2sgIT09IG51bGwgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlRXhpc3RpbmdGaWVsZE1hc2spICYmXG4gICAgICAgICAgICBwcmVFeGlzdGluZ0ZpZWxkTWFzay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBDYXNlIDI6IExvY2sgZmllbGRzIGZyb20gYmlkaSBzZXR1cCArIGFkZGl0aW9uYWwgZmllbGRzXG4gICAgICAgICAgICAvLyAocHJlRXhpc3RpbmdGaWVsZE1hc2spLlxuICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGlvbkNvbmZpZ0ZpZWxkcyA9IFtcbiAgICAgICAgICAgICAgICAndGVtcGVyYXR1cmUnLFxuICAgICAgICAgICAgICAgICd0b3BLJyxcbiAgICAgICAgICAgICAgICAndG9wUCcsXG4gICAgICAgICAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgICAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgICAgICAgICAgICAgJ3NlZWQnLFxuICAgICAgICAgICAgICAgICdzcGVlY2hDb25maWcnLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcmVFeGlzdGluZ0ZpZWxkTWFzay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nID0gcHJlRXhpc3RpbmdGaWVsZE1hc2subWFwKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGlvbkNvbmZpZ0ZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgZ2VuZXJhdGlvbkNvbmZpZy4ke2ZpZWxkfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkOyAvLyBLZWVwIG9yaWdpbmFsIGZpZWxkIG5hbWUgaWYgbm90IGluXG4gICAgICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRpb25Db25maWdGaWVsZHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFza1BhcnRzID0gW107XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkTWFza0Zyb21CaWRpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxNYXNrUGFydHMucHVzaChnZW5lcmF0ZWRNYXNrRnJvbUJpZGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxNYXNrUGFydHMucHVzaCguLi5tYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbmFsTWFza1BhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ10gPSBmaW5hbE1hc2tQYXJ0cy5qb2luKCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBmaWVsZHMgZnJvbSBiaWRpIGFuZCBubyB2YWxpZCBhZGRpdGlvbmFsIGZpZWxkcyBmcm9tXG4gICAgICAgICAgICAgICAgLy8gcHJlLWV4aXN0aW5nIG1hc2suXG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhc2UgMzogXCJMb2NrIGFsbCBmaWVsZHNcIiAobWVhbmluZywgZG9uJ3Qgc2VuZCBhIGZpZWxkX21hc2ssIGxldCBzZXJ2ZXJcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzIGFwcGx5IG9yIGFsbCBhcmUgbXV0YWJsZSkuIFRoaXMgaXMgaGl0IGlmOlxuICAgICAgICAgICAgLy8gIC0gYGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkc2AgaXMgdW5kZWZpbmVkLlxuICAgICAgICAgICAgLy8gIC0gYGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkc2AgaXMgbm9uLWVtcHR5LCBCVVRcbiAgICAgICAgICAgIC8vICBgcHJlRXhpc3RpbmdGaWVsZE1hc2tgIGlzIG51bGwsIG5vdCBhIHN0cmluZywgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTm8gdmFsaWQgYGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cGAgd2FzIGZvdW5kIG9yIGV4dHJhY3RlZC5cbiAgICAgICAgLy8gXCJMb2NrIGFkZGl0aW9uYWwgbnVsbCBmaWVsZHMgaWYgYW55XCIuXG4gICAgICAgIGlmIChwcmVFeGlzdGluZ0ZpZWxkTWFzayAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShwcmVFeGlzdGluZ0ZpZWxkTWFzaykgJiZcbiAgICAgICAgICAgIHByZUV4aXN0aW5nRmllbGRNYXNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBwcmUtZXhpc3RpbmcgZmllbGQgbWFzaywgaXQncyBhIHN0cmluZywgYW5kIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyBlbXB0eSwgdGhlbiB3ZSBzaG91bGQgbG9jayBhbGwgZmllbGRzLlxuICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gcHJlRXhpc3RpbmdGaWVsZE1hc2suam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdERpY3Q7XG59XG5jbGFzcyBUb2tlbnMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXBoZW1lcmFsIGF1dGggdG9rZW4gcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEVwaGVtZXJhbCBhdXRoIHRva2VucyBpcyBvbmx5IHN1cHBvcnRlZCBpbiB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuXG4gICAgICogSXQgY2FuIGJlIHVzZWQgZm9yIHRoZSBzZXNzaW9uIGNvbm5lY3Rpb24gdG8gdGhlIExpdmUgY29uc3RyYWluZWQgQVBJLlxuICAgICAqIFN1cHBvcnQgaW4gdjFhbHBoYSBvbmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY3JlYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBhdXRoIHRva2VuLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHtcbiAgICAgKiAgICAgYXBpS2V5OiB0b2tlbi5uYW1lLFxuICAgICAqICAgICBodHRwT3B0aW9uczogeyBhcGlWZXJzaW9uOiAndjFhbHBoYScgfSAgLy8gU3VwcG9ydCBpbiB2MWFscGhhIG9ubHkuXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDE6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHVuc2V0LCB1bmxvY2sgTGl2ZUNvbm5lY3RDb25maWdcbiAgICAgKiAvLyB3aGVuIHVzaW5nIHRoZSB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy4gRWFjaCBzZXNzaW9uIGNvbm5lY3Rpb24gY2FuXG4gICAgICogLy8gdXNlIGEgZGlmZmVyZW50IGNvbmZpZ3VyYXRpb24uXG4gICAgICogY29uc3QgY29uZmlnOiBDcmVhdGVBdXRoVG9rZW5Db25maWcgPSB7XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogfVxuICAgICAqIGNvbnN0IHRva2VuID0gYXdhaXQgYWkudG9rZW5zLmNyZWF0ZShjb25maWcpO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSAyOiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyBzZXQsIGxvY2sgYWxsIGZpZWxkcyBpblxuICAgICAqIC8vIExpdmVDb25uZWN0Q29uZmlnIHdoZW4gdXNpbmcgdGhlIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLiBGb3JcbiAgICAgKiAvLyBleGFtcGxlLCBjaGFuZ2luZyBgb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uYCBpbiB0aGUgTGl2ZSBBUElcbiAgICAgKiAvLyBjb25uZWN0aW9uIHdpbGwgYmUgaWdub3JlZCBieSB0aGUgQVBJLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID1cbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiAgICAgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnM6IHtcbiAgICAgKiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICAgICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJzogWydBVURJTyddLFxuICAgICAqICAgICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnQWx3YXlzIGFuc3dlciBpbiBFbmdsaXNoLicsXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgMzogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgc2V0IGFuZCBsb2NrQWRkaXRpb25hbEZpZWxkcyBpc1xuICAgICAqIC8vIHNldCwgbG9jayBMaXZlQ29ubmVjdENvbmZpZyB3aXRoIHNldCBhbmQgYWRkaXRpb25hbCBmaWVsZHMgKGUuZy5cbiAgICAgKiAvLyByZXNwb25zZU1vZGFsaXRpZXMsIHN5c3RlbUluc3RydWN0aW9uLCB0ZW1wZXJhdHVyZSBpbiB0aGlzIGV4YW1wbGUpIHdoZW5cbiAgICAgKiAvLyB1c2luZyB0aGUgdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuXG4gICAgICogY29uc3QgY29uZmlnOiBDcmVhdGVBdXRoVG9rZW5Db25maWcgPVxuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqICAgICBMaXZlRXBoZW1lcmFsUGFyYW1ldGVyczoge1xuICAgICAqICAgICAgICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gtMDAxJyxcbiAgICAgKiAgICAgICAgY29uZmlnOiB7XG4gICAgICogICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnOiBbJ0FVRElPJ10sXG4gICAgICogICAgICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbic6ICdBbHdheXMgYW5zd2VyIGluIEVuZ2xpc2guJyxcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBsb2NrQWRkaXRpb25hbEZpZWxkczogWyd0ZW1wZXJhdHVyZSddLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgNDogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgc2V0IGFuZCBsb2NrQWRkaXRpb25hbEZpZWxkcyBpc1xuICAgICAqIC8vIGVtcHR5IGFycmF5LCBsb2NrIExpdmVDb25uZWN0Q29uZmlnIHdpdGggc2V0IGZpZWxkcyAoZS5nLlxuICAgICAqIC8vIHJlc3BvbnNlTW9kYWxpdGllcywgc3lzdGVtSW5zdHJ1Y3Rpb24gaW4gdGhpcyBleGFtcGxlKSB3aGVuIHVzaW5nIHRoZVxuICAgICAqIC8vIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID1cbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiAgICAgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnM6IHtcbiAgICAgKiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICAgICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJzogWydBVURJTyddLFxuICAgICAqICAgICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnQWx3YXlzIGFuc3dlciBpbiBFbmdsaXNoLicsXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbG9ja0FkZGl0aW9uYWxGaWVsZHM6IFtdLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNsaWVudC50b2tlbnMuY3JlYXRlIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQXV0aFRva2VuUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdhdXRoX3Rva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQm9keSA9IGNvbnZlcnRCaWRpU2V0dXBUb1Rva2VuU2V0dXAoYm9keSwgcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybWVkQm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBkZWxldGVEb2N1bWVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9yY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZvcmNlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRm9yY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZvcmNlJ10sIGZyb21Gb3JjZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZURvY3VtZW50UGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZGVsZXRlRG9jdW1lbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RG9jdW1lbnRzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3REb2N1bWVudHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFyZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJlbnQnXSk7XG4gICAgaWYgKGZyb21QYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ3BhcmVudCddLCBmcm9tUGFyZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdERvY3VtZW50c0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RG9jdW1lbnRzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb2N1bWVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvY3VtZW50cyddKTtcbiAgICBpZiAoZnJvbURvY3VtZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRG9jdW1lbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb2N1bWVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBEb2N1bWVudHMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBkb2N1bWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiAtIEEgcGFnZXIgb2YgZG9jdW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBkb2N1bWVudHMgPSBhd2FpdCBhaS5kb2N1bWVudHMubGlzdCh7cGFyZW50OidyYWdfc3RvcmVfbmFtZScsIGNvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgZG9jdW1lbnQgb2YgZG9jdW1lbnRzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coZG9jdW1lbnQpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9ET0NVTUVOVFMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh7IHBhcmVudDogcGFyYW1zLnBhcmVudCwgY29uZmlnOiB4LmNvbmZpZyB9KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIERvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZXR0aW5nIGEgZG9jdW1lbnQuXG4gICAgICogQHJldHVybiBEb2N1bWVudC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldERvY3VtZW50UGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgRG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGRlbGV0aW5nIGEgZG9jdW1lbnQuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlRG9jdW1lbnRQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0RG9jdW1lbnRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3twYXJlbnR9L2RvY3VtZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0RG9jdW1lbnRzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0RG9jdW1lbnRzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBGaWxlU2VhcmNoU3RvcmVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBkb2N1bWVudHMgPSBuZXcgRG9jdW1lbnRzKGFwaUNsaWVudCkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRzID0gZG9jdW1lbnRzO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgZmlsZSBzZWFyY2ggc3RvcmVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIHBhZ2VyIG9mIGZpbGUgc2VhcmNoIHN0b3Jlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgZmlsZVNlYXJjaFN0b3JlcyA9IGF3YWl0IGFpLmZpbGVTZWFyY2hTdG9yZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBmaWxlU2VhcmNoU3RvcmUgb2YgZmlsZVNlYXJjaFN0b3Jlcykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGZpbGVTZWFyY2hTdG9yZSk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fRklMRV9TRUFSQ0hfU1RPUkVTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIGEgZ2l2ZW4gRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSBpbiBWZXJ0ZXggQUkuXG4gICAgICogU3VwcG9ydGVkIHVwbG9hZCBzb3VyY2VzOlxuICAgICAqIC0gTm9kZS5qczogRmlsZSBwYXRoIChzdHJpbmcpIG9yIEJsb2Igb2JqZWN0LlxuICAgICAqIC0gQnJvd3NlcjogQmxvYiBvYmplY3QgKGUuZy4sIEZpbGUpLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgYG1pbWVUeXBlYCBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBgY29uZmlnYCBwYXJhbWV0ZXIuIElmIG9taXR0ZWQ6XG4gICAgICogIC0gRm9yIGZpbGUgcGF0aCAoc3RyaW5nKSBpbnB1dHMsIHRoZSBgbWltZVR5cGVgIHdpbGwgYmUgaW5mZXJyZWQgZnJvbSB0aGVcbiAgICAgKiAgICAgZmlsZSBleHRlbnNpb24uXG4gICAgICogIC0gRm9yIEJsb2Igb2JqZWN0IGlucHV0cywgdGhlIGBtaW1lVHlwZWAgd2lsbCBiZSBzZXQgdG8gdGhlIEJsb2IncyBgdHlwZWBcbiAgICAgKiAgICAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGlzIHNlY3Rpb24gY2FuIGNvbnRhaW4gbXVsdGlwbGUgcGFyYWdyYXBocyBhbmQgY29kZSBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGVcbiAgICAgKiAgICAgICAgYHR5cGVzLlVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc2AgaW50ZXJmYWNlLlxuICAgICAqICAgICAgICAgQHNlZSB7QGxpbmsgdHlwZXMuVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzI2NvbmZpZ30gZm9yIHRoZSBvcHRpb25hbFxuICAgICAqICAgICAgICAgY29uZmlnIGluIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBsb25nIHJ1bm5pbmcgb3BlcmF0aW9uLlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgY2FsbGVkIG9uIGEgVmVydGV4IEFJIGNsaWVudC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBgbWltZVR5cGVgIGlzIG5vdCBwcm92aWRlZCBhbmQgY2FuIG5vdCBiZSBpbmZlcnJlZCxcbiAgICAgKiB0aGUgYG1pbWVUeXBlYCBjYW4gYmUgcHJvdmlkZWQgaW4gdGhlIGBwYXJhbXMuY29uZmlnYCBwYXJhbWV0ZXIuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBvY2N1cnMgaWYgYSBzdWl0YWJsZSB1cGxvYWQgbG9jYXRpb24gY2Fubm90IGJlIGVzdGFibGlzaGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgdXBsb2FkcyBhIGZpbGUgdG8gYSBnaXZlbiBmaWxlIHNlYXJjaCBzdG9yZS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3Qgb3BlcmF0aW9uID0gYXdhaXQgYWkuZmlsZVNlYXJjaFN0b3Jlcy51cGxvYWQoe2ZpbGVTZWFyY2hTdG9yZU5hbWU6ICdmaWxlU2VhcmNoU3RvcmVzL2Zvby1iYXInLCBmaWxlOiAnZmlsZS50eHQnLCBjb25maWc6IHtcbiAgICAgKiAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICogfX0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9wZXJhdGlvbi5uYW1lKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggQUkgZG9lcyBub3Qgc3VwcG9ydCB1cGxvYWRpbmcgZmlsZXMgdG8gYSBmaWxlIHNlYXJjaCBzdG9yZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQudXBsb2FkRmlsZVRvRmlsZVNlYXJjaFN0b3JlKHBhcmFtcy5maWxlU2VhcmNoU3RvcmVOYW1lLCBwYXJhbXMuZmlsZSwgcGFyYW1zLmNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKiBAcmV0dXJuIEZpbGVTZWFyY2hTdG9yZS5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlU2VhcmNoU3RvcmVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdldHRpbmcgYSBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKiBAcmV0dXJuIEZpbGVTZWFyY2hTdG9yZS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBkZWxldGluZyBhIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RGaWxlU2VhcmNoU3RvcmVzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVTZWFyY2hTdG9yZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEve2ZpbGVfc2VhcmNoX3N0b3JlX25hbWV9OnVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3VtYWJsZVJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXN1bWFibGVSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wb3J0cyBhIEZpbGUgZnJvbSBGaWxlIFNlcnZpY2UgdG8gYSBGaWxlU2VhcmNoU3RvcmUuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbiwgc2VlIGFpcC5kZXYvMTUxXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGltcG9ydGluZyBhIGZpbGUgdG8gYSBmaWxlIHNlYXJjaCBzdG9yZS5cbiAgICAgKiBAcmV0dXJuIEltcG9ydEZpbGVPcGVyYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgaW1wb3J0RmlsZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gaW1wb3J0RmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7ZmlsZV9zZWFyY2hfc3RvcmVfbmFtZX06aW1wb3J0RmlsZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gaW1wb3J0RmlsZU9wZXJhdGlvbkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEltcG9ydEZpbGVPcGVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuLyoqXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xuICovXG5sZXQgdXVpZDRJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB7IGNyeXB0byB9ID0gZ2xvYmFsVGhpcztcbiAgICBpZiAoY3J5cHRvID09PSBudWxsIHx8IGNyeXB0byA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3J5cHRvLnJhbmRvbVVVSUQpIHtcbiAgICAgICAgdXVpZDRJbnRlcm5hbCA9IGNyeXB0by5yYW5kb21VVUlELmJpbmQoY3J5cHRvKTtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgfVxuICAgIGNvbnN0IHU4ID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgY29uc3QgcmFuZG9tQnl0ZSA9IGNyeXB0byA/ICgpID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXModTgpWzBdIDogKCkgPT4gKE1hdGgucmFuZG9tKCkgKiAweGZmKSAmIDB4ZmY7XG4gICAgcmV0dXJuICcxMDAwMDAwMC0xMDAwLTQwMDAtODAwMC0xMDAwMDAwMDAwMDAnLnJlcGxhY2UoL1swMThdL2csIChjKSA9PiAoK2MgXiAocmFuZG9tQnl0ZSgpICYgKDE1ID4+ICgrYyAvIDQpKSkpLnRvU3RyaW5nKDE2KSk7XG59O1xuY29uc3QgdXVpZDQgPSAoKSA9PiB1dWlkNEludGVybmFsKCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5mdW5jdGlvbiBpc0Fib3J0RXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBlcnIgIT09IG51bGwgJiZcbiAgICAgICAgLy8gU3BlYy1jb21wbGlhbnQgZmV0Y2ggaW1wbGVtZW50YXRpb25zXG4gICAgICAgICgoJ25hbWUnIGluIGVyciAmJiBlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB8fFxuICAgICAgICAgICAgLy8gRXhwbyBmZXRjaFxuICAgICAgICAgICAgKCdtZXNzYWdlJyBpbiBlcnIgJiYgU3RyaW5nKGVyci5tZXNzYWdlKS5pbmNsdWRlcygnRmV0Y2hSZXF1ZXN0Q2FuY2VsZWRFeGNlcHRpb24nKSkpKTtcbn1cbmNvbnN0IGNhc3RUb0Vycm9yID0gKGVycikgPT4ge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgZXJyICE9PSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbm90IGFsbCBlbnZzIGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yIGNhdXNlIHlldFxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVyci5tZXNzYWdlLCBlcnIuY2F1c2UgPyB7IGNhdXNlOiBlcnIuY2F1c2UgfSA6IHt9KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLnN0YWNrKVxuICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbm90IGFsbCBlbnZzIGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yIGNhdXNlIHlldFxuICAgICAgICAgICAgICAgIGlmIChlcnIuY2F1c2UgJiYgIWVycm9yLmNhdXNlKVxuICAgICAgICAgICAgICAgICAgICBlcnJvci5jYXVzZSA9IGVyci5jYXVzZTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBlcnIubmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9iKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihlcnIpO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmNsYXNzIEdlbWluaU5leHRHZW5BUElDbGllbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmNsYXNzIEFQSUVycm9yIGV4dGVuZHMgR2VtaW5pTmV4dEdlbkFQSUNsaWVudEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gICAgICAgIHN1cGVyKGAke0FQSUVycm9yLm1ha2VNZXNzYWdlKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UpfWApO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZU1lc3NhZ2Uoc3RhdHVzLCBlcnJvciwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtc2cgPSAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpID9cbiAgICAgICAgICAgIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgIDogZXJyb3IgPyBKU09OLnN0cmluZ2lmeShlcnJvcilcbiAgICAgICAgICAgICAgICA6IG1lc3NhZ2U7XG4gICAgICAgIGlmIChzdGF0dXMgJiYgbXNnKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7c3RhdHVzfSAke21zZ31gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtzdGF0dXN9IHN0YXR1cyBjb2RlIChubyBib2R5KWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1zZykge1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyhubyBzdGF0dXMgY29kZSBvciBib2R5KSc7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZShzdGF0dXMsIGVycm9yUmVzcG9uc2UsIG1lc3NhZ2UsIGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCFzdGF0dXMgfHwgIWhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVBJQ29ubmVjdGlvbkVycm9yKHsgbWVzc2FnZSwgY2F1c2U6IGNhc3RUb0Vycm9yKGVycm9yUmVzcG9uc2UpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JSZXNwb25zZTtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJhZFJlcXVlc3RFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVybWlzc2lvbkRlbmllZEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb3RGb3VuZEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQwOSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25mbGljdEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQyMikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhdGVMaW1pdEVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVybmFsU2VydmVyRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBUElFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG59XG5jbGFzcyBBUElVc2VyQWJvcnRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlIHx8ICdSZXF1ZXN0IHdhcyBhYm9ydGVkLicsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuY2xhc3MgQVBJQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSwgY2F1c2UgfSkge1xuICAgICAgICBzdXBlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSB8fCAnQ29ubmVjdGlvbiBlcnJvci4nLCB1bmRlZmluZWQpO1xuICAgICAgICAvLyBpbiBzb21lIGVudmlyb25tZW50cyB0aGUgJ2NhdXNlJyBwcm9wZXJ0eSBpcyBhbHJlYWR5IGRlY2xhcmVkXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGNhdXNlKVxuICAgICAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIH1cbn1cbmNsYXNzIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgZXh0ZW5kcyBBUElDb25uZWN0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoeyBtZXNzYWdlOiBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnUmVxdWVzdCB0aW1lZCBvdXQuJyB9KTtcbiAgICB9XG59XG5jbGFzcyBCYWRSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5jbGFzcyBBdXRoZW50aWNhdGlvbkVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuY2xhc3MgUGVybWlzc2lvbkRlbmllZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmNsYXNzIENvbmZsaWN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5jbGFzcyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5jbGFzcyBSYXRlTGltaXRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmNsYXNzIEludGVybmFsU2VydmVyRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1zY2hlbWUtc3RyaW5nXG5jb25zdCBzdGFydHNXaXRoU2NoZW1lUmVnZXhwID0gL15bYS16XVthLXowLTkrLi1dKjovaTtcbmNvbnN0IGlzQWJzb2x1dGVVUkwgPSAodXJsKSA9PiB7XG4gICAgcmV0dXJuIHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAudGVzdCh1cmwpO1xufTtcbmxldCBpc0FycmF5SW50ZXJuYWwgPSAodmFsKSA9PiAoKGlzQXJyYXlJbnRlcm5hbCA9IEFycmF5LmlzQXJyYXkpLCBpc0FycmF5SW50ZXJuYWwodmFsKSk7XG5jb25zdCBpc0FycmF5ID0gaXNBcnJheUludGVybmFsO1xubGV0IGlzUmVhZG9ubHlBcnJheUludGVybmFsID0gaXNBcnJheTtcbmNvbnN0IGlzUmVhZG9ubHlBcnJheSA9IGlzUmVhZG9ubHlBcnJheUludGVybmFsO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0NDkxMjg3XG5mdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuICAgIGlmICghb2JqKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IF9rIGluIG9iailcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gaHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvbGF0ZXN0L3J1bGVzL25vLXByb3RvdHlwZS1idWlsdGluc1xuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5jb25zdCB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlciA9IChuYW1lLCBuKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihuKSkge1xuICAgICAgICB0aHJvdyBuZXcgR2VtaW5pTmV4dEdlbkFQSUNsaWVudEVycm9yKGAke25hbWV9IG11c3QgYmUgYW4gaW50ZWdlcmApO1xuICAgIH1cbiAgICBpZiAobiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEdlbWluaU5leHRHZW5BUElDbGllbnRFcnJvcihgJHtuYW1lfSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcmApO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn07XG5jb25zdCBzYWZlSlNPTiA9ICh0ZXh0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuY29uc3Qgc2xlZXAkMSA9IChtcykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgVkVSU0lPTiA9ICcwLjAuMSc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG4vKipcbiAqIE5vdGUgdGhpcyBkb2VzIG5vdCBkZXRlY3QgJ2Jyb3dzZXInOyBmb3IgdGhhdCwgdXNlIGdldEJyb3dzZXJJbmZvKCkuXG4gKi9cbmZ1bmN0aW9uIGdldERldGVjdGVkUGxhdGZvcm0oKSB7XG4gICAgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiBEZW5vLmJ1aWxkICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdkZW5vJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBFZGdlUnVudGltZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuICdlZGdlJztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMucHJvY2VzcyA6IDApID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAgICAgcmV0dXJuICdub2RlJztcbiAgICB9XG4gICAgcmV0dXJuICd1bmtub3duJztcbn1cbmNvbnN0IGdldFBsYXRmb3JtUHJvcGVydGllcyA9ICgpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IGRldGVjdGVkUGxhdGZvcm0gPSBnZXREZXRlY3RlZFBsYXRmb3JtKCk7XG4gICAgaWYgKGRldGVjdGVkUGxhdGZvcm0gPT09ICdkZW5vJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtT1MnOiBub3JtYWxpemVQbGF0Zm9ybShEZW5vLmJ1aWxkLm9zKSxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogbm9ybWFsaXplQXJjaChEZW5vLmJ1aWxkLmFyY2gpLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnZGVubycsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogdHlwZW9mIERlbm8udmVyc2lvbiA9PT0gJ3N0cmluZycgPyBEZW5vLnZlcnNpb24gOiAoX2IgPSAoX2EgPSBEZW5vLnZlcnNpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZW5vKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogYG90aGVyOiR7RWRnZVJ1bnRpbWV9YCxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ2VkZ2UnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IGdsb2JhbFRoaXMucHJvY2Vzcy52ZXJzaW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBOb2RlLmpzXG4gICAgaWYgKGRldGVjdGVkUGxhdGZvcm0gPT09ICdub2RlJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtT1MnOiBub3JtYWxpemVQbGF0Zm9ybSgoX2MgPSBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICd1bmtub3duJyksXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IG5vcm1hbGl6ZUFyY2goKF9kID0gZ2xvYmFsVGhpcy5wcm9jZXNzLmFyY2gpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICd1bmtub3duJyksXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdub2RlJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiAoX2UgPSBnbG9iYWxUaGlzLnByb2Nlc3MudmVyc2lvbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ3Vua25vd24nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBicm93c2VySW5mbyA9IGdldEJyb3dzZXJJbmZvKCk7XG4gICAgaWYgKGJyb3dzZXJJbmZvKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogJ3Vua25vd24nLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiBgYnJvd3Nlcjoke2Jyb3dzZXJJbmZvLmJyb3dzZXJ9YCxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBicm93c2VySW5mby52ZXJzaW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBUT0RPIGFkZCBzdXBwb3J0IGZvciBDbG91ZGZsYXJlIHdvcmtlcnMsIGV0Yy5cbiAgICByZXR1cm4ge1xuICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogJ3Vua25vd24nLFxuICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICd1bmtub3duJyxcbiAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6ICd1bmtub3duJyxcbiAgICB9O1xufTtcbi8vIE5vdGU6IG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0pTLURldlRvb2xzL2hvc3QtZW52aXJvbm1lbnQvYmxvYi9iMWFiNzllY2RlMzdkYjVkNmUxNjNjMDUwZTU0ZmU3ZDI4N2Q3YzkyL3NyYy9pc29tb3JwaGljLmJyb3dzZXIudHNcbmZ1bmN0aW9uIGdldEJyb3dzZXJJbmZvKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBOT1RFOiBUaGUgb3JkZXIgbWF0dGVycyBoZXJlIVxuICAgIGNvbnN0IGJyb3dzZXJQYXR0ZXJucyA9IFtcbiAgICAgICAgeyBrZXk6ICdlZGdlJywgcGF0dGVybjogL0VkZ2UoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICAgICAgeyBrZXk6ICdpZScsIHBhdHRlcm46IC9NU0lFKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnaWUnLCBwYXR0ZXJuOiAvVHJpZGVudCg/Oi4qcnZcXDooXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgICAgICB7IGtleTogJ2Nocm9tZScsIHBhdHRlcm46IC9DaHJvbWUoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICAgICAgeyBrZXk6ICdmaXJlZm94JywgcGF0dGVybjogL0ZpcmVmb3goPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICAgICAgeyBrZXk6ICdzYWZhcmknLCBwYXR0ZXJuOiAvKD86VmVyc2lvblxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/KD86XFxXK01vYmlsZVxcUyopP1xcVytTYWZhcmkvIH0sXG4gICAgXTtcbiAgICAvLyBGaW5kIHRoZSBGSVJTVCBtYXRjaGluZyBicm93c2VyXG4gICAgZm9yIChjb25zdCB7IGtleSwgcGF0dGVybiB9IG9mIGJyb3dzZXJQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBtYWpvciA9IG1hdGNoWzFdIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBtaW5vciA9IG1hdGNoWzJdIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBwYXRjaCA9IG1hdGNoWzNdIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4geyBicm93c2VyOiBrZXksIHZlcnNpb246IGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofWAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IG5vcm1hbGl6ZUFyY2ggPSAoYXJjaCkgPT4ge1xuICAgIC8vIE5vZGUgZG9jczpcbiAgICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NhcmNoXG4gICAgLy8gRGVubyBkb2NzOlxuICAgIC8vIC0gaHR0cHM6Ly9kb2MuZGVuby5sYW5kL2Rlbm8vc3RhYmxlL34vRGVuby5idWlsZFxuICAgIGlmIChhcmNoID09PSAneDMyJylcbiAgICAgICAgcmV0dXJuICd4MzInO1xuICAgIGlmIChhcmNoID09PSAneDg2XzY0JyB8fCBhcmNoID09PSAneDY0JylcbiAgICAgICAgcmV0dXJuICd4NjQnO1xuICAgIGlmIChhcmNoID09PSAnYXJtJylcbiAgICAgICAgcmV0dXJuICdhcm0nO1xuICAgIGlmIChhcmNoID09PSAnYWFyY2g2NCcgfHwgYXJjaCA9PT0gJ2FybTY0JylcbiAgICAgICAgcmV0dXJuICdhcm02NCc7XG4gICAgaWYgKGFyY2gpXG4gICAgICAgIHJldHVybiBgb3RoZXI6JHthcmNofWA7XG4gICAgcmV0dXJuICd1bmtub3duJztcbn07XG5jb25zdCBub3JtYWxpemVQbGF0Zm9ybSA9IChwbGF0Zm9ybSkgPT4ge1xuICAgIC8vIE5vZGUgcGxhdGZvcm1zOlxuICAgIC8vIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc3BsYXRmb3JtXG4gICAgLy8gRGVubyBwbGF0Zm9ybXM6XG4gICAgLy8gLSBodHRwczovL2RvYy5kZW5vLmxhbmQvZGVuby9zdGFibGUvfi9EZW5vLmJ1aWxkXG4gICAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVuby9pc3N1ZXMvMTQ3OTlcbiAgICBwbGF0Zm9ybSA9IHBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gTk9URTogdGhpcyBpT1MgY2hlY2sgaXMgdW50ZXN0ZWQgYW5kIG1heSBub3Qgd29ya1xuICAgIC8vIE5vZGUgZG9lcyBub3Qgd29yayBuYXRpdmVseSBvbiBJT1MsIHRoZXJlIGlzIGEgZm9yayBhdFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMtbW9iaWxlL25vZGVqcy1tb2JpbGVcbiAgICAvLyBob3dldmVyIGl0IGlzIHVua25vd24gYXQgdGhlIHRpbWUgb2Ygd3JpdGluZyBob3cgdG8gZGV0ZWN0IGlmIGl0IGlzIHJ1bm5pbmdcbiAgICBpZiAocGxhdGZvcm0uaW5jbHVkZXMoJ2lvcycpKVxuICAgICAgICByZXR1cm4gJ2lPUyc7XG4gICAgaWYgKHBsYXRmb3JtID09PSAnYW5kcm9pZCcpXG4gICAgICAgIHJldHVybiAnQW5kcm9pZCc7XG4gICAgaWYgKHBsYXRmb3JtID09PSAnZGFyd2luJylcbiAgICAgICAgcmV0dXJuICdNYWNPUyc7XG4gICAgaWYgKHBsYXRmb3JtID09PSAnd2luMzInKVxuICAgICAgICByZXR1cm4gJ1dpbmRvd3MnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKVxuICAgICAgICByZXR1cm4gJ0ZyZWVCU0QnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKVxuICAgICAgICByZXR1cm4gJ09wZW5CU0QnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2xpbnV4JylcbiAgICAgICAgcmV0dXJuICdMaW51eCc7XG4gICAgaWYgKHBsYXRmb3JtKVxuICAgICAgICByZXR1cm4gYE90aGVyOiR7cGxhdGZvcm19YDtcbiAgICByZXR1cm4gJ1Vua25vd24nO1xufTtcbmxldCBfcGxhdGZvcm1IZWFkZXJzO1xuY29uc3QgZ2V0UGxhdGZvcm1IZWFkZXJzID0gKCkgPT4ge1xuICAgIHJldHVybiAoX3BsYXRmb3JtSGVhZGVycyAhPT0gbnVsbCAmJiBfcGxhdGZvcm1IZWFkZXJzICE9PSB2b2lkIDAgPyBfcGxhdGZvcm1IZWFkZXJzIDogKF9wbGF0Zm9ybUhlYWRlcnMgPSBnZXRQbGF0Zm9ybVByb3BlcnRpZXMoKSkpO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEZldGNoKCkge1xuICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmZXRjaDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmV0Y2hgIGlzIG5vdCBkZWZpbmVkIGFzIGEgZ2xvYmFsOyBFaXRoZXIgcGFzcyBgZmV0Y2hgIHRvIHRoZSBjbGllbnQsIGBuZXcgR2VtaW5pTmV4dEdlbkFQSUNsaWVudCh7IGZldGNoIH0pYCBvciBwb2x5ZmlsbCB0aGUgZ2xvYmFsLCBgZ2xvYmFsVGhpcy5mZXRjaCA9IGZldGNoYCcpO1xufVxuZnVuY3Rpb24gbWFrZVJlYWRhYmxlU3RyZWFtKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBSZWFkYWJsZVN0cmVhbSA9IGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW07XG4gICAgaWYgKHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTm90ZTogQWxsIG9mIHRoZSBwbGF0Zm9ybXMgLyBydW50aW1lcyB3ZSBvZmZpY2lhbGx5IHN1cHBvcnQgYWxyZWFkeSBkZWZpbmVcbiAgICAgICAgLy8gYFJlYWRhYmxlU3RyZWFtYCBhcyBhIGdsb2JhbCwgc28gdGhpcyBzaG91bGQgb25seSBldmVyIGJlIGhpdCBvbiB1bnN1cHBvcnRlZCBydW50aW1lcy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgUmVhZGFibGVTdHJlYW1gIGlzIG5vdCBkZWZpbmVkIGFzIGEgZ2xvYmFsOyBZb3Ugd2lsbCBuZWVkIHRvIHBvbHlmaWxsIGl0LCBgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSA9IFJlYWRhYmxlU3RyZWFtYCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tKGl0ZXJhYmxlKSB7XG4gICAgbGV0IGl0ZXIgPSBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiBpdGVyYWJsZSA/IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIDogaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIHJldHVybiBtYWtlUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydCgpIHsgfSxcbiAgICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgYXdhaXQgKChfYSA9IGl0ZXIucmV0dXJuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpdGVyKSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIE1vc3QgYnJvd3NlcnMgZG9uJ3QgeWV0IGhhdmUgYXN5bmMgaXRlcmFibGUgc3VwcG9ydCBmb3IgUmVhZGFibGVTdHJlYW0sXG4gKiBhbmQgTm9kZSBoYXMgYSB2ZXJ5IGRpZmZlcmVudCB3YXkgb2YgcmVhZGluZyBieXRlcyBmcm9tIGl0cyBcIlJlYWRhYmxlU3RyZWFtXCIuXG4gKlxuICogVGhpcyBwb2x5ZmlsbCB3YXMgcHVsbGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL01hdHRpYXNCdWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3B1bGwvMTIyI2lzc3VlY29tbWVudC0xNjI3MzU0NDkwXG4gKi9cbmZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtVG9Bc3luY0l0ZXJhYmxlKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayB3aGVuIHN0cmVhbSBiZWNvbWVzIGNsb3NlZFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBlcnJvcmVkXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENhbmNlbHMgYSBSZWFkYWJsZVN0cmVhbSB3ZSBkb24ndCBuZWVkIHRvIGNvbnN1bWUuXG4gKiBTZWUgaHR0cHM6Ly91bmRpY2kubm9kZWpzLm9yZy8jLz9pZD1nYXJiYWdlLWNvbGxlY3Rpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gQ2FuY2VsUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoc3RyZWFtID09PSBudWxsIHx8IHR5cGVvZiBzdHJlYW0gIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSkucmV0dXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gcmVhZGVyLmNhbmNlbCgpO1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgIGF3YWl0IGNhbmNlbFByb21pc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IEZhbGxiYWNrRW5jb2RlciA9ICh7IGhlYWRlcnMsIGJvZHkgfSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJvZHlIZWFkZXJzOiB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICB9O1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgY2hlY2tGaWxlU3VwcG9ydCA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHR5cGVvZiBGaWxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCB7IHByb2Nlc3MgfSA9IGdsb2JhbFRoaXM7XG4gICAgICAgIGNvbnN0IGlzT2xkTm9kZSA9IHR5cGVvZiAoKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLnZlcnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZSkgPT09ICdzdHJpbmcnICYmIHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpKSA8IDIwO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BGaWxlYCBpcyBub3QgZGVmaW5lZCBhcyBhIGdsb2JhbCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIGZpbGUgdXBsb2Fkcy4nICtcbiAgICAgICAgICAgIChpc09sZE5vZGUgP1xuICAgICAgICAgICAgICAgIFwiIFVwZGF0ZSB0byBOb2RlIDIwIExUUyBvciBuZXdlciwgb3Igc2V0IGBnbG9iYWxUaGlzLkZpbGVgIHRvIGBpbXBvcnQoJ25vZGU6YnVmZmVyJykuRmlsZWAuXCJcbiAgICAgICAgICAgICAgICA6ICcnKSk7XG4gICAgfVxufTtcbi8qKlxuICogQ29uc3RydWN0IGEgYEZpbGVgIGluc3RhbmNlLiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIGEgaGVscGZ1bCBlcnJvciBpcyB0aHJvd25cbiAqIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBkZWZpbmUgYSBnbG9iYWwgYEZpbGVgIHlldC5cbiAqL1xuZnVuY3Rpb24gbWFrZUZpbGUoZmlsZUJpdHMsIGZpbGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY2hlY2tGaWxlU3VwcG9ydCgpO1xuICAgIHJldHVybiBuZXcgRmlsZShmaWxlQml0cywgZmlsZU5hbWUgIT09IG51bGwgJiYgZmlsZU5hbWUgIT09IHZvaWQgMCA/IGZpbGVOYW1lIDogJ3Vua25vd25fZmlsZScsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0TmFtZSh2YWx1ZSkge1xuICAgIHJldHVybiAoKCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICgoJ25hbWUnIGluIHZhbHVlICYmIHZhbHVlLm5hbWUgJiYgU3RyaW5nKHZhbHVlLm5hbWUpKSB8fFxuICAgICAgICAgICAgKCd1cmwnIGluIHZhbHVlICYmIHZhbHVlLnVybCAmJiBTdHJpbmcodmFsdWUudXJsKSkgfHxcbiAgICAgICAgICAgICgnZmlsZW5hbWUnIGluIHZhbHVlICYmIHZhbHVlLmZpbGVuYW1lICYmIFN0cmluZyh2YWx1ZS5maWxlbmFtZSkpIHx8XG4gICAgICAgICAgICAoJ3BhdGgnIGluIHZhbHVlICYmIHZhbHVlLnBhdGggJiYgU3RyaW5nKHZhbHVlLnBhdGgpKSkpIHx8XG4gICAgICAgICcnKVxuICAgICAgICAuc3BsaXQoL1tcXFxcL10vKVxuICAgICAgICAucG9wKCkgfHwgdW5kZWZpbmVkKTtcbn1cbmNvbnN0IGlzQXN5bmNJdGVyYWJsZSA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogVGhpcyBjaGVjayBhZGRzIHRoZSBhcnJheUJ1ZmZlcigpIG1ldGhvZCB0eXBlIGJlY2F1c2UgaXQgaXMgYXZhaWxhYmxlIGFuZCB1c2VkIGF0IHJ1bnRpbWVcbiAqL1xuY29uc3QgaXNCbG9iTGlrZSA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUuc2l6ZSA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbi8qKlxuICogVGhpcyBjaGVjayBhZGRzIHRoZSBhcnJheUJ1ZmZlcigpIG1ldGhvZCB0eXBlIGJlY2F1c2UgaXQgaXMgYXZhaWxhYmxlIGFuZCB1c2VkIGF0IHJ1bnRpbWVcbiAqL1xuY29uc3QgaXNGaWxlTGlrZSA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUubmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUubGFzdE1vZGlmaWVkID09PSAnbnVtYmVyJyAmJlxuICAgIGlzQmxvYkxpa2UodmFsdWUpO1xuY29uc3QgaXNSZXNwb25zZUxpa2UgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHZhbHVlLnVybCA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUuYmxvYiA9PT0gJ2Z1bmN0aW9uJztcbi8qKlxuICogSGVscGVyIGZvciBjcmVhdGluZyBhIHtAbGluayBGaWxlfSB0byBwYXNzIHRvIGFuIFNESyB1cGxvYWQgbWV0aG9kIGZyb20gYSB2YXJpZXR5IG9mIGRpZmZlcmVudCBkYXRhIGZvcm1hdHNcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmF3IGNvbnRlbnQgb2YgdGhlIGZpbGUuIENhbiBiZSBhbiB7QGxpbmsgVXBsb2FkYWJsZX0sIEJsb2JMaWtlUGFydCwgb3IgQXN5bmNJdGVyYWJsZSBvZiBCbG9iTGlrZVBhcnRzXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUuIElmIG9taXR0ZWQsIHRvRmlsZSB3aWxsIHRyeSB0byBkZXRlcm1pbmUgYSBmaWxlIG5hbWUgZnJvbSBiaXRzIGlmIHBvc3NpYmxlXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMudHlwZSB0aGUgTUlNRSB0eXBlIG9mIHRoZSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMubGFzdE1vZGlmaWVkIHRoZSBsYXN0IG1vZGlmaWVkIHRpbWVzdGFtcFxuICogQHJldHVybnMgYSB7QGxpbmsgRmlsZX0gd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllc1xuICovXG5hc3luYyBmdW5jdGlvbiB0b0ZpbGUodmFsdWUsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBjaGVja0ZpbGVTdXBwb3J0KCk7XG4gICAgLy8gSWYgaXQncyBhIHByb21pc2UsIHJlc29sdmUgaXQuXG4gICAgdmFsdWUgPSBhd2FpdCB2YWx1ZTtcbiAgICAvLyBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGEgYEZpbGVgIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICBpZiAoaXNGaWxlTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlRmlsZShbYXdhaXQgdmFsdWUuYXJyYXlCdWZmZXIoKV0sIHZhbHVlLm5hbWUpO1xuICAgIH1cbiAgICBpZiAoaXNSZXNwb25zZUxpa2UodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCB2YWx1ZS5ibG9iKCk7XG4gICAgICAgIG5hbWUgfHwgKG5hbWUgPSBuZXcgVVJMKHZhbHVlLnVybCkucGF0aG5hbWUuc3BsaXQoL1tcXFxcL10vKS5wb3AoKSk7XG4gICAgICAgIHJldHVybiBtYWtlRmlsZShhd2FpdCBnZXRCeXRlcyhibG9iKSwgbmFtZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gYXdhaXQgZ2V0Qnl0ZXModmFsdWUpO1xuICAgIG5hbWUgfHwgKG5hbWUgPSBnZXROYW1lKHZhbHVlKSk7XG4gICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJ0cy5maW5kKChwYXJ0KSA9PiB0eXBlb2YgcGFydCA9PT0gJ29iamVjdCcgJiYgJ3R5cGUnIGluIHBhcnQgJiYgcGFydC50eXBlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFrZUZpbGUocGFydHMsIG5hbWUsIG9wdGlvbnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWUpIHtcbiAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgIHZhciBfZDtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8IC8vIGluY2x1ZGVzIFVpbnQ4QXJyYXksIEJ1ZmZlciwgZXRjLlxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHBhcnRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jsb2JMaWtlKHZhbHVlKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKHZhbHVlIGluc3RhbmNlb2YgQmxvYiA/IHZhbHVlIDogYXdhaXQgdmFsdWUuYXJyYXlCdWZmZXIoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXN5bmNJdGVyYWJsZSh2YWx1ZSkgLy8gaW5jbHVkZXMgUmVhZGFibGUsIFJlYWRhYmxlU3RyZWFtLCBldGMuXG4gICAgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIHZhbHVlXzEgPSBfX2FzeW5jVmFsdWVzKHZhbHVlKSwgdmFsdWVfMV8xOyB2YWx1ZV8xXzEgPSBhd2FpdCB2YWx1ZV8xLm5leHQoKSwgX2EgPSB2YWx1ZV8xXzEuZG9uZSwgIV9hOyBfZSA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfYyA9IHZhbHVlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBfZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCguLi4oYXdhaXQgZ2V0Qnl0ZXMoY2h1bmspKSk7IC8vIFRPRE8sIGNvbnNpZGVyIHZhbGlkYXRpbmc/XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IHZhbHVlXzEucmV0dXJuKSkgYXdhaXQgX2IuY2FsbCh2YWx1ZV8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSAoX2QgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5uYW1lO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZGF0YSB0eXBlOiAke3R5cGVvZiB2YWx1ZX0ke2NvbnN0cnVjdG9yID8gYDsgY29uc3RydWN0b3I6ICR7Y29uc3RydWN0b3J9YCA6ICcnfSR7cHJvcHNGb3JFcnJvcih2YWx1ZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIHByb3BzRm9yRXJyb3IodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICAgIHJldHVybiBgOyBwcm9wczogWyR7cHJvcHMubWFwKChwKSA9PiBgXCIke3B9XCJgKS5qb2luKCcsICcpfV1gO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBBUElSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBrZXkgcGF0aCBmcm9tIHRoZSBjbGllbnQuIEZvciBleGFtcGxlLCBhIHJlc291cmNlIGFjY2Vzc2libGUgYXMgYGNsaWVudC5yZXNvdXJjZS5zdWJyZXNvdXJjZWAgd291bGRcbiAqIGhhdmUgYSBwcm9wZXJ0eSBgc3RhdGljIG92ZXJyaWRlIHJlYWRvbmx5IF9rZXkgPSBPYmplY3QuZnJlZXplKFsncmVzb3VyY2UnLCAnc3VicmVzb3VyY2UnXSBhcyBjb25zdCk7YC5cbiAqL1xuQVBJUmVzb3VyY2UuX2tleSA9IFtdO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFBlcmNlbnQtZW5jb2RlIGV2ZXJ5dGhpbmcgdGhhdCBpc24ndCBzYWZlIHRvIGhhdmUgaW4gYSBwYXRoIHdpdGhvdXQgZW5jb2Rpbmcgc2FmZSBjaGFycy5cbiAqXG4gKiBUYWtlbiBmcm9tIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMzpcbiAqID4gdW5yZXNlcnZlZCAgPSBBTFBIQSAvIERJR0lUIC8gXCItXCIgLyBcIi5cIiAvIFwiX1wiIC8gXCJ+XCJcbiAqID4gc3ViLWRlbGltcyAgPSBcIiFcIiAvIFwiJFwiIC8gXCImXCIgLyBcIidcIiAvIFwiKFwiIC8gXCIpXCIgLyBcIipcIiAvIFwiK1wiIC8gXCIsXCIgLyBcIjtcIiAvIFwiPVwiXG4gKiA+IHBjaGFyICAgICAgID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJUGF0aChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1teQS1aYS16MC05XFwtLl9+ISQmJygpKissOz06QF0rL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG59XG5jb25zdCBFTVBUWSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKTtcbmNvbnN0IGNyZWF0ZVBhdGhUYWdGdW5jdGlvbiA9IChwYXRoRW5jb2RlciA9IGVuY29kZVVSSVBhdGgpID0+IChmdW5jdGlvbiBwYXRoKHN0YXRpY3MsIC4uLnBhcmFtcykge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYXJhbXMsIG5vIHByb2Nlc3NpbmcgaXMgbmVlZGVkLlxuICAgIGlmIChzdGF0aWNzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHN0YXRpY3NbMF07XG4gICAgbGV0IHBvc3RQYXRoID0gZmFsc2U7XG4gICAgY29uc3QgaW52YWxpZFNlZ21lbnRzID0gW107XG4gICAgY29uc3QgcGF0aCA9IHN0YXRpY3MucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoL1s/I10vLnRlc3QoY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgICAgcG9zdFBhdGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2luZGV4XTtcbiAgICAgICAgbGV0IGVuY29kZWQgPSAocG9zdFBhdGggPyBlbmNvZGVVUklDb21wb25lbnQgOiBwYXRoRW5jb2RlcikoJycgKyB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gcGFyYW1zLmxlbmd0aCAmJlxuICAgICAgICAgICAgKHZhbHVlID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdmFsdWVzIGZyb20gb3RoZXIgcmVhbG1zXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRvU3RyaW5nID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgKChfYyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZigoX2IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoKF9hID0gdmFsdWUuaGFzT3duUHJvcGVydHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEVNUFRZKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogRU1QVFkpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcpKSkpIHtcbiAgICAgICAgICAgIGVuY29kZWQgPSB2YWx1ZSArICcnO1xuICAgICAgICAgICAgaW52YWxpZFNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2aW91c1ZhbHVlLmxlbmd0aCArIGN1cnJlbnRWYWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBlbmNvZGVkLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBlcnJvcjogYFZhbHVlIG9mIHR5cGUgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoOCwgLTEpfSBpcyBub3QgYSB2YWxpZCBwYXRoIHBhcmFtZXRlcmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZSArIGN1cnJlbnRWYWx1ZSArIChpbmRleCA9PT0gcGFyYW1zLmxlbmd0aCA/ICcnIDogZW5jb2RlZCk7XG4gICAgfSwgJycpO1xuICAgIGNvbnN0IHBhdGhPbmx5ID0gcGF0aC5zcGxpdCgvWz8jXS8sIDEpWzBdO1xuICAgIGNvbnN0IGludmFsaWRTZWdtZW50UGF0dGVybiA9IC8oPzw9XnxcXC8pKD86XFwufCUyZSl7MSwyfSg/PVxcL3wkKS9naTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgLy8gRmluZCBhbGwgaW52YWxpZCBzZWdtZW50c1xuICAgIHdoaWxlICgobWF0Y2ggPSBpbnZhbGlkU2VnbWVudFBhdHRlcm4uZXhlYyhwYXRoT25seSkpICE9PSBudWxsKSB7XG4gICAgICAgIGludmFsaWRTZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBtYXRjaC5pbmRleCxcbiAgICAgICAgICAgIGxlbmd0aDogbWF0Y2hbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgZXJyb3I6IGBWYWx1ZSBcIiR7bWF0Y2hbMF19XCIgY2FuXFwndCBiZSBzYWZlbHkgcGFzc2VkIGFzIGEgcGF0aCBwYXJhbWV0ZXJgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW52YWxpZFNlZ21lbnRzLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KTtcbiAgICBpZiAoaW52YWxpZFNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGxhc3RFbmQgPSAwO1xuICAgICAgICBjb25zdCB1bmRlcmxpbmUgPSBpbnZhbGlkU2VnbWVudHMucmVkdWNlKChhY2MsIHNlZ21lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlcyA9ICcgJy5yZXBlYXQoc2VnbWVudC5zdGFydCAtIGxhc3RFbmQpO1xuICAgICAgICAgICAgY29uc3QgYXJyb3dzID0gJ14nLnJlcGVhdChzZWdtZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICBsYXN0RW5kID0gc2VnbWVudC5zdGFydCArIHNlZ21lbnQubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIHNwYWNlcyArIGFycm93cztcbiAgICAgICAgfSwgJycpO1xuICAgICAgICB0aHJvdyBuZXcgR2VtaW5pTmV4dEdlbkFQSUNsaWVudEVycm9yKGBQYXRoIHBhcmFtZXRlcnMgcmVzdWx0IGluIHBhdGggd2l0aCBpbnZhbGlkIHNlZ21lbnRzOlxcbiR7aW52YWxpZFNlZ21lbnRzXG4gICAgICAgICAgICAubWFwKChlKSA9PiBlLmVycm9yKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpfVxcbiR7cGF0aH1cXG4ke3VuZGVybGluZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59KTtcbi8qKlxuICogVVJJLWVuY29kZXMgcGF0aCBwYXJhbXMgYW5kIGVuc3VyZXMgbm8gdW5zYWZlIC8uLyBvciAvLi4vIHBhdGggc2VnbWVudHMgYXJlIGludHJvZHVjZWQuXG4gKi9cbmNvbnN0IHBhdGggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlUGF0aFRhZ0Z1bmN0aW9uKGVuY29kZVVSSVBhdGgpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBCYXNlSW50ZXJhY3Rpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNyZWF0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGFwaV92ZXJzaW9uID0gdGhpcy5fY2xpZW50LmFwaVZlcnNpb24gfSA9IHBhcmFtcywgYm9keSA9IF9fcmVzdChwYXJhbXMsIFtcImFwaV92ZXJzaW9uXCJdKTtcbiAgICAgICAgaWYgKCdtb2RlbCcgaW4gYm9keSAmJiAnYWdlbnRfY29uZmlnJyBpbiBib2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR2VtaW5pTmV4dEdlbkFQSUNsaWVudEVycm9yKGBJbnZhbGlkIHJlcXVlc3Q6IHNwZWNpZmllZCBcXGBtb2RlbFxcYCBhbmQgXFxgYWdlbnRfY29uZmlnXFxgLiBJZiBzcGVjaWZ5aW5nIFxcYG1vZGVsXFxgLCB1c2UgXFxgZ2VuZXJhdGlvbl9jb25maWdcXGAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdhZ2VudCcgaW4gYm9keSAmJiAnZ2VuZXJhdGlvbl9jb25maWcnIGluIGJvZHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50RXJyb3IoYEludmFsaWQgcmVxdWVzdDogc3BlY2lmaWVkIFxcYGFnZW50XFxgIGFuZCBcXGBnZW5lcmF0aW9uX2NvbmZpZ1xcYC4gSWYgc3BlY2lmeWluZyBcXGBhZ2VudFxcYCwgdXNlIFxcYGFnZW50X2NvbmZpZ1xcYC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QocGF0aCBgLyR7YXBpX3ZlcnNpb259L2ludGVyYWN0aW9uc2AsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGJvZHkgfSwgb3B0aW9ucyksIHsgc3RyZWFtOiAoX2EgPSBwYXJhbXMuc3RyZWFtKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIGludGVyYWN0aW9uIGJ5IGlkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGludGVyYWN0aW9uID0gYXdhaXQgY2xpZW50LmludGVyYWN0aW9ucy5kZWxldGUoJ2lkJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZGVsZXRlKGlkLCBwYXJhbXMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGFwaV92ZXJzaW9uID0gdGhpcy5fY2xpZW50LmFwaVZlcnNpb24gfSA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShwYXRoIGAvJHthcGlfdmVyc2lvbn0vaW50ZXJhY3Rpb25zLyR7aWR9YCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gaW50ZXJhY3Rpb24gYnkgaWQuIFRoaXMgb25seSBhcHBsaWVzIHRvIGJhY2tncm91bmQgaW50ZXJhY3Rpb25zIHRoYXQgYXJlIHN0aWxsIHJ1bm5pbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgaW50ZXJhY3Rpb24gPSBhd2FpdCBjbGllbnQuaW50ZXJhY3Rpb25zLmNhbmNlbCgnaWQnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjYW5jZWwoaWQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYXBpX3ZlcnNpb24gPSB0aGlzLl9jbGllbnQuYXBpVmVyc2lvbiB9ID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChwYXRoIGAvJHthcGlfdmVyc2lvbn0vaW50ZXJhY3Rpb25zLyR7aWR9L2NhbmNlbGAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQoaWQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgX2IgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fSwgeyBhcGlfdmVyc2lvbiA9IHRoaXMuX2NsaWVudC5hcGlWZXJzaW9uIH0gPSBfYiwgcXVlcnkgPSBfX3Jlc3QoX2IsIFtcImFwaV92ZXJzaW9uXCJdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQocGF0aCBgLyR7YXBpX3ZlcnNpb259L2ludGVyYWN0aW9ucy8ke2lkfWAsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHF1ZXJ5IH0sIG9wdGlvbnMpLCB7IHN0cmVhbTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnN0cmVhbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UgfSkpO1xuICAgIH1cbn1cbkJhc2VJbnRlcmFjdGlvbnMuX2tleSA9IE9iamVjdC5mcmVlemUoWydpbnRlcmFjdGlvbnMnXSk7XG5jbGFzcyBJbnRlcmFjdGlvbnMgZXh0ZW5kcyBCYXNlSW50ZXJhY3Rpb25zIHtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoYnVmZmVycykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgICAgICAgbGVuZ3RoICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICAgIG91dHB1dC5zZXQoYnVmZmVyLCBpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5sZXQgZW5jb2RlVVRGOF87XG5mdW5jdGlvbiBlbmNvZGVVVEY4KHN0cikge1xuICAgIGxldCBlbmNvZGVyO1xuICAgIHJldHVybiAoZW5jb2RlVVRGOF8gIT09IG51bGwgJiYgZW5jb2RlVVRGOF8gIT09IHZvaWQgMCA/IGVuY29kZVVURjhfIDogKChlbmNvZGVyID0gbmV3IGdsb2JhbFRoaXMuVGV4dEVuY29kZXIoKSksIChlbmNvZGVVVEY4XyA9IGVuY29kZXIuZW5jb2RlLmJpbmQoZW5jb2RlcikpKSkoc3RyKTtcbn1cbmxldCBkZWNvZGVVVEY4XztcbmZ1bmN0aW9uIGRlY29kZVVURjgoYnl0ZXMpIHtcbiAgICBsZXQgZGVjb2RlcjtcbiAgICByZXR1cm4gKGRlY29kZVVURjhfICE9PSBudWxsICYmIGRlY29kZVVURjhfICE9PSB2b2lkIDAgPyBkZWNvZGVVVEY4XyA6ICgoZGVjb2RlciA9IG5ldyBnbG9iYWxUaGlzLlRleHREZWNvZGVyKCkpLCAoZGVjb2RlVVRGOF8gPSBkZWNvZGVyLmRlY29kZS5iaW5kKGRlY29kZXIpKSkpKGJ5dGVzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBBIHJlLWltcGxlbWVudGF0aW9uIG9mIGh0dHB4J3MgYExpbmVEZWNvZGVyYCBpbiBQeXRob24gdGhhdCBoYW5kbGVzIGluY3JlbWVudGFsbHlcbiAqIHJlYWRpbmcgbGluZXMgZnJvbSB0ZXh0LlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lbmNvZGUvaHR0cHgvYmxvYi85MjAzMzNlYTk4MTE4ZTljZjYxN2YyNDY5MDVkN2IyMDI1MTA5NDFjL2h0dHB4L19kZWNvZGVycy5weSNMMjU4XG4gKi9cbmNsYXNzIExpbmVEZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICB0aGlzLmNhcnJpYWdlUmV0dXJuSW5kZXggPSBudWxsO1xuICAgIH1cbiAgICBkZWNvZGUoY2h1bmspIHtcbiAgICAgICAgaWYgKGNodW5rID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaW5hcnlDaHVuayA9IGNodW5rIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShjaHVuaylcbiAgICAgICAgICAgIDogdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IGVuY29kZVVURjgoY2h1bmspXG4gICAgICAgICAgICAgICAgOiBjaHVuaztcbiAgICAgICAgdGhpcy5idWZmZXIgPSBjb25jYXRCeXRlcyhbdGhpcy5idWZmZXIsIGJpbmFyeUNodW5rXSk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgICAgIGxldCBwYXR0ZXJuSW5kZXg7XG4gICAgICAgIHdoaWxlICgocGF0dGVybkluZGV4ID0gZmluZE5ld2xpbmVJbmRleCh0aGlzLmJ1ZmZlciwgdGhpcy5jYXJyaWFnZVJldHVybkluZGV4KSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHBhdHRlcm5JbmRleC5jYXJyaWFnZSAmJiB0aGlzLmNhcnJpYWdlUmV0dXJuSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdW50aWwgd2UgZWl0aGVyIGdldCBhIGNvcnJlc3BvbmRpbmcgYFxcbmAsIGEgbmV3IGBcXHJgIG9yIG5vdGhpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmNhcnJpYWdlUmV0dXJuSW5kZXggPSBwYXR0ZXJuSW5kZXguaW5kZXg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBnb3QgZG91YmxlIFxcciBvciBcXHJ0ZXh0XFxuXG4gICAgICAgICAgICBpZiAodGhpcy5jYXJyaWFnZVJldHVybkluZGV4ICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAocGF0dGVybkluZGV4LmluZGV4ICE9PSB0aGlzLmNhcnJpYWdlUmV0dXJuSW5kZXggKyAxIHx8IHBhdHRlcm5JbmRleC5jYXJyaWFnZSkpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGRlY29kZVVURjgodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5jYXJyaWFnZVJldHVybkluZGV4IC0gMSkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMuY2FycmlhZ2VSZXR1cm5JbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXJyaWFnZVJldHVybkluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5jYXJyaWFnZVJldHVybkluZGV4ICE9PSBudWxsID8gcGF0dGVybkluZGV4LnByZWNlZGluZyAtIDEgOiBwYXR0ZXJuSW5kZXgucHJlY2VkaW5nO1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGRlY29kZVVURjgodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgZW5kSW5kZXgpKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YmFycmF5KHBhdHRlcm5JbmRleC5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLmNhcnJpYWdlUmV0dXJuSW5kZXggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKCdcXG4nKTtcbiAgICB9XG59XG4vLyBwcmV0dGllci1pZ25vcmVcbkxpbmVEZWNvZGVyLk5FV0xJTkVfQ0hBUlMgPSBuZXcgU2V0KFsnXFxuJywgJ1xcciddKTtcbkxpbmVEZWNvZGVyLk5FV0xJTkVfUkVHRVhQID0gL1xcclxcbnxbXFxuXFxyXS9nO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHNlYXJjaGVzIHRoZSBidWZmZXIgZm9yIHRoZSBlbmQgcGF0dGVybnMsIChcXHIgb3IgXFxuKVxuICogYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGluZGV4IHByZWNlZGluZyB0aGUgbWF0Y2hlZCBuZXdsaW5lIGFuZCB0aGVcbiAqIGluZGV4IGFmdGVyIHRoZSBuZXdsaW5lIGNoYXIuIGBudWxsYCBpcyByZXR1cm5lZCBpZiBubyBuZXcgbGluZSBpcyBmb3VuZC5cbiAqXG4gKiBgYGB0c1xuICogZmluZE5ld0xpbmVJbmRleCgnYWJjXFxuZGVmJykgLT4geyBwcmVjZWRpbmc6IDIsIGluZGV4OiAzIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBmaW5kTmV3bGluZUluZGV4KGJ1ZmZlciwgc3RhcnRJbmRleCkge1xuICAgIGNvbnN0IG5ld2xpbmUgPSAweDBhOyAvLyBcXG5cbiAgICBjb25zdCBjYXJyaWFnZSA9IDB4MGQ7IC8vIFxcclxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4ICE9PSBudWxsICYmIHN0YXJ0SW5kZXggIT09IHZvaWQgMCA/IHN0YXJ0SW5kZXggOiAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChidWZmZXJbaV0gPT09IG5ld2xpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNlZGluZzogaSwgaW5kZXg6IGkgKyAxLCBjYXJyaWFnZTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSBjYXJyaWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcHJlY2VkaW5nOiBpLCBpbmRleDogaSArIDEsIGNhcnJpYWdlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kRG91YmxlTmV3bGluZUluZGV4KGJ1ZmZlcikge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gc2VhcmNoZXMgdGhlIGJ1ZmZlciBmb3IgdGhlIGVuZCBwYXR0ZXJucyAoXFxyXFxyLCBcXG5cXG4sIFxcclxcblxcclxcbilcbiAgICAvLyBhbmQgcmV0dXJucyB0aGUgaW5kZXggcmlnaHQgYWZ0ZXIgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW55IHBhdHRlcm4sXG4gICAgLy8gb3IgLTEgaWYgbm9uZSBvZiB0aGUgcGF0dGVybnMgYXJlIGZvdW5kLlxuICAgIGNvbnN0IG5ld2xpbmUgPSAweDBhOyAvLyBcXG5cbiAgICBjb25zdCBjYXJyaWFnZSA9IDB4MGQ7IC8vIFxcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSBuZXdsaW5lICYmIGJ1ZmZlcltpICsgMV0gPT09IG5ld2xpbmUpIHtcbiAgICAgICAgICAgIC8vIFxcblxcblxuICAgICAgICAgICAgcmV0dXJuIGkgKyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXJbaV0gPT09IGNhcnJpYWdlICYmIGJ1ZmZlcltpICsgMV0gPT09IGNhcnJpYWdlKSB7XG4gICAgICAgICAgICAvLyBcXHJcXHJcbiAgICAgICAgICAgIHJldHVybiBpICsgMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSBjYXJyaWFnZSAmJlxuICAgICAgICAgICAgYnVmZmVyW2kgKyAxXSA9PT0gbmV3bGluZSAmJlxuICAgICAgICAgICAgaSArIDMgPCBidWZmZXIubGVuZ3RoICYmXG4gICAgICAgICAgICBidWZmZXJbaSArIDJdID09PSBjYXJyaWFnZSAmJlxuICAgICAgICAgICAgYnVmZmVyW2kgKyAzXSA9PT0gbmV3bGluZSkge1xuICAgICAgICAgICAgLy8gXFxyXFxuXFxyXFxuXG4gICAgICAgICAgICByZXR1cm4gaSArIDQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuY29uc3QgbGV2ZWxOdW1iZXJzID0ge1xuICAgIG9mZjogMCxcbiAgICBlcnJvcjogMjAwLFxuICAgIHdhcm46IDMwMCxcbiAgICBpbmZvOiA0MDAsXG4gICAgZGVidWc6IDUwMCxcbn07XG5jb25zdCBwYXJzZUxvZ0xldmVsID0gKG1heWJlTGV2ZWwsIHNvdXJjZU5hbWUsIGNsaWVudCkgPT4ge1xuICAgIGlmICghbWF5YmVMZXZlbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaGFzT3duKGxldmVsTnVtYmVycywgbWF5YmVMZXZlbCkpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlTGV2ZWw7XG4gICAgfVxuICAgIGxvZ2dlckZvcihjbGllbnQpLndhcm4oYCR7c291cmNlTmFtZX0gd2FzIHNldCB0byAke0pTT04uc3RyaW5naWZ5KG1heWJlTGV2ZWwpfSwgZXhwZWN0ZWQgb25lIG9mICR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMobGV2ZWxOdW1iZXJzKSl9YCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5mdW5jdGlvbiBub29wKCkgeyB9XG5mdW5jdGlvbiBtYWtlTG9nRm4oZm5MZXZlbCwgbG9nZ2VyLCBsb2dMZXZlbCkge1xuICAgIGlmICghbG9nZ2VyIHx8IGxldmVsTnVtYmVyc1tmbkxldmVsXSA+IGxldmVsTnVtYmVyc1tsb2dMZXZlbF0pIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEb24ndCB3cmFwIGxvZ2dlciBmdW5jdGlvbnMsIHdlIHdhbnQgdGhlIHN0YWNrdHJhY2UgaW50YWN0IVxuICAgICAgICByZXR1cm4gbG9nZ2VyW2ZuTGV2ZWxdLmJpbmQobG9nZ2VyKTtcbiAgICB9XG59XG5jb25zdCBub29wTG9nZ2VyID0ge1xuICAgIGVycm9yOiBub29wLFxuICAgIHdhcm46IG5vb3AsXG4gICAgaW5mbzogbm9vcCxcbiAgICBkZWJ1Zzogbm9vcCxcbn07XG5sZXQgY2FjaGVkTG9nZ2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbG9nZ2VyRm9yKGNsaWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIgPSBjbGllbnQubG9nZ2VyO1xuICAgIGNvbnN0IGxvZ0xldmVsID0gKF9hID0gY2xpZW50LmxvZ0xldmVsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnb2ZmJztcbiAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICByZXR1cm4gbm9vcExvZ2dlcjtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkTG9nZ2VyID0gY2FjaGVkTG9nZ2Vycy5nZXQobG9nZ2VyKTtcbiAgICBpZiAoY2FjaGVkTG9nZ2VyICYmIGNhY2hlZExvZ2dlclswXSA9PT0gbG9nTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZExvZ2dlclsxXTtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWxMb2dnZXIgPSB7XG4gICAgICAgIGVycm9yOiBtYWtlTG9nRm4oJ2Vycm9yJywgbG9nZ2VyLCBsb2dMZXZlbCksXG4gICAgICAgIHdhcm46IG1ha2VMb2dGbignd2FybicsIGxvZ2dlciwgbG9nTGV2ZWwpLFxuICAgICAgICBpbmZvOiBtYWtlTG9nRm4oJ2luZm8nLCBsb2dnZXIsIGxvZ0xldmVsKSxcbiAgICAgICAgZGVidWc6IG1ha2VMb2dGbignZGVidWcnLCBsb2dnZXIsIGxvZ0xldmVsKSxcbiAgICB9O1xuICAgIGNhY2hlZExvZ2dlcnMuc2V0KGxvZ2dlciwgW2xvZ0xldmVsLCBsZXZlbExvZ2dlcl0pO1xuICAgIHJldHVybiBsZXZlbExvZ2dlcjtcbn1cbmNvbnN0IGZvcm1hdFJlcXVlc3REZXRhaWxzID0gKGRldGFpbHMpID0+IHtcbiAgICBpZiAoZGV0YWlscy5vcHRpb25zKSB7XG4gICAgICAgIGRldGFpbHMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRldGFpbHMub3B0aW9ucyk7XG4gICAgICAgIGRlbGV0ZSBkZXRhaWxzLm9wdGlvbnNbJ2hlYWRlcnMnXTsgLy8gcmVkdW5kYW50ICsgbGVha3MgaW50ZXJuYWxzXG4gICAgfVxuICAgIGlmIChkZXRhaWxzLmhlYWRlcnMpIHtcbiAgICAgICAgZGV0YWlscy5oZWFkZXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKChkZXRhaWxzLmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzID8gWy4uLmRldGFpbHMuaGVhZGVyc10gOiBPYmplY3QuZW50cmllcyhkZXRhaWxzLmhlYWRlcnMpKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAobmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC1nb29nLWFwaS1rZXknIHx8XG4gICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYXV0aG9yaXphdGlvbicgfHxcbiAgICAgICAgICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjb29raWUnIHx8XG4gICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2V0LWNvb2tpZScpID9cbiAgICAgICAgICAgICAgICAnKioqJ1xuICAgICAgICAgICAgICAgIDogdmFsdWUsXG4gICAgICAgIF0pKTtcbiAgICB9XG4gICAgaWYgKCdyZXRyeU9mUmVxdWVzdExvZ0lEJyBpbiBkZXRhaWxzKSB7XG4gICAgICAgIGlmIChkZXRhaWxzLnJldHJ5T2ZSZXF1ZXN0TG9nSUQpIHtcbiAgICAgICAgICAgIGRldGFpbHMucmV0cnlPZiA9IGRldGFpbHMucmV0cnlPZlJlcXVlc3RMb2dJRDtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZGV0YWlscy5yZXRyeU9mUmVxdWVzdExvZ0lEO1xuICAgIH1cbiAgICByZXR1cm4gZGV0YWlscztcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoaXRlcmF0b3IsIGNvbnRyb2xsZXIsIGNsaWVudCkge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVNTRVJlc3BvbnNlKHJlc3BvbnNlLCBjb250cm9sbGVyLCBjbGllbnQpIHtcbiAgICAgICAgbGV0IGNvbnN1bWVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGxvZ2dlciA9IGNsaWVudCA/IGxvZ2dlckZvcihjbGllbnQpIDogY29uc29sZTtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBpdGVyYXRvcl8xKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50RXJyb3IoJ0Nhbm5vdCBpdGVyYXRlIG92ZXIgYSBjb25zdW1lZCBzdHJlYW0sIHVzZSBgLnRlZSgpYCB0byBzcGxpdCB0aGUgc3RyZWFtLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IF9fYXN5bmNWYWx1ZXMoX2l0ZXJTU0VNZXNzYWdlcyhyZXNwb25zZSwgY29udHJvbGxlcikpLCBfZjsgX2YgPSB5aWVsZCBfX2F3YWl0KF9lLm5leHQoKSksIF9hID0gX2YuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3NlID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzc2UuZGF0YS5zdGFydHNXaXRoKCdbRE9ORV0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChKU09OLnBhcnNlKHNzZS5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgQ291bGQgbm90IHBhcnNlIG1lc3NhZ2UgaW50byBKU09OOmAsIHNzZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRnJvbSBjaHVuazpgLCBzc2UucmF3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IF9lLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChfZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBjYWxscyBgc3RyZWFtLmNvbnRyb2xsZXIuYWJvcnQoKWAsIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgdGhyb3dpbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX19hd2FpdCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgYGJyZWFrYHMsIGFib3J0IHRoZSBvbmdvaW5nIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShpdGVyYXRvciwgY29udHJvbGxlciwgY2xpZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgU3RyZWFtIGZyb20gYSBuZXdsaW5lLXNlcGFyYXRlZCBSZWFkYWJsZVN0cmVhbVxuICAgICAqIHdoZXJlIGVhY2ggaXRlbSBpcyBhIEpTT04gdmFsdWUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgY29udHJvbGxlciwgY2xpZW50KSB7XG4gICAgICAgIGxldCBjb25zdW1lZCA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBpdGVyTGluZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBpdGVyTGluZXNfMSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVEZWNvZGVyID0gbmV3IExpbmVEZWNvZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlciA9IFJlYWRhYmxlU3RyZWFtVG9Bc3luY0l0ZXJhYmxlKHJlYWRhYmxlU3RyZWFtKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJfMSA9IF9fYXN5bmNWYWx1ZXMoaXRlciksIGl0ZXJfMV8xOyBpdGVyXzFfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcl8xLm5leHQoKSksIF9hID0gaXRlcl8xXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcl8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5kZWNvZGUoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcl8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5mbHVzaCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBpdGVyYXRvcl8yKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgZV8zLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50RXJyb3IoJ0Nhbm5vdCBpdGVyYXRlIG92ZXIgYSBjb25zdW1lZCBzdHJlYW0sIHVzZSBgLnRlZSgpYCB0byBzcGxpdCB0aGUgc3RyZWFtLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IF9fYXN5bmNWYWx1ZXMoaXRlckxpbmVzKCkpLCBfZjsgX2YgPSB5aWVsZCBfX2F3YWl0KF9lLm5leHQoKSksIF9hID0gX2YuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoSlNPTi5wYXJzZShsaW5lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IF9lLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChfZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBjYWxscyBgc3RyZWFtLmNvbnRyb2xsZXIuYWJvcnQoKWAsIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgdGhyb3dpbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX19hd2FpdCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgYGJyZWFrYHMsIGFib3J0IHRoZSBvbmdvaW5nIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShpdGVyYXRvciwgY29udHJvbGxlciwgY2xpZW50KTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BsaXRzIHRoZSBzdHJlYW0gaW50byB0d28gc3RyZWFtcyB3aGljaCBjYW4gYmVcbiAgICAgKiBpbmRlcGVuZGVudGx5IHJlYWQgZnJvbSBhdCBkaWZmZXJlbnQgc3BlZWRzLlxuICAgICAqL1xuICAgIHRlZSgpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IFtdO1xuICAgICAgICBjb25zdCByaWdodCA9IFtdO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgY29uc3QgdGVlSXRlcmF0b3IgPSAocXVldWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBTdHJlYW0oKCkgPT4gdGVlSXRlcmF0b3IobGVmdCksIHRoaXMuY29udHJvbGxlciwgdGhpcy5jbGllbnQpLFxuICAgICAgICAgICAgbmV3IFN0cmVhbSgoKSA9PiB0ZWVJdGVyYXRvcihyaWdodCksIHRoaXMuY29udHJvbGxlciwgdGhpcy5jbGllbnQpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIHN0cmVhbSB0byBhIG5ld2xpbmUtc2VwYXJhdGVkIFJlYWRhYmxlU3RyZWFtIG9mXG4gICAgICogSlNPTiBzdHJpbmdpZmllZCB2YWx1ZXMgaW4gdGhlIHN0cmVhbVxuICAgICAqIHdoaWNoIGNhbiBiZSB0dXJuZWQgYmFjayBpbnRvIGEgU3RyZWFtIHdpdGggYFN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0oKWAuXG4gICAgICovXG4gICAgdG9SZWFkYWJsZVN0cmVhbSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBpdGVyO1xuICAgICAgICByZXR1cm4gbWFrZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGl0ZXIgPSBzZWxmW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIHB1bGwoY3RybCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHJsLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZW5jb2RlVVRGOChKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZW5xdWV1ZShieXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2EgPSBpdGVyLnJldHVybikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaXRlcikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2l0ZXJTU0VNZXNzYWdlcyhyZXNwb25zZSwgY29udHJvbGxlcikge1xuICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIF9pdGVyU1NFTWVzc2FnZXNfMSgpIHtcbiAgICAgICAgdmFyIF9hLCBlXzQsIF9iLCBfYztcbiAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMubmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMubmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR2VtaW5pTmV4dEdlbkFQSUNsaWVudEVycm9yKGBUaGUgZGVmYXVsdCByZWFjdC1uYXRpdmUgZmV0Y2ggaW1wbGVtZW50YXRpb24gZG9lcyBub3Qgc3VwcG9ydCBzdHJlYW1pbmcuIFBsZWFzZSB1c2UgZXhwby9mZXRjaDogaHR0cHM6Ly9kb2NzLmV4cG8uZGV2L3ZlcnNpb25zL2xhdGVzdC9zZGsvZXhwby8jZXhwb2ZldGNoLWFwaWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdlbWluaU5leHRHZW5BUElDbGllbnRFcnJvcihgQXR0ZW1wdGVkIHRvIGl0ZXJhdGUgb3ZlciBhIHJlc3BvbnNlIHdpdGggbm8gYm9keWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNzZURlY29kZXIgPSBuZXcgU1NFRGVjb2RlcigpO1xuICAgICAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuICAgICAgICBjb25zdCBpdGVyID0gUmVhZGFibGVTdHJlYW1Ub0FzeW5jSXRlcmFibGUocmVzcG9uc2UuYm9keSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIF9lID0gX19hc3luY1ZhbHVlcyhpdGVyU1NFQ2h1bmtzKGl0ZXIpKSwgX2Y7IF9mID0geWllbGQgX19hd2FpdChfZS5uZXh0KCkpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgX2MgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNzZUNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVEZWNvZGVyLmRlY29kZShzc2VDaHVuaykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3NlID0gc3NlRGVjb2Rlci5kZWNvZGUobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHNzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoX2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZmx1c2goKSkge1xuICAgICAgICAgICAgY29uc3Qgc3NlID0gc3NlRGVjb2Rlci5kZWNvZGUobGluZSk7XG4gICAgICAgICAgICBpZiAoc3NlKVxuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoc3NlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBHaXZlbiBhbiBhc3luYyBpdGVyYWJsZSBpdGVyYXRvciwgaXRlcmF0ZXMgb3ZlciBpdCBhbmQgeWllbGRzIGZ1bGxcbiAqIFNTRSBjaHVua3MsIGkuZS4geWllbGRzIHdoZW4gYSBkb3VibGUgbmV3LWxpbmUgaXMgZW5jb3VudGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGl0ZXJTU0VDaHVua3MoaXRlcmF0b3IpIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBpdGVyU1NFQ2h1bmtzXzEoKSB7XG4gICAgICAgIHZhciBfYSwgZV81LCBfYiwgX2M7XG4gICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmF0b3JfMyA9IF9fYXN5bmNWYWx1ZXMoaXRlcmF0b3IpLCBpdGVyYXRvcl8zXzE7IGl0ZXJhdG9yXzNfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmF0b3JfMy5uZXh0KCkpLCBfYSA9IGl0ZXJhdG9yXzNfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9jID0gaXRlcmF0b3JfM18xLnZhbHVlO1xuICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmluYXJ5Q2h1bmsgPSBjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IGVuY29kZVVURjgoY2h1bmspXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNodW5rO1xuICAgICAgICAgICAgICAgIGxldCBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBiaW5hcnlDaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG5ld0RhdGEuc2V0KGRhdGEpO1xuICAgICAgICAgICAgICAgIG5ld0RhdGEuc2V0KGJpbmFyeUNodW5rLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm5JbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHBhdHRlcm5JbmRleCA9IGZpbmREb3VibGVOZXdsaW5lSW5kZXgoZGF0YSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGRhdGEuc2xpY2UoMCwgcGF0dGVybkluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKHBhdHRlcm5JbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYXRvcl8zLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYXRvcl8zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChkYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY2xhc3MgU1NFRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICB9XG4gICAgZGVjb2RlKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUuZW5kc1dpdGgoJ1xccicpKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMCwgbGluZS5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IGxpbmUgYW5kIHdlIGRpZG4ndCBwcmV2aW91c2x5IGVuY291bnRlciBhbnkgbWVzc2FnZXNcbiAgICAgICAgICAgIGlmICghdGhpcy5ldmVudCAmJiAhdGhpcy5kYXRhLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHNzZSA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgcmF3OiB0aGlzLmNodW5rcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBzc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChsaW5lKTtcbiAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgW2ZpZWxkbmFtZSwgXywgdmFsdWVdID0gcGFydGl0aW9uKGxpbmUsICc6Jyk7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcgJykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZG5hbWUgPT09ICdldmVudCcpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZG5hbWUgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnRpdGlvbihzdHIsIGRlbGltaXRlcikge1xuICAgIGNvbnN0IGluZGV4ID0gc3RyLmluZGV4T2YoZGVsaW1pdGVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbc3RyLnN1YnN0cmluZygwLCBpbmRleCksIGRlbGltaXRlciwgc3RyLnN1YnN0cmluZyhpbmRleCArIGRlbGltaXRlci5sZW5ndGgpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHIsICcnLCAnJ107XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHRQYXJzZVJlc3BvbnNlKGNsaWVudCwgcHJvcHMpIHtcbiAgICBjb25zdCB7IHJlc3BvbnNlLCByZXF1ZXN0TG9nSUQsIHJldHJ5T2ZSZXF1ZXN0TG9nSUQsIHN0YXJ0VGltZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHByb3BzLm9wdGlvbnMuc3RyZWFtKSB7XG4gICAgICAgICAgICBsb2dnZXJGb3IoY2xpZW50KS5kZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywgcmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGVyZSBpcyBhbiBpbnZhcmlhbnQgaGVyZSB0aGF0IGlzbid0IHJlcHJlc2VudGVkIGluIHRoZSB0eXBlIHN5c3RlbVxuICAgICAgICAgICAgLy8gdGhhdCBpZiB5b3Ugc2V0IGBzdHJlYW06IHRydWVgIHRoZSByZXNwb25zZSB0eXBlIG11c3QgYWxzbyBiZSBgU3RyZWFtPFQ+YFxuICAgICAgICAgICAgaWYgKHByb3BzLm9wdGlvbnMuX19zdHJlYW1DbGFzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5vcHRpb25zLl9fc3RyZWFtQ2xhc3MuZnJvbVNTRVJlc3BvbnNlKHJlc3BvbnNlLCBwcm9wcy5jb250cm9sbGVyLCBjbGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbS5mcm9tU1NFUmVzcG9uc2UocmVzcG9uc2UsIHByb3BzLmNvbnRyb2xsZXIsIGNsaWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmV0Y2ggcmVmdXNlcyB0byByZWFkIHRoZSBib2R5IHdoZW4gdGhlIHN0YXR1cyBjb2RlIGlzIDIwNC5cbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMub3B0aW9ucy5fX2JpbmFyeVJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgIGNvbnN0IG1lZGlhVHlwZSA9IChfYSA9IGNvbnRlbnRUeXBlID09PSBudWxsIHx8IGNvbnRlbnRUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50VHlwZS5zcGxpdCgnOycpWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJpbSgpO1xuICAgICAgICBjb25zdCBpc0pTT04gPSAobWVkaWFUeXBlID09PSBudWxsIHx8IG1lZGlhVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVkaWFUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHx8IChtZWRpYVR5cGUgPT09IG51bGwgfHwgbWVkaWFUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZWRpYVR5cGUuZW5kc1dpdGgoJytqc29uJykpO1xuICAgICAgICBpZiAoaXNKU09OKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSkoKTtcbiAgICBsb2dnZXJGb3IoY2xpZW50KS5kZWJ1ZyhgWyR7cmVxdWVzdExvZ0lEfV0gcmVzcG9uc2UgcGFyc2VkYCwgZm9ybWF0UmVxdWVzdERldGFpbHMoe1xuICAgICAgICByZXRyeU9mUmVxdWVzdExvZ0lELFxuICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGR1cmF0aW9uTXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgfSkpO1xuICAgIHJldHVybiBib2R5O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIEEgc3ViY2xhc3Mgb2YgYFByb21pc2VgIHByb3ZpZGluZyBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzXG4gKiBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgU0RLLlxuICovXG5jbGFzcyBBUElQcm9taXNlIGV4dGVuZHMgUHJvbWlzZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50LCByZXNwb25zZVByb21pc2UsIHBhcnNlUmVzcG9uc2UgPSBkZWZhdWx0UGFyc2VSZXNwb25zZSkge1xuICAgICAgICBzdXBlcigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBtYXliZSBhIGJpdCB3ZWlyZCBidXQgdGhpcyBoYXMgdG8gYmUgYSBuby1vcCB0byBub3QgaW1wbGljaXRseVxuICAgICAgICAgICAgLy8gcGFyc2UgdGhlIHJlc3BvbnNlIGJvZHk7IGluc3RlYWQgLnRoZW4sIC5jYXRjaCwgLmZpbmFsbHkgYXJlIG92ZXJyaWRkZW5cbiAgICAgICAgICAgIC8vIHRvIHBhcnNlIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzcG9uc2VQcm9taXNlID0gcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICB0aGlzLnBhcnNlUmVzcG9uc2UgPSBwYXJzZVJlc3BvbnNlO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgX3RoZW5VbndyYXAodHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVBJUHJvbWlzZSh0aGlzLmNsaWVudCwgdGhpcy5yZXNwb25zZVByb21pc2UsIGFzeW5jIChjbGllbnQsIHByb3BzKSA9PiB0cmFuc2Zvcm0oYXdhaXQgdGhpcy5wYXJzZVJlc3BvbnNlKGNsaWVudCwgcHJvcHMpLCBwcm9wcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSBpbnN0ZWFkIG9mIHBhcnNpbmcgdGhlIHJlc3BvbnNlXG4gICAgICogZGF0YS5cbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IHRvIHBhcnNlIHRoZSByZXNwb25zZSBib2R5IGJ1dCBzdGlsbCBnZXQgdGhlIGBSZXNwb25zZWBcbiAgICAgKiBpbnN0YW5jZSwgeW91IGNhbiB1c2Uge0BsaW5rIHdpdGhSZXNwb25zZSgpfS5cbiAgICAgKlxuICAgICAqIPCfkYsgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgICAqIFRyeSBzZXR0aW5nIGBcIm1vZHVsZVJlc29sdXRpb25cIjogXCJOb2RlTmV4dFwiYCBvciBhZGQgYFwibGliXCI6IFtcIkRPTVwiXWBcbiAgICAgKiB0byB5b3VyIGB0c2NvbmZpZy5qc29uYC5cbiAgICAgKi9cbiAgICBhc1Jlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZVByb21pc2UudGhlbigocCkgPT4gcC5yZXNwb25zZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcnNlZCByZXNwb25zZSBkYXRhIGFuZCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBJZiB5b3UganVzdCB3YW50IHRvIGdldCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2Ugd2l0aG91dCBwYXJzaW5nIGl0LFxuICAgICAqIHlvdSBjYW4gdXNlIHtAbGluayBhc1Jlc3BvbnNlKCl9LlxuICAgICAqXG4gICAgICog8J+RiyBHZXR0aW5nIHRoZSB3cm9uZyBUeXBlU2NyaXB0IHR5cGUgZm9yIGBSZXNwb25zZWA/XG4gICAgICogVHJ5IHNldHRpbmcgYFwibW9kdWxlUmVzb2x1dGlvblwiOiBcIk5vZGVOZXh0XCJgIG9yIGFkZCBgXCJsaWJcIjogW1wiRE9NXCJdYFxuICAgICAqIHRvIHlvdXIgYHRzY29uZmlnLmpzb25gLlxuICAgICAqL1xuICAgIGFzeW5jIHdpdGhSZXNwb25zZSgpIHtcbiAgICAgICAgY29uc3QgW2RhdGEsIHJlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLnBhcnNlKCksIHRoaXMuYXNSZXNwb25zZSgpXSk7XG4gICAgICAgIHJldHVybiB7IGRhdGEsIHJlc3BvbnNlIH07XG4gICAgfVxuICAgIHBhcnNlKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyc2VkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRQcm9taXNlID0gdGhpcy5yZXNwb25zZVByb21pc2UudGhlbigoZGF0YSkgPT4gdGhpcy5wYXJzZVJlc3BvbnNlKHRoaXMuY2xpZW50LCBkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkUHJvbWlzZTtcbiAgICB9XG4gICAgdGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICAgIH1cbiAgICBjYXRjaChvbnJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKCkuY2F0Y2gob25yZWplY3RlZCk7XG4gICAgfVxuICAgIGZpbmFsbHkob25maW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKCkuZmluYWxseShvbmZpbmFsbHkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmNvbnN0IGJyYW5kX3ByaXZhdGVOdWxsYWJsZUhlYWRlcnMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCdicmFuZC5wcml2YXRlTnVsbGFibGVIZWFkZXJzJyk7XG5mdW5jdGlvbiogaXRlcmF0ZUhlYWRlcnMoaGVhZGVycykge1xuICAgIGlmICghaGVhZGVycylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChicmFuZF9wcml2YXRlTnVsbGFibGVIZWFkZXJzIGluIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZXMsIG51bGxzIH0gPSBoZWFkZXJzO1xuICAgICAgICB5aWVsZCogdmFsdWVzLmVudHJpZXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG51bGxzKSB7XG4gICAgICAgICAgICB5aWVsZCBbbmFtZSwgbnVsbF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkQ2xlYXIgPSBmYWxzZTtcbiAgICBsZXQgaXRlcjtcbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgICAgaXRlciA9IGhlYWRlcnMuZW50cmllcygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlYWRvbmx5QXJyYXkoaGVhZGVycykpIHtcbiAgICAgICAgaXRlciA9IGhlYWRlcnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaG91bGRDbGVhciA9IHRydWU7XG4gICAgICAgIGl0ZXIgPSBPYmplY3QuZW50cmllcyhoZWFkZXJzICE9PSBudWxsICYmIGhlYWRlcnMgIT09IHZvaWQgMCA/IGhlYWRlcnMgOiB7fSk7XG4gICAgfVxuICAgIGZvciAobGV0IHJvdyBvZiBpdGVyKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSByb3dbMF07XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBoZWFkZXIgbmFtZSB0byBiZSBhIHN0cmluZycpO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBpc1JlYWRvbmx5QXJyYXkocm93WzFdKSA/IHJvd1sxXSA6IFtyb3dbMV1dO1xuICAgICAgICBsZXQgZGlkQ2xlYXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gT2JqZWN0cyBrZXlzIGFsd2F5cyBvdmVyd3JpdGUgb2xkZXIgaGVhZGVycywgdGhleSBuZXZlciBhcHBlbmQuXG4gICAgICAgICAgICAvLyBZaWVsZCBhIG51bGwgdG8gY2xlYXIgdGhlIGhlYWRlciBiZWZvcmUgYWRkaW5nIHRoZSBuZXcgdmFsdWVzLlxuICAgICAgICAgICAgaWYgKHNob3VsZENsZWFyICYmICFkaWRDbGVhcikge1xuICAgICAgICAgICAgICAgIGRpZENsZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB5aWVsZCBbbmFtZSwgbnVsbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBbbmFtZSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgYnVpbGRIZWFkZXJzID0gKG5ld0hlYWRlcnMpID0+IHtcbiAgICBjb25zdCB0YXJnZXRIZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBjb25zdCBudWxsSGVhZGVycyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGhlYWRlcnMgb2YgbmV3SGVhZGVycykge1xuICAgICAgICBjb25zdCBzZWVuSGVhZGVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGl0ZXJhdGVIZWFkZXJzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICBjb25zdCBsb3dlck5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIXNlZW5IZWFkZXJzLmhhcyhsb3dlck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SGVhZGVycy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICAgICAgc2VlbkhlYWRlcnMuYWRkKGxvd2VyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRIZWFkZXJzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICBudWxsSGVhZGVycy5hZGQobG93ZXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldEhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBudWxsSGVhZGVycy5kZWxldGUobG93ZXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBbYnJhbmRfcHJpdmF0ZU51bGxhYmxlSGVhZGVyc106IHRydWUsIHZhbHVlczogdGFyZ2V0SGVhZGVycywgbnVsbHM6IG51bGxIZWFkZXJzIH07XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuLyoqXG4gKiBSZWFkIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICpcbiAqIFRyaW1zIGJlZ2lubmluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAqXG4gKiBXaWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGRvZXNuJ3QgZXhpc3Qgb3IgY2Fubm90IGJlIGFjY2Vzc2VkLlxuICovXG5jb25zdCByZWFkRW52ID0gKGVudikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gZ2xvYmFsVGhpcy5wcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Vudl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50cmltKCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLkRlbm8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAoX2YgPSAoX2UgPSAoX2QgPSBnbG9iYWxUaGlzLkRlbm8uZW52KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZ2V0KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCwgZW52KSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfYTtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgR2VtaW5pIE5leHQgR2VuIEFQSSBBUEkgY2xpZW50cy5cbiAqL1xuY2xhc3MgQmFzZUdlbWluaU5leHRHZW5BUElDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIEdlbWluaSBOZXh0IEdlbiBBUEkgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5hcGlLZXk9cHJvY2Vzcy5lbnZbJ0dFTUlOSV9BUElfS0VZJ10gPz8gbnVsbF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW29wdHMuYXBpVmVyc2lvbj12MWJldGFdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhc2VVUkw9cHJvY2Vzcy5lbnZbJ0dFTUlOSV9ORVhUX0dFTl9BUElfQkFTRV9VUkwnXSA/PyBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbV0gLSBPdmVycmlkZSB0aGUgZGVmYXVsdCBiYXNlIFVSTCBmb3IgdGhlIEFQSS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dD0xIG1pbnV0ZV0gLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0aGUgY2xpZW50IHdpbGwgd2FpdCBmb3IgYSByZXNwb25zZSBiZWZvcmUgdGltaW5nIG91dC5cbiAgICAgKiBAcGFyYW0ge01lcmdlZFJlcXVlc3RJbml0fSBbb3B0cy5mZXRjaE9wdGlvbnNdIC0gQWRkaXRpb25hbCBgUmVxdWVzdEluaXRgIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIGBmZXRjaGAgY2FsbHMuXG4gICAgICogQHBhcmFtIHtGZXRjaH0gW29wdHMuZmV0Y2hdIC0gU3BlY2lmeSBhIGN1c3RvbSBgZmV0Y2hgIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5tYXhSZXRyaWVzPTJdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoZSBjbGllbnQgd2lsbCByZXRyeSBhIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtIZWFkZXJzTGlrZX0gb3B0cy5kZWZhdWx0SGVhZGVycyAtIERlZmF1bHQgaGVhZGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPn0gb3B0cy5kZWZhdWx0UXVlcnkgLSBEZWZhdWx0IHF1ZXJ5IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfYikge1xuICAgICAgICB2YXIgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIHZhciB7IGJhc2VVUkwgPSByZWFkRW52KCdHRU1JTklfTkVYVF9HRU5fQVBJX0JBU0VfVVJMJyksIGFwaUtleSA9IChfYyA9IHJlYWRFbnYoJ0dFTUlOSV9BUElfS0VZJykpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsIGFwaVZlcnNpb24gPSAndjFiZXRhJyB9ID0gX2IsIG9wdHMgPSBfX3Jlc3QoX2IsIFtcImJhc2VVUkxcIiwgXCJhcGlLZXlcIiwgXCJhcGlWZXJzaW9uXCJdKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGFwaUtleSxcbiAgICAgICAgICAgIGFwaVZlcnNpb24gfSwgb3B0cyksIHsgYmFzZVVSTDogYmFzZVVSTCB8fCBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb21gIH0pO1xuICAgICAgICB0aGlzLmJhc2VVUkwgPSBvcHRpb25zLmJhc2VVUkw7XG4gICAgICAgIHRoaXMudGltZW91dCA9IChfZCA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogQmFzZUdlbWluaU5leHRHZW5BUElDbGllbnQuREVGQVVMVF9USU1FT1VUIC8qIDEgbWludXRlICovO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IChfZSA9IG9wdGlvbnMubG9nZ2VyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBjb25zb2xlO1xuICAgICAgICBjb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSAnd2Fybic7XG4gICAgICAgIC8vIFNldCBkZWZhdWx0IGxvZ0xldmVsIGVhcmx5IHNvIHRoYXQgd2UgY2FuIGxvZyBhIHdhcm5pbmcgaW4gcGFyc2VMb2dMZXZlbC5cbiAgICAgICAgdGhpcy5sb2dMZXZlbCA9IGRlZmF1bHRMb2dMZXZlbDtcbiAgICAgICAgdGhpcy5sb2dMZXZlbCA9XG4gICAgICAgICAgICAoX2cgPSAoX2YgPSBwYXJzZUxvZ0xldmVsKG9wdGlvbnMubG9nTGV2ZWwsICdDbGllbnRPcHRpb25zLmxvZ0xldmVsJywgdGhpcykpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHBhcnNlTG9nTGV2ZWwocmVhZEVudignR0VNSU5JX05FWFRfR0VOX0FQSV9MT0cnKSwgXCJwcm9jZXNzLmVudlsnR0VNSU5JX05FWFRfR0VOX0FQSV9MT0cnXVwiLCB0aGlzKSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogZGVmYXVsdExvZ0xldmVsO1xuICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IG9wdGlvbnMuZmV0Y2hPcHRpb25zO1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSAoX2ggPSBvcHRpb25zLm1heFJldHJpZXMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IDI7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSAoX2ogPSBvcHRpb25zLmZldGNoKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBnZXREZWZhdWx0RmV0Y2goKTtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gRmFsbGJhY2tFbmNvZGVyO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgICAgIHRoaXMuYXBpVmVyc2lvbiA9IGFwaVZlcnNpb247XG4gICAgICAgIHRoaXMuY2xpZW50QWRhcHRlciA9IG9wdGlvbnMuY2xpZW50QWRhcHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBpbnN0YW5jZSByZS11c2luZyB0aGUgc2FtZSBvcHRpb25zIGdpdmVuIHRvIHRoZSBjdXJyZW50IGNsaWVudCB3aXRoIG9wdGlvbmFsIG92ZXJyaWRpbmcuXG4gICAgICovXG4gICAgd2l0aE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fb3B0aW9ucyksIHsgYmFzZVVSTDogdGhpcy5iYXNlVVJMLCBtYXhSZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsIHRpbWVvdXQ6IHRoaXMudGltZW91dCwgbG9nZ2VyOiB0aGlzLmxvZ2dlciwgbG9nTGV2ZWw6IHRoaXMubG9nTGV2ZWwsIGZldGNoOiB0aGlzLmZldGNoLCBmZXRjaE9wdGlvbnM6IHRoaXMuZmV0Y2hPcHRpb25zLCBhcGlLZXk6IHRoaXMuYXBpS2V5LCBhcGlWZXJzaW9uOiB0aGlzLmFwaVZlcnNpb24gfSksIG9wdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgYmFzZSBVUkwgaXMgc2V0IHRvIGl0cyBkZWZhdWx0LlxuICAgICAqL1xuICAgIGJhc2VVUkxPdmVycmlkZGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlVVJMICE9PSAnaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20nO1xuICAgIH1cbiAgICBkZWZhdWx0UXVlcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmRlZmF1bHRRdWVyeTtcbiAgICB9XG4gICAgdmFsaWRhdGVIZWFkZXJzKHsgdmFsdWVzLCBudWxscyB9KSB7XG4gICAgICAgIC8vIFRoZSBoZWFkZXJzIG9iamVjdCBoYW5kbGVzIGNhc2UgaW5zZW5zaXRpdml0eS5cbiAgICAgICAgaWYgKHZhbHVlcy5oYXMoJ2F1dGhvcml6YXRpb24nKSB8fCB2YWx1ZXMuaGFzKCd4LWdvb2ctYXBpLWtleScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5ICYmIHZhbHVlcy5nZXQoJ3gtZ29vZy1hcGkta2V5JykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbHMuaGFzKCd4LWdvb2ctYXBpLWtleScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVzb2x2ZSBhdXRoZW50aWNhdGlvbiBtZXRob2QuIEV4cGVjdGVkIHRoZSBhcGlLZXkgdG8gYmUgc2V0LiBPciBmb3IgdGhlIFwieC1nb29nLWFwaS1rZXlcIiBoZWFkZXJzIHRvIGJlIGV4cGxpY2l0bHkgb21pdHRlZCcpO1xuICAgIH1cbiAgICBhc3luYyBhdXRoSGVhZGVycyhvcHRzKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhZGVycyA9IGJ1aWxkSGVhZGVycyhbb3B0cy5oZWFkZXJzXSk7XG4gICAgICAgIGlmIChleGlzdGluZ0hlYWRlcnMudmFsdWVzLmhhcygnYXV0aG9yaXphdGlvbicpIHx8IGV4aXN0aW5nSGVhZGVycy52YWx1ZXMuaGFzKCd4LWdvb2ctYXBpLWtleScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVycyhbeyAneC1nb29nLWFwaS1rZXknOiB0aGlzLmFwaUtleSB9XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xpZW50QWRhcHRlci5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBidWlsZEhlYWRlcnMoW2F3YWl0IHRoaXMuY2xpZW50QWRhcHRlci5nZXRBdXRoSGVhZGVycygpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzaWMgcmUtaW1wbGVtZW50YXRpb24gb2YgYHFzLnN0cmluZ2lmeWAgZm9yIHByaW1pdGl2ZSB0eXBlcy5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlRdWVyeShxdWVyeSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocXVlcnkpXG4gICAgICAgICAgICAuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50RXJyb3IoYENhbm5vdCBzdHJpbmdpZnkgdHlwZSAke3R5cGVvZiB2YWx1ZX07IEV4cGVjdGVkIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsLiBJZiB5b3UgbmVlZCB0byBwYXNzIG5lc3RlZCBxdWVyeSBwYXJhbWV0ZXJzLCB5b3UgY2FuIG1hbnVhbGx5IGVuY29kZSB0aGVtLCBlLmcuIHsgcXVlcnk6IHsgJ2Zvb1trZXkxXSc6IHZhbHVlMSwgJ2Zvb1trZXkyXSc6IHZhbHVlMiB9IH0sIGFuZCBwbGVhc2Ugb3BlbiBhIEdpdEh1YiBpc3N1ZSByZXF1ZXN0aW5nIGJldHRlciBzdXBwb3J0IGZvciB5b3VyIHVzZSBjYXNlLmApO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJyYnKTtcbiAgICB9XG4gICAgZ2V0VXNlckFnZW50KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS9KUyAke1ZFUlNJT059YDtcbiAgICB9XG4gICAgZGVmYXVsdElkZW1wb3RlbmN5S2V5KCkge1xuICAgICAgICByZXR1cm4gYHN0YWlubGVzcy1ub2RlLXJldHJ5LSR7dXVpZDQoKX1gO1xuICAgIH1cbiAgICBtYWtlU3RhdHVzRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycykge1xuICAgICAgICByZXR1cm4gQVBJRXJyb3IuZ2VuZXJhdGUoc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuICAgIGJ1aWxkVVJMKHBhdGgsIHF1ZXJ5LCBkZWZhdWx0QmFzZVVSTCkge1xuICAgICAgICBjb25zdCBiYXNlVVJMID0gKCF0aGlzLmJhc2VVUkxPdmVycmlkZGVuKCkgJiYgZGVmYXVsdEJhc2VVUkwpIHx8IHRoaXMuYmFzZVVSTDtcbiAgICAgICAgY29uc3QgdXJsID0gaXNBYnNvbHV0ZVVSTChwYXRoKSA/XG4gICAgICAgICAgICBuZXcgVVJMKHBhdGgpXG4gICAgICAgICAgICA6IG5ldyBVUkwoYmFzZVVSTCArIChiYXNlVVJMLmVuZHNXaXRoKCcvJykgJiYgcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aCkpO1xuICAgICAgICBjb25zdCBkZWZhdWx0UXVlcnkgPSB0aGlzLmRlZmF1bHRRdWVyeSgpO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmooZGVmYXVsdFF1ZXJ5KSkge1xuICAgICAgICAgICAgcXVlcnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRRdWVyeSksIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiBxdWVyeSAmJiAhQXJyYXkuaXNBcnJheShxdWVyeSkpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2ggPSB0aGlzLnN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgYXMgYSBjYWxsYmFjayBmb3IgbXV0YXRpbmcgdGhlIGdpdmVuIGBGaW5hbFJlcXVlc3RPcHRpb25zYCBvYmplY3QuXG4gIFxuICAgICAqL1xuICAgIGFzeW5jIHByZXBhcmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50QWRhcHRlciAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRBZGFwdGVyLmlzVmVydGV4QUkoKSAmJlxuICAgICAgICAgICAgIW9wdGlvbnMucGF0aC5zdGFydHNXaXRoKGAvJHt0aGlzLmFwaVZlcnNpb259L3Byb2plY3RzL2ApKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRQYXRoID0gb3B0aW9ucy5wYXRoLnNsaWNlKHRoaXMuYXBpVmVyc2lvbi5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIG9wdGlvbnMucGF0aCA9IGAvJHt0aGlzLmFwaVZlcnNpb259L3Byb2plY3RzLyR7dGhpcy5jbGllbnRBZGFwdGVyLmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7dGhpcy5jbGllbnRBZGFwdGVyLmdldExvY2F0aW9uKCl9JHtvbGRQYXRofWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBhcyBhIGNhbGxiYWNrIGZvciBtdXRhdGluZyB0aGUgZ2l2ZW4gYFJlcXVlc3RJbml0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91IHdhbnQgdG8gYWRkIGNlcnRhaW4gaGVhZGVycyBiYXNlZCBvZmYgb2ZcbiAgICAgKiB0aGUgcmVxdWVzdCBwcm9wZXJ0aWVzLCBlLmcuIGBtZXRob2RgIG9yIGB1cmxgLlxuICAgICAqL1xuICAgIGFzeW5jIHByZXBhcmVSZXF1ZXN0KHJlcXVlc3QsIHsgdXJsLCBvcHRpb25zIH0pIHsgfVxuICAgIGdldChwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ2dldCcsIHBhdGgsIG9wdHMpO1xuICAgIH1cbiAgICBwb3N0KHBhdGgsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgncG9zdCcsIHBhdGgsIG9wdHMpO1xuICAgIH1cbiAgICBwYXRjaChwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3BhdGNoJywgcGF0aCwgb3B0cyk7XG4gICAgfVxuICAgIHB1dChwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3B1dCcsIHBhdGgsIG9wdHMpO1xuICAgIH1cbiAgICBkZWxldGUocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdkZWxldGUnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgbWV0aG9kUmVxdWVzdChtZXRob2QsIHBhdGgsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChQcm9taXNlLnJlc29sdmUob3B0cykudGhlbigob3B0cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBtZXRob2QsIHBhdGggfSwgb3B0cyk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVxdWVzdChvcHRpb25zLCByZW1haW5pbmdSZXRyaWVzID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IEFQSVByb21pc2UodGhpcywgdGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCByZW1haW5pbmdSZXRyaWVzLCB1bmRlZmluZWQpKTtcbiAgICB9XG4gICAgYXN5bmMgbWFrZVJlcXVlc3Qob3B0aW9uc0lucHV0LCByZXRyaWVzUmVtYWluaW5nLCByZXRyeU9mUmVxdWVzdExvZ0lEKSB7XG4gICAgICAgIHZhciBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgb3B0aW9uc0lucHV0O1xuICAgICAgICBjb25zdCBtYXhSZXRyaWVzID0gKF9iID0gb3B0aW9ucy5tYXhSZXRyaWVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLm1heFJldHJpZXM7XG4gICAgICAgIGlmIChyZXRyaWVzUmVtYWluaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHJpZXNSZW1haW5pbmcgPSBtYXhSZXRyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgcmVxLCB1cmwsIHRpbWVvdXQgfSA9IGF3YWl0IHRoaXMuYnVpbGRSZXF1ZXN0KG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHJldHJ5Q291bnQ6IG1heFJldHJpZXMgLSByZXRyaWVzUmVtYWluaW5nLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5wcmVwYXJlUmVxdWVzdChyZXEsIHsgdXJsLCBvcHRpb25zIH0pO1xuICAgICAgICAvKiogTm90IGFuIEFQSSByZXF1ZXN0IElELCBqdXN0IGZvciBjb3JyZWxhdGluZyBsb2NhbCBsb2cgZW50cmllcy4gKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdExvZ0lEID0gJ2xvZ18nICsgKChNYXRoLnJhbmRvbSgpICogKDEgPDwgMjQpKSB8IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2LCAnMCcpO1xuICAgICAgICBjb25zdCByZXRyeUxvZ1N0ciA9IHJldHJ5T2ZSZXF1ZXN0TG9nSUQgPT09IHVuZGVmaW5lZCA/ICcnIDogYCwgcmV0cnlPZjogJHtyZXRyeU9mUmVxdWVzdExvZ0lEfWA7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGxvZ2dlckZvcih0aGlzKS5kZWJ1ZyhgWyR7cmVxdWVzdExvZ0lEfV0gc2VuZGluZyByZXF1ZXN0YCwgZm9ybWF0UmVxdWVzdERldGFpbHMoe1xuICAgICAgICAgICAgcmV0cnlPZlJlcXVlc3RMb2dJRCxcbiAgICAgICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogcmVxLmhlYWRlcnMsXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKChfYyA9IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aFRpbWVvdXQodXJsLCByZXEsIHRpbWVvdXQsIGNvbnRyb2xsZXIpLmNhdGNoKGNhc3RUb0Vycm9yKTtcbiAgICAgICAgY29uc3QgaGVhZGVyc1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCByZXRyeU1lc3NhZ2UgPSBgcmV0cnlpbmcsICR7cmV0cmllc1JlbWFpbmluZ30gYXR0ZW1wdHMgcmVtYWluaW5nYDtcbiAgICAgICAgICAgIGlmICgoX2QgPSBvcHRpb25zLnNpZ25hbCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRldGVjdCBuYXRpdmUgY29ubmVjdGlvbiB0aW1lb3V0IGVycm9yc1xuICAgICAgICAgICAgLy8gZGVubyB0aHJvd3MgXCJUeXBlRXJyb3I6IGVycm9yIHNlbmRpbmcgcmVxdWVzdCBmb3IgdXJsIChodHRwczovL2V4YW1wbGUvKTogY2xpZW50IGVycm9yIChDb25uZWN0KTogdGNwIGNvbm5lY3QgZXJyb3I6IE9wZXJhdGlvbiB0aW1lZCBvdXQgKG9zIGVycm9yIDYwKTogT3BlcmF0aW9uIHRpbWVkIG91dCAob3MgZXJyb3IgNjApXCJcbiAgICAgICAgICAgIC8vIHVuZGljaSB0aHJvd3MgXCJUeXBlRXJyb3I6IGZldGNoIGZhaWxlZFwiIHdpdGggY2F1c2UgXCJDb25uZWN0VGltZW91dEVycm9yOiBDb25uZWN0IFRpbWVvdXQgRXJyb3IgKGF0dGVtcHRlZCBhZGRyZXNzOiBleGFtcGxlOjQ0MywgdGltZW91dDogMW1zKVwiXG4gICAgICAgICAgICAvLyBvdGhlcnMgZG8gbm90IHByb3ZpZGUgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGRpc3Rpbmd1aXNoIHRpbWVvdXRzIGZyb20gb3RoZXIgY29ubmVjdGlvbiBlcnJvcnNcbiAgICAgICAgICAgIGNvbnN0IGlzVGltZW91dCA9IGlzQWJvcnRFcnJvcihyZXNwb25zZSkgfHxcbiAgICAgICAgICAgICAgICAvdGltZWQ/ID9vdXQvaS50ZXN0KFN0cmluZyhyZXNwb25zZSkgKyAoJ2NhdXNlJyBpbiByZXNwb25zZSA/IFN0cmluZyhyZXNwb25zZS5jYXVzZSkgOiAnJykpO1xuICAgICAgICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJGb3IodGhpcykuaW5mbyhgWyR7cmVxdWVzdExvZ0lEfV0gY29ubmVjdGlvbiAke2lzVGltZW91dCA/ICd0aW1lZCBvdXQnIDogJ2ZhaWxlZCd9IC0gJHtyZXRyeU1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmRlYnVnKGBbJHtyZXF1ZXN0TG9nSUR9XSBjb25uZWN0aW9uICR7aXNUaW1lb3V0ID8gJ3RpbWVkIG91dCcgOiAnZmFpbGVkJ30gKCR7cmV0cnlNZXNzYWdlfSlgLCBmb3JtYXRSZXF1ZXN0RGV0YWlscyh7XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5T2ZSZXF1ZXN0TG9nSUQsXG4gICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25NczogaGVhZGVyc1RpbWUgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nLCByZXRyeU9mUmVxdWVzdExvZ0lEICE9PSBudWxsICYmIHJldHJ5T2ZSZXF1ZXN0TG9nSUQgIT09IHZvaWQgMCA/IHJldHJ5T2ZSZXF1ZXN0TG9nSUQgOiByZXF1ZXN0TG9nSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmluZm8oYFske3JlcXVlc3RMb2dJRH1dIGNvbm5lY3Rpb24gJHtpc1RpbWVvdXQgPyAndGltZWQgb3V0JyA6ICdmYWlsZWQnfSAtIGVycm9yOyBubyBtb3JlIHJldHJpZXMgbGVmdGApO1xuICAgICAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmRlYnVnKGBbJHtyZXF1ZXN0TG9nSUR9XSBjb25uZWN0aW9uICR7aXNUaW1lb3V0ID8gJ3RpbWVkIG91dCcgOiAnZmFpbGVkJ30gKGVycm9yOyBubyBtb3JlIHJldHJpZXMgbGVmdClgLCBmb3JtYXRSZXF1ZXN0RGV0YWlscyh7XG4gICAgICAgICAgICAgICAgcmV0cnlPZlJlcXVlc3RMb2dJRCxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgZHVyYXRpb25NczogaGVhZGVyc1RpbWUgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzcG9uc2UubWVzc2FnZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChpc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiByZXNwb25zZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZUluZm8gPSBgWyR7cmVxdWVzdExvZ0lEfSR7cmV0cnlMb2dTdHJ9XSAke3JlcS5tZXRob2R9ICR7dXJsfSAke3Jlc3BvbnNlLm9rID8gJ3N1Y2NlZWRlZCcgOiAnZmFpbGVkJ30gd2l0aCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9IGluICR7aGVhZGVyc1RpbWUgLSBzdGFydFRpbWV9bXNgO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZXRyeSA9IGF3YWl0IHRoaXMuc2hvdWxkUmV0cnkocmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcgJiYgc2hvdWxkUmV0cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeU1lc3NhZ2UgPSBgcmV0cnlpbmcsICR7cmV0cmllc1JlbWFpbmluZ30gYXR0ZW1wdHMgcmVtYWluaW5nYDtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRoZSBib2R5IG9mIHRoaXMgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgYXdhaXQgQ2FuY2VsUmVhZGFibGVTdHJlYW0ocmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmluZm8oYCR7cmVzcG9uc2VJbmZvfSAtICR7cmV0cnlNZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIGxvZ2dlckZvcih0aGlzKS5kZWJ1ZyhgWyR7cmVxdWVzdExvZ0lEfV0gcmVzcG9uc2UgZXJyb3IgKCR7cmV0cnlNZXNzYWdlfSlgLCBmb3JtYXRSZXF1ZXN0RGV0YWlscyh7XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5T2ZSZXF1ZXN0TG9nSUQsXG4gICAgICAgICAgICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25NczogaGVhZGVyc1RpbWUgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nLCByZXRyeU9mUmVxdWVzdExvZ0lEICE9PSBudWxsICYmIHJldHJ5T2ZSZXF1ZXN0TG9nSUQgIT09IHZvaWQgMCA/IHJldHJ5T2ZSZXF1ZXN0TG9nSUQgOiByZXF1ZXN0TG9nSUQsIHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmV0cnlNZXNzYWdlID0gc2hvdWxkUmV0cnkgPyBgZXJyb3I7IG5vIG1vcmUgcmV0cmllcyBsZWZ0YCA6IGBlcnJvcjsgbm90IHJldHJ5YWJsZWA7XG4gICAgICAgICAgICBsb2dnZXJGb3IodGhpcykuaW5mbyhgJHtyZXNwb25zZUluZm99IC0gJHtyZXRyeU1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBjb25zdCBlcnJUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKChlcnIpID0+IGNhc3RUb0Vycm9yKGVycikubWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zdCBlcnJKU09OID0gc2FmZUpTT04oZXJyVGV4dCk7XG4gICAgICAgICAgICBjb25zdCBlcnJNZXNzYWdlID0gZXJySlNPTiA/IHVuZGVmaW5lZCA6IGVyclRleHQ7XG4gICAgICAgICAgICBsb2dnZXJGb3IodGhpcykuZGVidWcoYFske3JlcXVlc3RMb2dJRH1dIHJlc3BvbnNlIGVycm9yICgke3JldHJ5TWVzc2FnZX0pYCwgZm9ybWF0UmVxdWVzdERldGFpbHMoe1xuICAgICAgICAgICAgICAgIHJldHJ5T2ZSZXF1ZXN0TG9nSUQsXG4gICAgICAgICAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNZXNzYWdlLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uTXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLm1ha2VTdGF0dXNFcnJvcihyZXNwb25zZS5zdGF0dXMsIGVyckpTT04sIGVyck1lc3NhZ2UsIHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlckZvcih0aGlzKS5pbmZvKHJlc3BvbnNlSW5mbyk7XG4gICAgICAgIGxvZ2dlckZvcih0aGlzKS5kZWJ1ZyhgWyR7cmVxdWVzdExvZ0lEfV0gcmVzcG9uc2Ugc3RhcnRgLCBmb3JtYXRSZXF1ZXN0RGV0YWlscyh7XG4gICAgICAgICAgICByZXRyeU9mUmVxdWVzdExvZ0lELFxuICAgICAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICBkdXJhdGlvbk1zOiBoZWFkZXJzVGltZSAtIHN0YXJ0VGltZSxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4geyByZXNwb25zZSwgb3B0aW9ucywgY29udHJvbGxlciwgcmVxdWVzdExvZ0lELCByZXRyeU9mUmVxdWVzdExvZ0lELCBzdGFydFRpbWUgfTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hXaXRoVGltZW91dCh1cmwsIGluaXQsIG1zLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IF9iID0gaW5pdCB8fCB7fSwgeyBzaWduYWwsIG1ldGhvZCB9ID0gX2IsIG9wdGlvbnMgPSBfX3Jlc3QoX2IsIFtcInNpZ25hbFwiLCBcIm1ldGhvZFwiXSk7XG4gICAgICAgIGlmIChzaWduYWwpXG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBjb250cm9sbGVyLmFib3J0KCkpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIG1zKTtcbiAgICAgICAgY29uc3QgaXNSZWFkYWJsZUJvZHkgPSAoZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSAmJiBvcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvcHRpb25zLmJvZHkgPT09ICdvYmplY3QnICYmIG9wdGlvbnMuYm9keSAhPT0gbnVsbCAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiBvcHRpb25zLmJvZHkpO1xuICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHNpZ25hbDogY29udHJvbGxlci5zaWduYWwgfSwgKGlzUmVhZGFibGVCb2R5ID8geyBkdXBsZXg6ICdoYWxmJyB9IDoge30pKSwgeyBtZXRob2Q6ICdHRVQnIH0pLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgLy8gQ3VzdG9tIG1ldGhvZHMgbGlrZSAncGF0Y2gnIG5lZWQgdG8gYmUgdXBwZXJjYXNlZFxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMjk0XG4gICAgICAgICAgICBmZXRjaE9wdGlvbnMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHVzZSB1bmRlZmluZWQgdGhpcyBiaW5kaW5nOyBmZXRjaCBlcnJvcnMgaWYgYm91bmQgdG8gc29tZXRoaW5nIGVsc2UgaW4gYnJvd3Nlci9jbG91ZGZsYXJlXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaC5jYWxsKHVuZGVmaW5lZCwgdXJsLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNob3VsZFJldHJ5KHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBpcyBub3QgYSBzdGFuZGFyZCBoZWFkZXIuXG4gICAgICAgIGNvbnN0IHNob3VsZFJldHJ5SGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtc2hvdWxkLXJldHJ5Jyk7XG4gICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgZXhwbGljaXRseSBzYXlzIHdoZXRoZXIgb3Igbm90IHRvIHJldHJ5LCBvYmV5LlxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICd0cnVlJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICdmYWxzZScpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFJldHJ5IG9uIHJlcXVlc3QgdGltZW91dHMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBSZXRyeSBvbiBsb2NrIHRpbWVvdXRzLlxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gUmV0cnkgb24gcmF0ZSBsaW1pdHMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBSZXRyeSBpbnRlcm5hbCBlcnJvcnMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgcmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcsIHJlcXVlc3RMb2dJRCwgcmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgbGV0IHRpbWVvdXRNaWxsaXM7XG4gICAgICAgIC8vIE5vdGUgdGhlIGByZXRyeS1hZnRlci1tc2AgaGVhZGVyIG1heSBub3QgYmUgc3RhbmRhcmQsIGJ1dCBpcyBhIGdvb2QgaWRlYSBhbmQgd2UnZCBsaWtlIHByb2FjdGl2ZSBzdXBwb3J0IGZvciBpdC5cbiAgICAgICAgY29uc3QgcmV0cnlBZnRlck1pbGxpc0hlYWRlciA9IHJlc3BvbnNlSGVhZGVycyA9PT0gbnVsbCB8fCByZXNwb25zZUhlYWRlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlSGVhZGVycy5nZXQoJ3JldHJ5LWFmdGVyLW1zJyk7XG4gICAgICAgIGlmIChyZXRyeUFmdGVyTWlsbGlzSGVhZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0TXMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dE1zKSkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aW1lb3V0TXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWJvdXQgdGhlIFJldHJ5LUFmdGVyIGhlYWRlcjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1JldHJ5LUFmdGVyXG4gICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXJIZWFkZXIgPSByZXNwb25zZUhlYWRlcnMgPT09IG51bGwgfHwgcmVzcG9uc2VIZWFkZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZUhlYWRlcnMuZ2V0KCdyZXRyeS1hZnRlcicpO1xuICAgICAgICBpZiAocmV0cnlBZnRlckhlYWRlciAmJiAhdGltZW91dE1pbGxpcykge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dFNlY29uZHMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXJIZWFkZXIpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dFNlY29uZHMpKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dE1pbGxpcyA9IHRpbWVvdXRTZWNvbmRzICogMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRNaWxsaXMgPSBEYXRlLnBhcnNlKHJldHJ5QWZ0ZXJIZWFkZXIpIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgQVBJIGFza3MgdXMgdG8gd2FpdCBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUgKGFuZCBpdCdzIGEgcmVhc29uYWJsZSBhbW91bnQpLFxuICAgICAgICAvLyBqdXN0IGRvIHdoYXQgaXQgc2F5cywgYnV0IG90aGVyd2lzZSBjYWxjdWxhdGUgYSBkZWZhdWx0XG4gICAgICAgIGlmICghKHRpbWVvdXRNaWxsaXMgJiYgMCA8PSB0aW1lb3V0TWlsbGlzICYmIHRpbWVvdXRNaWxsaXMgPCA2MCAqIDEwMDApKSB7XG4gICAgICAgICAgICBjb25zdCBtYXhSZXRyaWVzID0gKF9iID0gb3B0aW9ucy5tYXhSZXRyaWVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLm1heFJldHJpZXM7XG4gICAgICAgICAgICB0aW1lb3V0TWlsbGlzID0gdGhpcy5jYWxjdWxhdGVEZWZhdWx0UmV0cnlUaW1lb3V0TWlsbGlzKHJldHJpZXNSZW1haW5pbmcsIG1heFJldHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNsZWVwJDEodGltZW91dE1pbGxpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcgLSAxLCByZXF1ZXN0TG9nSUQpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVEZWZhdWx0UmV0cnlUaW1lb3V0TWlsbGlzKHJldHJpZXNSZW1haW5pbmcsIG1heFJldHJpZXMpIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbFJldHJ5RGVsYXkgPSAwLjU7XG4gICAgICAgIGNvbnN0IG1heFJldHJ5RGVsYXkgPSA4LjA7XG4gICAgICAgIGNvbnN0IG51bVJldHJpZXMgPSBtYXhSZXRyaWVzIC0gcmV0cmllc1JlbWFpbmluZztcbiAgICAgICAgLy8gQXBwbHkgZXhwb25lbnRpYWwgYmFja29mZiwgYnV0IG5vdCBtb3JlIHRoYW4gdGhlIG1heC5cbiAgICAgICAgY29uc3Qgc2xlZXBTZWNvbmRzID0gTWF0aC5taW4oaW5pdGlhbFJldHJ5RGVsYXkgKiBNYXRoLnBvdygyLCBudW1SZXRyaWVzKSwgbWF4UmV0cnlEZWxheSk7XG4gICAgICAgIC8vIEFwcGx5IHNvbWUgaml0dGVyLCB0YWtlIHVwIHRvIGF0IG1vc3QgMjUgcGVyY2VudCBvZiB0aGUgcmV0cnkgdGltZS5cbiAgICAgICAgY29uc3Qgaml0dGVyID0gMSAtIE1hdGgucmFuZG9tKCkgKiAwLjI1O1xuICAgICAgICByZXR1cm4gc2xlZXBTZWNvbmRzICogaml0dGVyICogMTAwMDtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRSZXF1ZXN0KGlucHV0T3B0aW9ucywgeyByZXRyeUNvdW50ID0gMCB9ID0ge30pIHtcbiAgICAgICAgdmFyIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbnB1dE9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCwgcXVlcnksIGRlZmF1bHRCYXNlVVJMIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVVJMKHBhdGgsIHF1ZXJ5LCBkZWZhdWx0QmFzZVVSTCk7XG4gICAgICAgIGlmICgndGltZW91dCcgaW4gb3B0aW9ucylcbiAgICAgICAgICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKCd0aW1lb3V0Jywgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgb3B0aW9ucy50aW1lb3V0ID0gKF9iID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IHsgYm9keUhlYWRlcnMsIGJvZHkgfSA9IHRoaXMuYnVpbGRCb2R5KHsgb3B0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgcmVxSGVhZGVycyA9IGF3YWl0IHRoaXMuYnVpbGRIZWFkZXJzKHsgb3B0aW9uczogaW5wdXRPcHRpb25zLCBtZXRob2QsIGJvZHlIZWFkZXJzLCByZXRyeUNvdW50IH0pO1xuICAgICAgICBjb25zdCByZXEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2QsIGhlYWRlcnM6IHJlcUhlYWRlcnMgfSwgKG9wdGlvbnMuc2lnbmFsICYmIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9KSksIChnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtICYmXG4gICAgICAgICAgICBib2R5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSAmJiB7IGR1cGxleDogJ2hhbGYnIH0pKSwgKGJvZHkgJiYgeyBib2R5IH0pKSwgKChfYyA9IHRoaXMuZmV0Y2hPcHRpb25zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSkpLCAoKF9kID0gb3B0aW9ucy5mZXRjaE9wdGlvbnMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9KSk7XG4gICAgICAgIHJldHVybiB7IHJlcSwgdXJsLCB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgfTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRIZWFkZXJzKHsgb3B0aW9ucywgbWV0aG9kLCBib2R5SGVhZGVycywgcmV0cnlDb3VudCwgfSkge1xuICAgICAgICBsZXQgaWRlbXBvdGVuY3lIZWFkZXJzID0ge307XG4gICAgICAgIGlmICh0aGlzLmlkZW1wb3RlbmN5SGVhZGVyICYmIG1ldGhvZCAhPT0gJ2dldCcpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5pZGVtcG90ZW5jeUtleSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLmlkZW1wb3RlbmN5S2V5ID0gdGhpcy5kZWZhdWx0SWRlbXBvdGVuY3lLZXkoKTtcbiAgICAgICAgICAgIGlkZW1wb3RlbmN5SGVhZGVyc1t0aGlzLmlkZW1wb3RlbmN5SGVhZGVyXSA9IG9wdGlvbnMuaWRlbXBvdGVuY3lLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSBhd2FpdCB0aGlzLmF1dGhIZWFkZXJzKG9wdGlvbnMpO1xuICAgICAgICBsZXQgaGVhZGVycyA9IGJ1aWxkSGVhZGVycyhbXG4gICAgICAgICAgICBpZGVtcG90ZW5jeUhlYWRlcnMsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1VzZXItQWdlbnQnOiB0aGlzLmdldFVzZXJBZ2VudCgpLCAnWC1TdGFpbmxlc3MtUmV0cnktQ291bnQnOiBTdHJpbmcocmV0cnlDb3VudCkgfSwgKG9wdGlvbnMudGltZW91dCA/IHsgJ1gtU3RhaW5sZXNzLVRpbWVvdXQnOiBTdHJpbmcoTWF0aC50cnVuYyhvcHRpb25zLnRpbWVvdXQgLyAxMDAwKSkgfSA6IHt9KSksIGdldFBsYXRmb3JtSGVhZGVycygpKSxcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuZGVmYXVsdEhlYWRlcnMsXG4gICAgICAgICAgICBib2R5SGVhZGVycyxcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIGF1dGhIZWFkZXJzLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzLnZhbHVlcztcbiAgICB9XG4gICAgYnVpbGRCb2R5KHsgb3B0aW9uczogeyBib2R5LCBoZWFkZXJzOiByYXdIZWFkZXJzIH0gfSkge1xuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGJvZHlIZWFkZXJzOiB1bmRlZmluZWQsIGJvZHk6IHVuZGVmaW5lZCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBidWlsZEhlYWRlcnMoW3Jhd0hlYWRlcnNdKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBQYXNzIHJhdyB0eXBlIHZlcmJhdGltXG4gICAgICAgIEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSB8fFxuICAgICAgICAgICAgYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICBib2R5IGluc3RhbmNlb2YgRGF0YVZpZXcgfHxcbiAgICAgICAgICAgICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBsZWdhY3kgc3RyaW5nIGVuY29kaW5nIGJlaGF2aW9yIGZvciBub3dcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnZhbHVlcy5oYXMoJ2NvbnRlbnQtdHlwZScpKSB8fFxuICAgICAgICAgICAgLy8gYEJsb2JgIGlzIHN1cGVyc2V0IG9mIGBGaWxlYFxuICAgICAgICAgICAgKGdsb2JhbFRoaXMuQmxvYiAmJiBib2R5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5CbG9iKSB8fFxuICAgICAgICAgICAgLy8gYEZvcm1EYXRhYCAtPiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YWBcbiAgICAgICAgICAgIGJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fFxuICAgICAgICAgICAgLy8gYFVSTFNlYXJjaFBhcmFtc2AgLT4gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGBcbiAgICAgICAgICAgIGJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgfHxcbiAgICAgICAgICAgIC8vIFNlbmQgY2h1bmtlZCBzdHJlYW0gKGVhY2ggY2h1bmsgaGFzIG93biBgbGVuZ3RoYClcbiAgICAgICAgICAgIChnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtICYmIGJvZHkgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgYm9keUhlYWRlcnM6IHVuZGVmaW5lZCwgYm9keTogYm9keSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIGJvZHkgfHxcbiAgICAgICAgICAgICAgICAoU3ltYm9sLml0ZXJhdG9yIGluIGJvZHkgJiYgJ25leHQnIGluIGJvZHkgJiYgdHlwZW9mIGJvZHkubmV4dCA9PT0gJ2Z1bmN0aW9uJykpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBib2R5SGVhZGVyczogdW5kZWZpbmVkLCBib2R5OiBSZWFkYWJsZVN0cmVhbUZyb20oYm9keSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZXIoeyBib2R5LCBoZWFkZXJzIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuQmFzZUdlbWluaU5leHRHZW5BUElDbGllbnQuREVGQVVMVF9USU1FT1VUID0gNjAwMDA7IC8vIDEgbWludXRlXG4vKipcbiAqIEFQSSBDbGllbnQgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIEdlbWluaSBOZXh0IEdlbiBBUEkgQVBJLlxuICovXG5jbGFzcyBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50IGV4dGVuZHMgQmFzZUdlbWluaU5leHRHZW5BUElDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9ucyA9IG5ldyBJbnRlcmFjdGlvbnModGhpcyk7XG4gICAgfVxufVxuX2EgPSBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50O1xuR2VtaW5pTmV4dEdlbkFQSUNsaWVudC5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50ID0gX2E7XG5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50LkdlbWluaU5leHRHZW5BUElDbGllbnRFcnJvciA9IEdlbWluaU5leHRHZW5BUElDbGllbnRFcnJvcjtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuQVBJRXJyb3IgPSBBUElFcnJvcjtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuQVBJQ29ubmVjdGlvbkVycm9yID0gQVBJQ29ubmVjdGlvbkVycm9yO1xuR2VtaW5pTmV4dEdlbkFQSUNsaWVudC5BUElDb25uZWN0aW9uVGltZW91dEVycm9yID0gQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcjtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuQVBJVXNlckFib3J0RXJyb3IgPSBBUElVc2VyQWJvcnRFcnJvcjtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuTm90Rm91bmRFcnJvciA9IE5vdEZvdW5kRXJyb3I7XG5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50LkNvbmZsaWN0RXJyb3IgPSBDb25mbGljdEVycm9yO1xuR2VtaW5pTmV4dEdlbkFQSUNsaWVudC5SYXRlTGltaXRFcnJvciA9IFJhdGVMaW1pdEVycm9yO1xuR2VtaW5pTmV4dEdlbkFQSUNsaWVudC5CYWRSZXF1ZXN0RXJyb3IgPSBCYWRSZXF1ZXN0RXJyb3I7XG5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50LkF1dGhlbnRpY2F0aW9uRXJyb3IgPSBBdXRoZW50aWNhdGlvbkVycm9yO1xuR2VtaW5pTmV4dEdlbkFQSUNsaWVudC5JbnRlcm5hbFNlcnZlckVycm9yID0gSW50ZXJuYWxTZXJ2ZXJFcnJvcjtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuUGVybWlzc2lvbkRlbmllZEVycm9yID0gUGVybWlzc2lvbkRlbmllZEVycm9yO1xuR2VtaW5pTmV4dEdlbkFQSUNsaWVudC5VbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgPSBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3I7XG5HZW1pbmlOZXh0R2VuQVBJQ2xpZW50LnRvRmlsZSA9IHRvRmlsZTtcbkdlbWluaU5leHRHZW5BUElDbGllbnQuSW50ZXJhY3Rpb25zID0gSW50ZXJhY3Rpb25zO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBHT09HTEVfQVBJX0tFWV9IRUFERVIgPSAneC1nb29nLWFwaS1rZXknO1xuY29uc3QgUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0nO1xuY2xhc3MgTm9kZUF1dGgge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gb3B0cy5hcGlLZXk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVydGV4QXV0aE9wdGlvbnMgPSBidWlsZEdvb2dsZUF1dGhPcHRpb25zKG9wdHMuZ29vZ2xlQXV0aE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdvb2dsZUF1dGggPSBuZXcgR29vZ2xlQXV0aCh2ZXJ0ZXhBdXRoT3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCkge1xuICAgICAgICBpZiAodGhpcy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpS2V5LnN0YXJ0c1dpdGgoJ2F1dGhfdG9rZW5zLycpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcGhlbWVyYWwgdG9rZW5zIGFyZSBvbmx5IHN1cHBvcnRlZCBieSB0aGUgbGl2ZSBBUEkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZEtleUhlYWRlcihoZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGRHb29nbGVBdXRoSGVhZGVycyhoZWFkZXJzLCB1cmwpO1xuICAgIH1cbiAgICBhZGRLZXlIZWFkZXIoaGVhZGVycykge1xuICAgICAgICBpZiAoaGVhZGVycy5nZXQoR09PR0xFX0FQSV9LRVlfSEVBREVSKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIHRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkXG4gICAgICAgICAgICAvLyB3aGVuIGFwaUtleSBpcyBzZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBzZXQgQVBJIGtleSBoZWFkZXIgYnV0IGFwaUtleSBpcyBub3Qgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycy5hcHBlbmQoR09PR0xFX0FQSV9LRVlfSEVBREVSLCB0aGlzLmFwaUtleSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEdvb2dsZUF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCkge1xuICAgICAgICBpZiAodGhpcy5nb29nbGVBdXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYWRkR29vZ2xlQXV0aEhlYWRlcnMgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFwaUtleSBzZXQgYW5kIGluIHRoZXNlIGNhc2VzIGdvb2dsZUF1dGhcbiAgICAgICAgICAgIC8vIGlzIHNldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHNldCBnb29nbGUtYXV0aCBoZWFkZXJzIGJ1dCBnb29nbGVBdXRoIGlzIHVuc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSBhd2FpdCB0aGlzLmdvb2dsZUF1dGguZ2V0UmVxdWVzdEhlYWRlcnModXJsKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXV0aEhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzLmdldChrZXkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkR29vZ2xlQXV0aE9wdGlvbnMoZ29vZ2xlQXV0aE9wdGlvbnMpIHtcbiAgICBsZXQgYXV0aE9wdGlvbnM7XG4gICAgaWYgKCFnb29nbGVBdXRoT3B0aW9ucykge1xuICAgICAgICBhdXRoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNjb3BlczogW1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRV0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF1dGhPcHRpb25zID0gZ29vZ2xlQXV0aE9wdGlvbnM7XG4gICAgICAgIGlmICghYXV0aE9wdGlvbnMuc2NvcGVzKSB7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucy5zY29wZXMgPSBbUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFXTtcbiAgICAgICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodHlwZW9mIGF1dGhPcHRpb25zLnNjb3BlcyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3BlcyAhPT0gUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoYXV0aE9wdGlvbnMuc2NvcGVzKSAmJlxuICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3Blcy5pbmRleE9mKFJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSkgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGF1dGggc2NvcGVzLiBTY29wZXMgbXVzdCBpbmNsdWRlOiAke1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aE9wdGlvbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlRG93bmxvYWRlciB7XG4gICAgYXN5bmMgZG93bmxvYWQocGFyYW1zLCBhcGlDbGllbnQpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5kb3dubG9hZFBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZG93bmxvYWRGaWxlKHBhcmFtcywgYXBpQ2xpZW50KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlciA9IGNyZWF0ZVdyaXRlU3RyZWFtKHBhcmFtcy5kb3dubG9hZFBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBSZWFkYWJsZS5mcm9tV2ViKHJlc3BvbnNlLnJlc3BvbnNlSW50ZXJuYWwuYm9keSk7XG4gICAgICAgICAgICAgICAgYm9keS5waXBlKHdyaXRlcik7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmluaXNoZWQod3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZShwYXJhbXMuZG93bmxvYWRQYXRoLCByZXNwb25zZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHdyaXRlIGZpbGUgdG8gJHtwYXJhbXMuZG93bmxvYWRQYXRofTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUocGFyYW1zLCBhcGlDbGllbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBuYW1lID0gdEZpbGVOYW1lKHBhcmFtcy5maWxlKTtcbiAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoOiBgZmlsZXMvJHtuYW1lfTpkb3dubG9hZGAsXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgJ2FsdCc6ICdtZWRpYScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0dlbmVyYXRlZFZpZGVvKHBhcmFtcy5maWxlKSkge1xuICAgICAgICBjb25zdCB2aWRlb0J5dGVzID0gKF9jID0gcGFyYW1zLmZpbGUudmlkZW8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy52aWRlb0J5dGVzO1xuICAgICAgICBpZiAodHlwZW9mIHZpZGVvQnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlkZW9CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRvd25sb2FkIGdlbmVyYXRlZCB2aWRlbywgVXJpIG9yIHZpZGVvQnl0ZXMgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVmlkZW8ocGFyYW1zLmZpbGUpKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvQnl0ZXMgPSBwYXJhbXMuZmlsZS52aWRlb0J5dGVzO1xuICAgICAgICBpZiAodHlwZW9mIHZpZGVvQnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlkZW9CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRvd25sb2FkIHZpZGVvLCBVcmkgb3IgdmlkZW9CeXRlcyBub3QgZm91bmQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZmlsZSB0eXBlJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlV2ViU29ja2V0RmFjdG9yeSB7XG4gICAgY3JlYXRlKHVybCwgaGVhZGVycywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVdlYlNvY2tldCh1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcyk7XG4gICAgfVxufVxuY2xhc3MgTm9kZVdlYlNvY2tldCB7XG4gICAgY29uc3RydWN0b3IodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLndzID0gbmV3IE5vZGVXcy5XZWJTb2NrZXQodGhpcy51cmwsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9IHRoaXMuY2FsbGJhY2tzLm9ub3BlbjtcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gdGhpcy5jYWxsYmFja3Mub25lcnJvcjtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5jYWxsYmFja3Mub25jbG9zZTtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSB0aGlzLmNhbGxiYWNrcy5vbm1lc3NhZ2U7XG4gICAgfVxuICAgIHNlbmQobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxUdW5pbmdKb2JSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmNlbFR1bmluZ0pvYlJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRpb25EYXRhc2V0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzY3JpcHRpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVwb2NoQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vwb2NoQ291bnQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkYXB0ZXJTaXplJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGFwdGVyU2l6ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXRjaFNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnYmF0Y2hTaXplJ10sIGZyb21CYXRjaFNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsZWFybmluZ1JhdGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlJ10sIGZyb21MZWFybmluZ1JhdGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZXRhJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZXRhIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JWYWxpZGF0aW9uRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAndmFsaWRhdGlvbkRhdGFzZXQnLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WYWxpZGF0aW9uRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnXSwgdHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleChmcm9tVmFsaWRhdGlvbkRhdGFzZXQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbVZhbGlkYXRpb25EYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZhbGlkYXRpb25EYXRhc2V0JyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJ10sIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbVZhbGlkYXRpb25EYXRhc2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuZWRNb2RlbERpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JFcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JFcG9jaENvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckVwb2NoQ291bnQgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21FcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaENvdW50J10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVwb2NoQ291bnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdlcG9jaENvdW50J10sIGZyb21FcG9jaENvdW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnZXBvY2hDb3VudCddLCBmcm9tRXBvY2hDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlTXVsdGlwbGllciddLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAnbGVhcm5pbmdSYXRlTXVsdGlwbGllcicsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbXG4gICAgICAgICAgICAgICAgJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJyxcbiAgICAgICAgICAgICAgICAnaHlwZXJQYXJhbWV0ZXJzJyxcbiAgICAgICAgICAgICAgICAnbGVhcm5pbmdSYXRlTXVsdGlwbGllcicsXG4gICAgICAgICAgICBdLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbJ2NvbmZpZycsICdtZXRob2QnXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckV4cG9ydExhc3RDaGVja3BvaW50T25seSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5JyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknXSwgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckV4cG9ydExhc3RDaGVja3BvaW50T25seSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5J10sIGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yQWRhcHRlclNpemUgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbXG4gICAgICAgICdjb25maWcnLFxuICAgICAgICAnbWV0aG9kJyxcbiAgICBdKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID09PSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUFkYXB0ZXJTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGFwdGVyU2l6ZSddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGFwdGVyU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2FkYXB0ZXJTaXplJ10sIGZyb21BZGFwdGVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID09PSAnUFJFRkVSRU5DRV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21BZGFwdGVyU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRhcHRlclNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdhZGFwdGVyU2l6ZSddLCBmcm9tQWRhcHRlclNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JhdGNoU2l6ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmF0Y2hTaXplIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGVhcm5pbmdSYXRlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZWFybmluZ1JhdGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmV0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmV0YSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJldGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2JldGEnXSwgZnJvbUJldGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhaW5pbmdEYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJhaW5pbmdEYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyYWluaW5nRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgIHR1bmluZ0RhdGFzZXRUb01sZGV2KGZyb21UcmFpbmluZ0RhdGFzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVUdW5pbmdKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb1ZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVUdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlVHVuZWRNb2RlbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVUdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlVHVuZWRNb2RlbCddLCBmcm9tUHJlVHVuZWRNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UcmFpbmluZ0RhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0cmFpbmluZ0RhdGFzZXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHJhaW5pbmdEYXRhc2V0ICE9IG51bGwpIHtcbiAgICAgICAgdHVuaW5nRGF0YXNldFRvVmVydGV4KGZyb21UcmFpbmluZ0RhdGFzZXQsIHRvT2JqZWN0LCByb290T2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QsIHJvb3RPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdFR1bmluZ0pvYnNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdFR1bmluZ0pvYnNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5lZE1vZGVscyddKTtcbiAgICBpZiAoZnJvbVR1bmluZ0pvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVR1bmluZ0pvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmluZ0pvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmluZ0pvYnMnXSk7XG4gICAgaWYgKGZyb21UdW5pbmdKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21UdW5pbmdKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYkZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxGcm9tTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZHBvaW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludCddLCBmcm9tRW5kcG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdEYXRhc2V0VG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVydGV4RGF0YXNldFJlc291cmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4YW1wbGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlcyddKTtcbiAgICBpZiAoZnJvbUV4YW1wbGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FeGFtcGxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhhbXBsZXMnLCAnZXhhbXBsZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nRGF0YXNldFRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbXG4gICAgICAgICdjb25maWcnLFxuICAgICAgICAnbWV0aG9kJyxcbiAgICBdKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvckdjc1VyaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JHY3NVcmkgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yR2NzVXJpID09PSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JHY3NVcmkgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAndmVydGV4RGF0YXNldFJlc291cmNlJyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZlcnRleERhdGFzZXRSZXNvdXJjZScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4YW1wbGVzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGFtcGxlcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0pvYkZyb21NbGRldihmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRUdW5pbmdKb2JTdGF0dXMoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuaW5nVGFzaycsXG4gICAgICAgICdzdGFydFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ1Rhc2snLFxuICAgICAgICAnY29tcGxldGVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSwgdHVuZWRNb2RlbEZyb21NbGRldihmcm9tVHVuZWRNb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdKb2JGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRUdW5pbmdKb2JTdGF0dXMoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVuZWRNb2RlbCddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsJ10sIGZyb21UdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVUdW5lZE1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVUdW5lZE1vZGVsJ10sIGZyb21QcmVUdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYyddLCBmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJ10sIGZyb21QcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdEYXRhU3RhdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5pbmdEYXRhU3RhdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuaW5nRGF0YVN0YXRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nRGF0YVN0YXRzJ10sIGZyb21UdW5pbmdEYXRhU3RhdHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5jcnlwdGlvblNwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmNyeXB0aW9uU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmNyeXB0aW9uU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuY3J5cHRpb25TcGVjJ10sIGZyb21FbmNyeXB0aW9uU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFydG5lck1vZGVsVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydG5lck1vZGVsVHVuaW5nU3BlYyddLCBmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DdXN0b21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjdXN0b21CYXNlTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ3VzdG9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3VzdG9tQmFzZU1vZGVsJ10sIGZyb21DdXN0b21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwZXJpbWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwZXJpbWVudCddKTtcbiAgICBpZiAoZnJvbUV4cGVyaW1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBlcmltZW50J10sIGZyb21FeHBlcmltZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRVcmknXSk7XG4gICAgaWYgKGZyb21PdXRwdXRVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXRVcmknXSwgZnJvbU91dHB1dFVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QaXBlbGluZUpvYiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGlwZWxpbmVKb2InXSk7XG4gICAgaWYgKGZyb21QaXBlbGluZUpvYiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10sIGZyb21QaXBlbGluZUpvYik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXJ2aWNlQWNjb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZpY2VBY2NvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZpY2VBY2NvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VydmljZUFjY291bnQnXSwgZnJvbVNlcnZpY2VBY2NvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsRGlzcGxheU5hbWUnXSwgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZW9UdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmVvVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WZW9UdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmVvVHVuaW5nU3BlYyddLCBmcm9tVmVvVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ09wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXRVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmVydGV4RGF0YXNldFJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgVHVuaW5ncyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIHR1bmluZyBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIHBhZ2VyIG9mIHR1bmluZyBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCB0dW5pbmdKb2JzID0gYXdhaXQgYWkudHVuaW5ncy5saXN0KHtjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IHR1bmluZ0pvYiBvZiB0dW5pbmdKb2JzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2codHVuaW5nSm9iKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9UVU5JTkdfSk9CUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIFR1bmluZ0pvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgcmVzb3VyY2UgbmFtZSBvZiB0aGUgdHVuaW5nIGpvYi5cbiAgICAgICAgICogQHJldHVybiAtIEEgVHVuaW5nSm9iIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCAtIFRoZSBTREsncyB0dW5pbmcgaW1wbGVtZW50YXRpb24gaXMgZXhwZXJpbWVudGFsLCBhbmQgbWF5XG4gICAgICAgICAqIGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEludGVybmFsKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgc3VwZXJ2aXNlZCBmaW5lLXR1bmluZyBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHR1bmluZyBqb2IuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIFR1bmluZ0pvYiBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50dW5lID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmFzZU1vZGVsLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZVR1bmVkTW9kZWwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZTogcGFyYW1zLmJhc2VNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVUdW5lZE1vZGVsLmNoZWNrcG9pbnRJZCA9IHBhcmFtcy5jb25maWcucHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNQcml2YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHByZVR1bmVkTW9kZWw6IHByZVR1bmVkTW9kZWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1ByaXZhdGUuYmFzZU1vZGVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50dW5lSW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNQcml2YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHVuZUludGVybmFsKHBhcmFtc1ByaXZhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IHRoaXMudHVuZU1sZGV2SW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHR1bmVkTW9kZWxOYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvblsnbWV0YWRhdGEnXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblsnbWV0YWRhdGEnXVsndHVuZWRNb2RlbCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHVuZWRNb2RlbE5hbWUgPSBvcGVyYXRpb25bJ21ldGFkYXRhJ11bJ3R1bmVkTW9kZWwnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uWyduYW1lJ10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25bJ25hbWUnXS5pbmNsdWRlcygnL29wZXJhdGlvbnMvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHVuZWRNb2RlbE5hbWUgPSBvcGVyYXRpb25bJ25hbWUnXS5zcGxpdCgnL29wZXJhdGlvbnMvJylbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHR1bmluZ0pvYiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdHVuZWRNb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBKb2JTdGF0ZS5KT0JfU1RBVEVfUVVFVUVELFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ0pvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5pbmdKb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RUdW5pbmdKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmVkTW9kZWxzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIHR1bmluZyBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjYW5jZWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLnR1bmluZ3MuY2FuY2VsKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FuY2VsVHVuaW5nSm9iUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ2FuY2VsVHVuaW5nSm9iUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FuY2VsVHVuaW5nSm9iUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDYW5jZWxUdW5pbmdKb2JSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdHVuZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb1ZlcnRleChwYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5pbmdKb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB0dW5lTWxkZXZJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5lZE1vZGVscycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ09wZXJhdGlvbkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxMDI0ICogMTAyNCAqIDg7IC8vIGJ5dGVzXG5jb25zdCBNQVhfUkVUUllfQ09VTlQgPSAzO1xuY29uc3QgSU5JVElBTF9SRVRSWV9ERUxBWV9NUyA9IDEwMDA7XG5jb25zdCBERUxBWV9NVUxUSVBMSUVSID0gMjtcbmNvbnN0IFhfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRCA9ICd4LWdvb2ctdXBsb2FkLXN0YXR1cyc7XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRCbG9iKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdXBsb2FkQmxvYkludGVybmFsKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICBjb25zdCByZXNwb25zZUpzb24gPSAoYXdhaXQgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5qc29uKCkpKTtcbiAgICBpZiAoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGZpbGU6IFVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlSnNvblsnZmlsZSddO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkQmxvYlRvRmlsZVNlYXJjaFN0b3JlKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdXBsb2FkQmxvYkludGVybmFsKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICBjb25zdCByZXNwb25zZUpzb24gPSAoYXdhaXQgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5qc29uKCkpKTtcbiAgICBpZiAoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGZpbGU6IFVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcCA9IHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uRnJvbU1sZGV2KHJlc3BvbnNlSnNvbik7XG4gICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uKCk7XG4gICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgIHJldHVybiB0eXBlZFJlc3A7XG59XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRCbG9iSW50ZXJuYWwoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBmaWxlU2l6ZSA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IHJlc3BvbnNlID0gbmV3IEh0dHBSZXNwb25zZShuZXcgUmVzcG9uc2UoKSk7XG4gICAgbGV0IHVwbG9hZENvbW1hbmQgPSAndXBsb2FkJztcbiAgICBmaWxlU2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICB3aGlsZSAob2Zmc2V0IDwgZmlsZVNpemUpIHtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5taW4oTUFYX0NIVU5LX1NJWkUsIGZpbGVTaXplIC0gb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBmaWxlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY2h1bmtTaXplKTtcbiAgICAgICAgaWYgKG9mZnNldCArIGNodW5rU2l6ZSA+PSBmaWxlU2l6ZSkge1xuICAgICAgICAgICAgdXBsb2FkQ29tbWFuZCArPSAnLCBmaW5hbGl6ZSc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldHJ5Q291bnQgPSAwO1xuICAgICAgICBsZXQgY3VycmVudERlbGF5TXMgPSBJTklUSUFMX1JFVFJZX0RFTEFZX01TO1xuICAgICAgICB3aGlsZSAocmV0cnlDb3VudCA8IE1BWF9SRVRSWV9DT1VOVCkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogJycsXG4gICAgICAgICAgICAgICAgYm9keTogY2h1bmssXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGFwaVZlcnNpb246ICcnLFxuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsOiB1cGxvYWRVcmwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiB1cGxvYWRDb21tYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtT2Zmc2V0JzogU3RyaW5nKG9mZnNldCksXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBTdHJpbmcoY2h1bmtTaXplKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcChjdXJyZW50RGVsYXlNcyk7XG4gICAgICAgICAgICBjdXJyZW50RGVsYXlNcyA9IGN1cnJlbnREZWxheU1zICogREVMQVlfTVVMVElQTElFUjtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgICAgICAvLyBUaGUgYHgtZ29vZy11cGxvYWQtc3RhdHVzYCBoZWFkZXIgZmllbGQgY2FuIGJlIGBhY3RpdmVgLCBgZmluYWxgIGFuZFxuICAgICAgICAvL2BjYW5jZWxsZWRgIGluIHJlc3Bvc25lLlxuICAgICAgICBpZiAoKChfYiA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGIvNDAxMzkxNDMwKSBJbnZlc3RpZ2F0ZSB3aHkgdGhlIHVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZFxuICAgICAgICAvLyBldmVuIHRob3VnaCBhbGwgY29udGVudCBoYXMgYmVlbiB1cGxvYWRlZC5cbiAgICAgICAgaWYgKGZpbGVTaXplIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbGwgY29udGVudCBoYXMgYmVlbiB1cGxvYWRlZCwgYnV0IHRoZSB1cGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QmxvYlN0YXQoZmlsZSkge1xuICAgIGNvbnN0IGZpbGVTdGF0ID0geyBzaXplOiBmaWxlLnNpemUsIHR5cGU6IGZpbGUudHlwZSB9O1xuICAgIHJldHVybiBmaWxlU3RhdDtcbn1cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlUHJvbWlzZSkgPT4gc2V0VGltZW91dChyZXNvbHZlUHJvbWlzZSwgbXMpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTm9kZVVwbG9hZGVyIHtcbiAgICBhc3luYyBzdGF0KGZpbGUpIHtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSB7IHNpemU6IDAsIHR5cGU6IHVuZGVmaW5lZCB9O1xuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0YXQgPSBhd2FpdCBmcy5zdGF0KGZpbGUpO1xuICAgICAgICAgICAgZmlsZVN0YXQuc2l6ZSA9IG9yaWdpbmFsU3RhdC5zaXplO1xuICAgICAgICAgICAgZmlsZVN0YXQudHlwZSA9IHRoaXMuaW5mZXJNaW1lVHlwZShmaWxlKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlU3RhdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXRCbG9iU3RhdChmaWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGxvYWQoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBsb2FkRmlsZUZyb21QYXRoKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRCbG9iKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZShmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy51cGxvYWRGaWxlVG9GaWxlU2VhcmNoU3RvcmVGcm9tUGF0aChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXBsb2FkQmxvYlRvRmlsZVNlYXJjaFN0b3JlKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmZlcnMgdGhlIE1JTUUgdHlwZSBvZiBhIGZpbGUgYmFzZWQgb24gaXRzIGV4dGVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCBUaGUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLCBvciB1bmRlZmluZWQgaWYgaXQgY2Fubm90IGJlIGluZmVycmVkLlxuICAgICAqL1xuICAgIGluZmVyTWltZVR5cGUoZmlsZVBhdGgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAgICAgICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IGZpbGVQYXRoLnNsaWNlKGZpbGVQYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGZpbGUgZXh0ZW5zaW9ucyB0byBNSU1FIHR5cGVzLlxuICAgICAgICBjb25zdCBtaW1lVHlwZXMgPSB7XG4gICAgICAgICAgICAnYWFjJzogJ2F1ZGlvL2FhYycsXG4gICAgICAgICAgICAnYWJ3JzogJ2FwcGxpY2F0aW9uL3gtYWJpd29yZCcsXG4gICAgICAgICAgICAnYXJjJzogJ2FwcGxpY2F0aW9uL3gtZnJlZWFyYycsXG4gICAgICAgICAgICAnYXZpJzogJ3ZpZGVvL3gtbXN2aWRlbycsXG4gICAgICAgICAgICAnYXp3JzogJ2FwcGxpY2F0aW9uL3ZuZC5hbWF6b24uZWJvb2snLFxuICAgICAgICAgICAgJ2Jpbic6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgJ2JtcCc6ICdpbWFnZS9ibXAnLFxuICAgICAgICAgICAgJ2J6JzogJ2FwcGxpY2F0aW9uL3gtYnppcCcsXG4gICAgICAgICAgICAnYnoyJzogJ2FwcGxpY2F0aW9uL3gtYnppcDInLFxuICAgICAgICAgICAgJ2NzaCc6ICdhcHBsaWNhdGlvbi94LWNzaCcsXG4gICAgICAgICAgICAnY3NzJzogJ3RleHQvY3NzJyxcbiAgICAgICAgICAgICdjc3YnOiAndGV4dC9jc3YnLFxuICAgICAgICAgICAgJ2RvYyc6ICdhcHBsaWNhdGlvbi9tc3dvcmQnLFxuICAgICAgICAgICAgJ2RvY3gnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgICAgICAgJ2VvdCc6ICdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCcsXG4gICAgICAgICAgICAnZXB1Yic6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCcsXG4gICAgICAgICAgICAnZ3onOiAnYXBwbGljYXRpb24vZ3ppcCcsXG4gICAgICAgICAgICAnZ2lmJzogJ2ltYWdlL2dpZicsXG4gICAgICAgICAgICAnaHRtJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICAgICAnaHRtbCc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAgICAgJ2ljbyc6ICdpbWFnZS92bmQubWljcm9zb2Z0Lmljb24nLFxuICAgICAgICAgICAgJ2ljcyc6ICd0ZXh0L2NhbGVuZGFyJyxcbiAgICAgICAgICAgICdqYXInOiAnYXBwbGljYXRpb24vamF2YS1hcmNoaXZlJyxcbiAgICAgICAgICAgICdqcGVnJzogJ2ltYWdlL2pwZWcnLFxuICAgICAgICAgICAgJ2pwZyc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgICAgICdqcyc6ICd0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgJ2pzb24nOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnanNvbmxkJzogJ2FwcGxpY2F0aW9uL2xkK2pzb24nLFxuICAgICAgICAgICAgJ2ttbCc6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCt4bWwnLFxuICAgICAgICAgICAgJ2tteic6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmtteit4bWwnLFxuICAgICAgICAgICAgJ21qcyc6ICd0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgJ21wMyc6ICdhdWRpby9tcGVnJyxcbiAgICAgICAgICAgICdtcDQnOiAndmlkZW8vbXA0JyxcbiAgICAgICAgICAgICdtcGVnJzogJ3ZpZGVvL21wZWcnLFxuICAgICAgICAgICAgJ21wa2cnOiAnYXBwbGljYXRpb24vdm5kLmFwcGxlLmluc3RhbGxlcit4bWwnLFxuICAgICAgICAgICAgJ29kdCc6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQnLFxuICAgICAgICAgICAgJ29nYSc6ICdhdWRpby9vZ2cnLFxuICAgICAgICAgICAgJ29ndic6ICd2aWRlby9vZ2cnLFxuICAgICAgICAgICAgJ29neCc6ICdhcHBsaWNhdGlvbi9vZ2cnLFxuICAgICAgICAgICAgJ29wdXMnOiAnYXVkaW8vb3B1cycsXG4gICAgICAgICAgICAnb3RmJzogJ2ZvbnQvb3RmJyxcbiAgICAgICAgICAgICdwbmcnOiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgICAgICdwZGYnOiAnYXBwbGljYXRpb24vcGRmJyxcbiAgICAgICAgICAgICdwaHAnOiAnYXBwbGljYXRpb24veC1odHRwZC1waHAnLFxuICAgICAgICAgICAgJ3BwdCc6ICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCcsXG4gICAgICAgICAgICAncHB0eCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgICdyYXInOiAnYXBwbGljYXRpb24vdm5kLnJhcicsXG4gICAgICAgICAgICAncnRmJzogJ2FwcGxpY2F0aW9uL3J0ZicsXG4gICAgICAgICAgICAnc2gnOiAnYXBwbGljYXRpb24veC1zaCcsXG4gICAgICAgICAgICAnc3ZnJzogJ2ltYWdlL3N2Zyt4bWwnLFxuICAgICAgICAgICAgJ3N3Zic6ICdhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCcsXG4gICAgICAgICAgICAndGFyJzogJ2FwcGxpY2F0aW9uL3gtdGFyJyxcbiAgICAgICAgICAgICd0aWYnOiAnaW1hZ2UvdGlmZicsXG4gICAgICAgICAgICAndGlmZic6ICdpbWFnZS90aWZmJyxcbiAgICAgICAgICAgICd0cyc6ICd2aWRlby9tcDJ0JyxcbiAgICAgICAgICAgICd0dGYnOiAnZm9udC90dGYnLFxuICAgICAgICAgICAgJ3R4dCc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAgICd2c2QnOiAnYXBwbGljYXRpb24vdm5kLnZpc2lvJyxcbiAgICAgICAgICAgICd3YXYnOiAnYXVkaW8vd2F2JyxcbiAgICAgICAgICAgICd3ZWJhJzogJ2F1ZGlvL3dlYm0nLFxuICAgICAgICAgICAgJ3dlYm0nOiAndmlkZW8vd2VibScsXG4gICAgICAgICAgICAnd2VicCc6ICdpbWFnZS93ZWJwJyxcbiAgICAgICAgICAgICd3b2ZmJzogJ2ZvbnQvd29mZicsXG4gICAgICAgICAgICAnd29mZjInOiAnZm9udC93b2ZmMicsXG4gICAgICAgICAgICAneGh0bWwnOiAnYXBwbGljYXRpb24veGh0bWwreG1sJyxcbiAgICAgICAgICAgICd4bHMnOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgICAgICAgICAgICd4bHN4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JyxcbiAgICAgICAgICAgICd4bWwnOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICAgICAgICAgICd4dWwnOiAnYXBwbGljYXRpb24vdm5kLm1vemlsbGEueHVsK3htbCcsXG4gICAgICAgICAgICAnemlwJzogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgICAgICAgICAnM2dwJzogJ3ZpZGVvLzNncHAnLFxuICAgICAgICAgICAgJzNnMic6ICd2aWRlby8zZ3BwMicsXG4gICAgICAgICAgICAnN3onOiAnYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkJyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgTUlNRSB0eXBlIGJhc2VkIG9uIHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBtaW1lVHlwZXNbZmlsZUV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBNSU1FIHR5cGUuXG4gICAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkRmlsZUZyb21QYXRoKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnVwbG9hZEZpbGVGcm9tUGF0aEludGVybmFsKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VKc29uID0gKGF3YWl0IChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuanNvbigpKSk7XG4gICAgICAgIGlmICgoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGZpbGU6IFVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VKc29uWydmaWxlJ107XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZEZpbGVUb0ZpbGVTZWFyY2hTdG9yZUZyb21QYXRoKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnVwbG9hZEZpbGVGcm9tUGF0aEludGVybmFsKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VKc29uID0gKGF3YWl0IChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuanNvbigpKSk7XG4gICAgICAgIGlmICgoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGZpbGU6IFVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwID0gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb25Gcm9tTWxkZXYocmVzcG9uc2VKc29uKTtcbiAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uKCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkRmlsZUZyb21QYXRoSW50ZXJuYWwoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IGZpbGVTaXplID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCByZXNwb25zZSA9IG5ldyBIdHRwUmVzcG9uc2UobmV3IFJlc3BvbnNlKCkpO1xuICAgICAgICBsZXQgdXBsb2FkQ29tbWFuZCA9ICd1cGxvYWQnO1xuICAgICAgICBsZXQgZmlsZUhhbmRsZTtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoJDEuYmFzZW5hbWUoZmlsZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaWxlSGFuZGxlID0gYXdhaXQgZnMub3BlbihmaWxlLCAncicpO1xuICAgICAgICAgICAgaWYgKCFmaWxlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gb3BlbiBmaWxlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlU2l6ZSA9IChhd2FpdCBmaWxlSGFuZGxlLnN0YXQoKSkuc2l6ZTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBmaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKE1BWF9DSFVOS19TSVpFLCBmaWxlU2l6ZSAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIGNodW5rU2l6ZSA+PSBmaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRDb21tYW5kICs9ICcsIGZpbmFsaXplJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJ5dGVzUmVhZDogYnl0ZXNSZWFkIH0gPSBhd2FpdCBmaWxlSGFuZGxlLnJlYWQoYnVmZmVyLCAwLCBjaHVua1NpemUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCAhPT0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlYWQgJHtjaHVua1NpemV9IGJ5dGVzIGZyb20gZmlsZSBhdCBvZmZzZXQgJHtvZmZzZXR9LiBieXRlcyBhY3R1YWxseSByZWFkOiAke2J5dGVzUmVhZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgQmxvYihbYnVmZmVyXSk7XG4gICAgICAgICAgICAgICAgbGV0IHJldHJ5Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RGVsYXlNcyA9IElOSVRJQUxfUkVUUllfREVMQVlfTVM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJldHJ5Q291bnQgPCBNQVhfUkVUUllfQ09VTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsOiB1cGxvYWRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogdXBsb2FkQ29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtT2Zmc2V0JzogU3RyaW5nKG9mZnNldCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IFN0cmluZyhieXRlc1JlYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1GaWxlLU5hbWUnOiBmaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoY3VycmVudERlbGF5TXMpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVsYXlNcyA9IGN1cnJlbnREZWxheU1zICogREVMQVlfTVVMVElQTElFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYHgtZ29vZy11cGxvYWQtc3RhdHVzYCBoZWFkZXIgZmllbGQgY2FuIGJlIGBhY3RpdmVgLCBgZmluYWxgIGFuZFxuICAgICAgICAgICAgICAgIC8vYGNhbmNlbGxlZGAgaW4gcmVzcG9zbmUuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVTaXplIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLCBidXQgdGhlIHVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGZpbGUgaGFuZGxlIGlzIGFsd2F5cyBjbG9zZWRcbiAgICAgICAgICAgIGlmIChmaWxlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsZUhhbmRsZS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBMQU5HVUFHRV9MQUJFTF9QUkVGSVggPSAnZ2wtbm9kZS8nO1xuLyoqXG4gKiBUaGUgR29vZ2xlIEdlbkFJIFNESy5cbiAqXG4gKiBAcmVtYXJrc1xuICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBHZW5BSSBmZWF0dXJlcyB0aHJvdWdoIGVpdGhlciB0aGUge0BsaW5rXG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2RvY3MvcmVmZXJlbmNlL3Jlc3QgfCBHZW1pbmkgQVBJfSBvclxuICogdGhlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2RvY3MvcmVmZXJlbmNlL3Jlc3QgfCBWZXJ0ZXggQUlcbiAqIEFQSX0uXG4gKlxuICogVGhlIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMudmVydGV4YWl9IHZhbHVlIGRldGVybWluZXMgd2hpY2ggb2YgdGhlIEFQSVxuICogc2VydmljZXMgdG8gdXNlLlxuICpcbiAqIFdoZW4gdXNpbmcgdGhlIEdlbWluaSBBUEksIGEge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9ucy5hcGlLZXl9IG11c3QgYWxzbyBiZVxuICogc2V0LiBXaGVuIHVzaW5nIFZlcnRleCBBSSwgYm90aCB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLnByb2plY3R9IGFuZCB7QGxpbmtcbiAqIEdvb2dsZUdlbkFJT3B0aW9ucy5sb2NhdGlvbn0gbXVzdCBiZSBzZXQsIG9yIGEge0BsaW5rXG4gKiBHb29nbGVHZW5BSU9wdGlvbnMuYXBpS2V5fSBtdXN0IGJlIHNldCB3aGVuIHVzaW5nIEV4cHJlc3MgTW9kZS5cbiAqXG4gKiBFeHBsaWNpdGx5IHBhc3NlZCBpbiB2YWx1ZXMgaW4ge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9uc30gd2lsbCBhbHdheXMgdGFrZVxuICogcHJlY2VkZW5jZSBvdmVyIGVudmlyb25tZW50IHZhcmlhYmxlcy4gSWYgYm90aCBwcm9qZWN0L2xvY2F0aW9uIGFuZCBhcGlfa2V5XG4gKiBleGlzdCBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLCB0aGUgcHJvamVjdC9sb2NhdGlvbiB3aWxsIGJlIHVzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgR2VtaW5pIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6ICdHRU1JTklfQVBJX0tFWSd9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJbml0aWFsaXppbmcgdGhlIFNESyBmb3IgdXNpbmcgdGhlIFZlcnRleCBBSSBBUEk6XG4gKiBgYGB0c1xuICogaW1wb3J0IHtHb29nbGVHZW5BSX0gZnJvbSAnQGdvb2dsZS9nZW5haSc7XG4gKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gKiAgIHZlcnRleGFpOiB0cnVlLFxuICogICBwcm9qZWN0OiAnUFJPSkVDVF9JRCcsXG4gKiAgIGxvY2F0aW9uOiAnUFJPSkVDVF9MT0NBVElPTidcbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5jbGFzcyBHb29nbGVHZW5BSSB7XG4gICAgZ2V0IGludGVyYWN0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVyYWN0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJhY3Rpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybignR29vZ2xlR2VuQUkuaW50ZXJhY3Rpb25zOiBJbnRlcmFjdGlvbnMgdXNhZ2UgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy4nKTtcbiAgICAgICAgY29uc3QgaHR0cE9wdHMgPSB0aGlzLmh0dHBPcHRpb25zO1xuICAgICAgICAvLyBVbnN1cHBvcnRlZCBPcHRpb25zIFdhcm5pbmdzXG4gICAgICAgIGlmIChodHRwT3B0cyA9PT0gbnVsbCB8fCBodHRwT3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdHMuZXh0cmFCb2R5KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dvb2dsZUdlbkFJLmludGVyYWN0aW9uczogQ2xpZW50IGxldmVsIGh0dHBPcHRpb25zLmV4dHJhQm9keSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBpbnRlcmFjdGlvbnMgY2xpZW50IGFuZCB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dEdlbkNsaWVudCA9IG5ldyBHZW1pbmlOZXh0R2VuQVBJQ2xpZW50KHtcbiAgICAgICAgICAgIGJhc2VVUkw6IHRoaXMuYXBpQ2xpZW50LmdldEJhc2VVcmwoKSxcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICBhcGlWZXJzaW9uOiB0aGlzLmFwaUNsaWVudC5nZXRBcGlWZXJzaW9uKCksXG4gICAgICAgICAgICBjbGllbnRBZGFwdGVyOiB0aGlzLmFwaUNsaWVudCxcbiAgICAgICAgICAgIGRlZmF1bHRIZWFkZXJzOiB0aGlzLmFwaUNsaWVudC5nZXREZWZhdWx0SGVhZGVycygpLFxuICAgICAgICAgICAgdGltZW91dDogaHR0cE9wdHMgPT09IG51bGwgfHwgaHR0cE9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0dHBPcHRzLnRpbWVvdXQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pbnRlcmFjdGlvbnMgPSBuZXh0R2VuQ2xpZW50LmludGVyYWN0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aW9ucztcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgLy8gVmFsaWRhdGUgZXhwbGljaXRseSBzZXQgaW5pdGlhbGl6ZXIgdmFsdWVzLlxuICAgICAgICBpZiAoKG9wdGlvbnMucHJvamVjdCB8fCBvcHRpb25zLmxvY2F0aW9uKSAmJiBvcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0L2xvY2F0aW9uIGFuZCBBUEkga2V5IGFyZSBtdXR1YWxseSBleGNsdXNpdmUgaW4gdGhlIGNsaWVudCBpbml0aWFsaXplci4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRleGFpID1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IG9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdldEJvb2xlYW5FbnYoJ0dPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUknKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGVudkFwaUtleSA9IGdldEFwaUtleUZyb21FbnYoKTtcbiAgICAgICAgY29uc3QgZW52UHJvamVjdCA9IGdldEVudignR09PR0xFX0NMT1VEX1BST0pFQ1QnKTtcbiAgICAgICAgY29uc3QgZW52TG9jYXRpb24gPSBnZXRFbnYoJ0dPT0dMRV9DTE9VRF9MT0NBVElPTicpO1xuICAgICAgICB0aGlzLmFwaUtleSA9IChfYyA9IG9wdGlvbnMuYXBpS2V5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBlbnZBcGlLZXk7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IChfZCA9IG9wdGlvbnMucHJvamVjdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZW52UHJvamVjdDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IChfZSA9IG9wdGlvbnMubG9jYXRpb24pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGVudkxvY2F0aW9uO1xuICAgICAgICAvLyBIYW5kbGUgd2hlbiB0byB1c2UgVmVydGV4IEFJIGluIGV4cHJlc3MgbW9kZSAoYXBpIGtleSlcbiAgICAgICAgaWYgKG9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIGlmICgoX2YgPSBvcHRpb25zLmdvb2dsZUF1dGhPcHRpb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBjcmVkZW50aWFscyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBpbXBsaWNpdCBhcGlfa2V5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSB1c2VyIHByb3ZpZGVkIEdvb2dsZSBDbG91ZCBjcmVkZW50aWFscyB3aWxsIHRha2UgcHJlY2VkZW5jZScgK1xuICAgICAgICAgICAgICAgICAgICAnIG92ZXIgdGhlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBhcGlfa2V5IGFuZCBleHBsaWNpdCBwcm9qZWN0L2xvY2F0aW9uIGFscmVhZHkgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgICAgIGlmICgoZW52UHJvamVjdCB8fCBlbnZMb2NhdGlvbikgJiYgb3B0aW9ucy5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBhcGlfa2V5IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBpbXBsaWNpdCBwcm9qZWN0L2xvY2F0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSB1c2VyIHByb3ZpZGVkIFZlcnRleCBBSSBBUEkga2V5IHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXInICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aGUgcHJvamVjdC9sb2NhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgob3B0aW9ucy5wcm9qZWN0IHx8IG9wdGlvbnMubG9jYXRpb24pICYmIGVudkFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IHByb2plY3QvbG9jYXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgcHJvamVjdC9sb2NhdGlvbiB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyJyArXG4gICAgICAgICAgICAgICAgICAgICcgdGhlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGVudlByb2plY3QgfHwgZW52TG9jYXRpb24pICYmIGVudkFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEltcGxpY2l0IHByb2plY3QvbG9jYXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHByb2plY3QvbG9jYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpbGwgdGFrZScgK1xuICAgICAgICAgICAgICAgICAgICAnIHByZWNlZGVuY2Ugb3ZlciB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubG9jYXRpb24gJiYgIXRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9ICdnbG9iYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsKG9wdGlvbnMuaHR0cE9wdGlvbnMsIG9wdGlvbnMudmVydGV4YWksIGdldEVudignR09PR0xFX1ZFUlRFWF9CQVNFX1VSTCcpLCBnZXRFbnYoJ0dPT0dMRV9HRU1JTklfQkFTRV9VUkwnKSk7XG4gICAgICAgIGlmIChiYXNlVXJsKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmh0dHBPcHRpb25zID0geyBiYXNlVXJsOiBiYXNlVXJsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlWZXJzaW9uID0gb3B0aW9ucy5hcGlWZXJzaW9uO1xuICAgICAgICB0aGlzLmh0dHBPcHRpb25zID0gb3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgY29uc3QgYXV0aCA9IG5ldyBOb2RlQXV0aCh7XG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgZ29vZ2xlQXV0aE9wdGlvbnM6IG9wdGlvbnMuZ29vZ2xlQXV0aE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBBcGlDbGllbnQoe1xuICAgICAgICAgICAgYXV0aDogYXV0aCxcbiAgICAgICAgICAgIHByb2plY3Q6IHRoaXMucHJvamVjdCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLmxvY2F0aW9uLFxuICAgICAgICAgICAgYXBpVmVyc2lvbjogdGhpcy5hcGlWZXJzaW9uLFxuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIHZlcnRleGFpOiB0aGlzLnZlcnRleGFpLFxuICAgICAgICAgICAgaHR0cE9wdGlvbnM6IHRoaXMuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICB1c2VyQWdlbnRFeHRyYTogTEFOR1VBR0VfTEFCRUxfUFJFRklYICsgcHJvY2Vzcy52ZXJzaW9uLFxuICAgICAgICAgICAgdXBsb2FkZXI6IG5ldyBOb2RlVXBsb2FkZXIoKSxcbiAgICAgICAgICAgIGRvd25sb2FkZXI6IG5ldyBOb2RlRG93bmxvYWRlcigpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBuZXcgTW9kZWxzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5saXZlID0gbmV3IExpdmUodGhpcy5hcGlDbGllbnQsIGF1dGgsIG5ldyBOb2RlV2ViU29ja2V0RmFjdG9yeSgpKTtcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gbmV3IEJhdGNoZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmNoYXRzID0gbmV3IENoYXRzKHRoaXMubW9kZWxzLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuY2FjaGVzID0gbmV3IENhY2hlcyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuZmlsZXMgPSBuZXcgRmlsZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBuZXcgT3BlcmF0aW9ucyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuYXV0aFRva2VucyA9IG5ldyBUb2tlbnModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLnR1bmluZ3MgPSBuZXcgVHVuaW5ncyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuZmlsZVNlYXJjaFN0b3JlcyA9IG5ldyBGaWxlU2VhcmNoU3RvcmVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFbnYoZW52KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IHByb2Nlc3MgPT09IG51bGwgfHwgcHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzcy5lbnYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtlbnZdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHJpbSgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRCb29sZWFuRW52KGVudikge1xuICAgIHJldHVybiBzdHJpbmdUb0Jvb2xlYW4oZ2V0RW52KGVudikpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9Cb29sZWFuKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuZnVuY3Rpb24gZ2V0QXBpS2V5RnJvbUVudigpIHtcbiAgICBjb25zdCBlbnZHb29nbGVBcGlLZXkgPSBnZXRFbnYoJ0dPT0dMRV9BUElfS0VZJyk7XG4gICAgY29uc3QgZW52R2VtaW5pQXBpS2V5ID0gZ2V0RW52KCdHRU1JTklfQVBJX0tFWScpO1xuICAgIGlmIChlbnZHb29nbGVBcGlLZXkgJiYgZW52R2VtaW5pQXBpS2V5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQm90aCBHT09HTEVfQVBJX0tFWSBhbmQgR0VNSU5JX0FQSV9LRVkgYXJlIHNldC4gVXNpbmcgR09PR0xFX0FQSV9LRVkuJyk7XG4gICAgfVxuICAgIHJldHVybiBlbnZHb29nbGVBcGlLZXkgfHwgZW52R2VtaW5pQXBpS2V5IHx8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHsgQWN0aXZpdHlIYW5kbGluZywgQWRhcHRlclNpemUsIEFwaUVycm9yLCBBcGlTcGVjLCBBdXRoVHlwZSwgQmF0Y2hlcywgQmVoYXZpb3IsIEJsb2NrZWRSZWFzb24sIENhY2hlcywgQ2FuY2VsVHVuaW5nSm9iUmVzcG9uc2UsIENoYXQsIENoYXRzLCBDb21wdXRlVG9rZW5zUmVzcG9uc2UsIENvbnRlbnRSZWZlcmVuY2VJbWFnZSwgQ29udHJvbFJlZmVyZW5jZUltYWdlLCBDb250cm9sUmVmZXJlbmNlVHlwZSwgQ291bnRUb2tlbnNSZXNwb25zZSwgQ3JlYXRlRmlsZVJlc3BvbnNlLCBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UsIERlbGV0ZUZpbGVSZXNwb25zZSwgRGVsZXRlTW9kZWxSZXNwb25zZSwgRG9jdW1lbnRTdGF0ZSwgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUsIEVkaXRJbWFnZVJlc3BvbnNlLCBFZGl0TW9kZSwgRW1iZWRDb250ZW50UmVzcG9uc2UsIEVuZFNlbnNpdGl2aXR5LCBFbnZpcm9ubWVudCwgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UsIEZpbGVTb3VyY2UsIEZpbGVTdGF0ZSwgRmlsZXMsIEZpbmlzaFJlYXNvbiwgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSwgRnVuY3Rpb25SZXNwb25zZSwgRnVuY3Rpb25SZXNwb25zZUJsb2IsIEZ1bmN0aW9uUmVzcG9uc2VGaWxlRGF0YSwgRnVuY3Rpb25SZXNwb25zZVBhcnQsIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nLCBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSwgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VQcm9tcHRGZWVkYmFjaywgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VVc2FnZU1ldGFkYXRhLCBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlLCBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbiwgR2VuZXJhdGVWaWRlb3NSZXNwb25zZSwgR29vZ2xlR2VuQUksIEhhcm1CbG9ja01ldGhvZCwgSGFybUJsb2NrVGhyZXNob2xkLCBIYXJtQ2F0ZWdvcnksIEhhcm1Qcm9iYWJpbGl0eSwgSGFybVNldmVyaXR5LCBIdHRwRWxlbWVudExvY2F0aW9uLCBIdHRwUmVzcG9uc2UsIEltYWdlUHJvbXB0TGFuZ3VhZ2UsIEltcG9ydEZpbGVPcGVyYXRpb24sIEltcG9ydEZpbGVSZXNwb25zZSwgSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlLCBJbmxpbmVkUmVzcG9uc2UsIEpvYlN0YXRlLCBMYW5ndWFnZSwgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlLCBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSwgTGlzdERvY3VtZW50c1Jlc3BvbnNlLCBMaXN0RmlsZVNlYXJjaFN0b3Jlc1Jlc3BvbnNlLCBMaXN0RmlsZXNSZXNwb25zZSwgTGlzdE1vZGVsc1Jlc3BvbnNlLCBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlLCBMaXZlLCBMaXZlQ2xpZW50VG9vbFJlc3BvbnNlLCBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wsIExpdmVNdXNpY1NlcnZlck1lc3NhZ2UsIExpdmVTZW5kVG9vbFJlc3BvbnNlUGFyYW1ldGVycywgTGl2ZVNlcnZlck1lc3NhZ2UsIE1hc2tSZWZlcmVuY2VJbWFnZSwgTWFza1JlZmVyZW5jZU1vZGUsIE1lZGlhTW9kYWxpdHksIE1lZGlhUmVzb2x1dGlvbiwgTW9kYWxpdHksIE1vZGVscywgTXVzaWNHZW5lcmF0aW9uTW9kZSwgT3BlcmF0aW9ucywgT3V0Y29tZSwgUGFnZWRJdGVtLCBQYWdlciwgUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsLCBQZXJzb25HZW5lcmF0aW9uLCBQaGlzaEJsb2NrVGhyZXNob2xkLCBSYXdSZWZlcmVuY2VJbWFnZSwgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSwgUmVwbGF5UmVzcG9uc2UsIFNhZmV0eUZpbHRlckxldmVsLCBTY2FsZSwgU2VnbWVudEltYWdlUmVzcG9uc2UsIFNlZ21lbnRNb2RlLCBTZXNzaW9uLCBTaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZSwgU3RhcnRTZW5zaXRpdml0eSwgU3R5bGVSZWZlcmVuY2VJbWFnZSwgU3ViamVjdFJlZmVyZW5jZUltYWdlLCBTdWJqZWN0UmVmZXJlbmNlVHlwZSwgVGhpbmtpbmdMZXZlbCwgVG9rZW5zLCBUcmFmZmljVHlwZSwgVHVuaW5nTWV0aG9kLCBUdW5pbmdNb2RlLCBUdW5pbmdUYXNrLCBUdXJuQ29tcGxldGVSZWFzb24sIFR1cm5Db3ZlcmFnZSwgVHlwZSwgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb24sIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2UsIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2UsIFVwc2NhbGVJbWFnZVJlc3BvbnNlLCBVcmxSZXRyaWV2YWxTdGF0dXMsIFZhZFNpZ25hbFR5cGUsIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5LCBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSwgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSwgY3JlYXRlRnVuY3Rpb25SZXNwb25zZVBhcnRGcm9tQmFzZTY0LCBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21VcmksIGNyZWF0ZU1vZGVsQ29udGVudCwgY3JlYXRlUGFydEZyb21CYXNlNjQsIGNyZWF0ZVBhcnRGcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCwgY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZSwgY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwsIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZSwgY3JlYXRlUGFydEZyb21UZXh0LCBjcmVhdGVQYXJ0RnJvbVVyaSwgY3JlYXRlVXNlckNvbnRlbnQsIG1jcFRvVG9vbCwgc2V0RGVmYXVsdEJhc2VVcmxzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiR29vZ2xlQXV0aCIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiZnMiLCJ3cml0ZUZpbGUiLCJSZWFkYWJsZSIsImZpbmlzaGVkIiwiTm9kZVdzIiwicGF0aCQxIiwiX2RlZmF1bHRCYXNlR2VtaW5pVXJsIiwidW5kZWZpbmVkIiwiX2RlZmF1bHRCYXNlVmVydGV4VXJsIiwic2V0RGVmYXVsdEJhc2VVcmxzIiwiYmFzZVVybFBhcmFtcyIsImdlbWluaVVybCIsInZlcnRleFVybCIsImdldERlZmF1bHRCYXNlVXJscyIsImdldEJhc2VVcmwiLCJodHRwT3B0aW9ucyIsInZlcnRleGFpIiwidmVydGV4QmFzZVVybEZyb21FbnYiLCJnZW1pbmlCYXNlVXJsRnJvbUVudiIsIl9hIiwiX2IiLCJiYXNlVXJsIiwiZGVmYXVsdEJhc2VVcmxzIiwiQmFzZU1vZHVsZSIsImZvcm1hdE1hcCIsInRlbXBsYXRlU3RyaW5nIiwidmFsdWVNYXAiLCJyZWdleCIsInJlcGxhY2UiLCJtYXRjaCIsImtleSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwiU3RyaW5nIiwiRXJyb3IiLCJzZXRWYWx1ZUJ5UGF0aCIsImRhdGEiLCJrZXlzIiwiaSIsImxlbmd0aCIsImVuZHNXaXRoIiwia2V5TmFtZSIsInNsaWNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZnJvbSIsImFycmF5RGF0YSIsImoiLCJlbnRyeSIsImQiLCJrZXlUb1NldCIsImV4aXN0aW5nRGF0YSIsImFzc2lnbiIsInZhbHVlQXNSZWNvcmQiLCJnZXRWYWx1ZUJ5UGF0aCIsImRlZmF1bHRWYWx1ZSIsIm1hcCIsImVycm9yIiwiVHlwZUVycm9yIiwibW92ZVZhbHVlQnlQYXRoIiwicGF0aHMiLCJzb3VyY2VQYXRoIiwiZGVzdFBhdGgiLCJlbnRyaWVzIiwic291cmNlS2V5cyIsInNwbGl0IiwiZGVzdEtleXMiLCJleGNsdWRlS2V5cyIsIlNldCIsIndpbGRjYXJkSWR4IiwiYWRkIiwiX21vdmVWYWx1ZVJlY3Vyc2l2ZSIsImtleUlkeCIsImRhdGFSZWNvcmQiLCJpdGVtIiwia2V5c1RvTW92ZSIsImZpbHRlciIsImsiLCJzdGFydHNXaXRoIiwiaGFzIiwidmFsdWVzVG9Nb3ZlIiwidiIsIm5ld0Rlc3RLZXlzIiwiZGsiLCJwdXNoIiwidEJ5dGVzJDEiLCJmcm9tQnl0ZXMiLCJmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJmcm9tT2JqZWN0IiwidG9PYmplY3QiLCJmcm9tT3BlcmF0aW9uTmFtZSIsImZyb21SZXNvdXJjZU5hbWUiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxIiwiZnJvbU5hbWUiLCJmcm9tTWV0YWRhdGEiLCJmcm9tRG9uZSIsImZyb21FcnJvciIsImZyb21SZXNwb25zZSIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYkMSIsImdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxIiwiZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgkMSIsImZyb21HZW5lcmF0ZWRWaWRlb3MiLCJ0cmFuc2Zvcm1lZExpc3QiLCJnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxIiwiZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCIsImZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyIsImdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxIiwiZnJvbVZpZGVvIiwidmlkZW9Gcm9tTWxkZXYkMSIsInZpZGVvRnJvbVZlcnRleCQxIiwiZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvTWxkZXYiLCJnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2JDEiLCJpbXBvcnRGaWxlUmVzcG9uc2VGcm9tTWxkZXYkMSIsImZyb21TZGtIdHRwUmVzcG9uc2UiLCJmcm9tUGFyZW50IiwiZnJvbURvY3VtZW50TmFtZSIsInVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uRnJvbU1sZGV2IiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXNwb25zZUZyb21NbGRldiIsImZyb21VcmkiLCJmcm9tVmlkZW9CeXRlcyIsImZyb21NaW1lVHlwZSIsIk91dGNvbWUiLCJMYW5ndWFnZSIsIkZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nIiwiVHlwZSIsIkFwaVNwZWMiLCJBdXRoVHlwZSIsIkh0dHBFbGVtZW50TG9jYXRpb24iLCJQaGlzaEJsb2NrVGhyZXNob2xkIiwiQmVoYXZpb3IiLCJEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSIsIkZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUiLCJUaGlua2luZ0xldmVsIiwiSGFybUNhdGVnb3J5IiwiSGFybUJsb2NrTWV0aG9kIiwiSGFybUJsb2NrVGhyZXNob2xkIiwiRmluaXNoUmVhc29uIiwiSGFybVByb2JhYmlsaXR5IiwiSGFybVNldmVyaXR5IiwiVXJsUmV0cmlldmFsU3RhdHVzIiwiQmxvY2tlZFJlYXNvbiIsIlRyYWZmaWNUeXBlIiwiTW9kYWxpdHkiLCJNZWRpYVJlc29sdXRpb24iLCJUdW5pbmdNb2RlIiwiQWRhcHRlclNpemUiLCJKb2JTdGF0ZSIsIlR1bmluZ1Rhc2siLCJQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWwiLCJGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSIsIkVudmlyb25tZW50IiwiU2FmZXR5RmlsdGVyTGV2ZWwiLCJQZXJzb25HZW5lcmF0aW9uIiwiSW1hZ2VQcm9tcHRMYW5ndWFnZSIsIk1hc2tSZWZlcmVuY2VNb2RlIiwiQ29udHJvbFJlZmVyZW5jZVR5cGUiLCJTdWJqZWN0UmVmZXJlbmNlVHlwZSIsIkVkaXRNb2RlIiwiU2VnbWVudE1vZGUiLCJWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlIiwiVmlkZW9HZW5lcmF0aW9uTWFza01vZGUiLCJWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSIsIlR1bmluZ01ldGhvZCIsIkRvY3VtZW50U3RhdGUiLCJGaWxlU3RhdGUiLCJGaWxlU291cmNlIiwiVHVybkNvbXBsZXRlUmVhc29uIiwiTWVkaWFNb2RhbGl0eSIsIlZhZFNpZ25hbFR5cGUiLCJTdGFydFNlbnNpdGl2aXR5IiwiRW5kU2Vuc2l0aXZpdHkiLCJBY3Rpdml0eUhhbmRsaW5nIiwiVHVybkNvdmVyYWdlIiwiU2NhbGUiLCJNdXNpY0dlbmVyYXRpb25Nb2RlIiwiTGl2ZU11c2ljUGxheWJhY2tDb250cm9sIiwiRnVuY3Rpb25SZXNwb25zZUJsb2IiLCJGdW5jdGlvblJlc3BvbnNlRmlsZURhdGEiLCJGdW5jdGlvblJlc3BvbnNlUGFydCIsImNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbUJhc2U2NCIsIm1pbWVUeXBlIiwiaW5saW5lRGF0YSIsImNyZWF0ZUZ1bmN0aW9uUmVzcG9uc2VQYXJ0RnJvbVVyaSIsInVyaSIsImZpbGVEYXRhIiwiZmlsZVVyaSIsIkZ1bmN0aW9uUmVzcG9uc2UiLCJjcmVhdGVQYXJ0RnJvbVVyaSIsIm1lZGlhUmVzb2x1dGlvbiIsImxldmVsIiwiY3JlYXRlUGFydEZyb21UZXh0IiwidGV4dCIsImNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25DYWxsIiwibmFtZSIsImFyZ3MiLCJmdW5jdGlvbkNhbGwiLCJjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uUmVzcG9uc2UiLCJpZCIsInJlc3BvbnNlIiwicGFydHMiLCJmdW5jdGlvblJlc3BvbnNlIiwiY3JlYXRlUGFydEZyb21CYXNlNjQiLCJjcmVhdGVQYXJ0RnJvbUNvZGVFeGVjdXRpb25SZXN1bHQiLCJvdXRjb21lIiwib3V0cHV0IiwiY29kZUV4ZWN1dGlvblJlc3VsdCIsImNyZWF0ZVBhcnRGcm9tRXhlY3V0YWJsZUNvZGUiLCJjb2RlIiwibGFuZ3VhZ2UiLCJleGVjdXRhYmxlQ29kZSIsIl9pc1BhcnQiLCJvYmoiLCJfdG9QYXJ0cyIsInBhcnRPclN0cmluZyIsInBhcnQiLCJjcmVhdGVVc2VyQ29udGVudCIsInJvbGUiLCJjcmVhdGVNb2RlbENvbnRlbnQiLCJIdHRwUmVzcG9uc2UiLCJjb25zdHJ1Y3RvciIsImhlYWRlcnMiLCJwYWlyIiwicmVzcG9uc2VJbnRlcm5hbCIsImpzb24iLCJHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrIiwiR2VuZXJhdGVDb250ZW50UmVzcG9uc2VVc2FnZU1ldGFkYXRhIiwiR2VuZXJhdGVDb250ZW50UmVzcG9uc2UiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJjYW5kaWRhdGVzIiwiY29udGVudCIsImNvbnNvbGUiLCJ3YXJuIiwiYW55VGV4dFBhcnRUZXh0Iiwibm9uVGV4dFBhcnRzIiwiZmllbGROYW1lIiwiZmllbGRWYWx1ZSIsInRob3VnaHQiLCJub25EYXRhUGFydHMiLCJhdG9iIiwiYnRvYSIsImZ1bmN0aW9uQ2FsbHMiLCJfaiIsIkVtYmVkQ29udGVudFJlc3BvbnNlIiwiR2VuZXJhdGVJbWFnZXNSZXNwb25zZSIsIkVkaXRJbWFnZVJlc3BvbnNlIiwiVXBzY2FsZUltYWdlUmVzcG9uc2UiLCJSZWNvbnRleHRJbWFnZVJlc3BvbnNlIiwiU2VnbWVudEltYWdlUmVzcG9uc2UiLCJMaXN0TW9kZWxzUmVzcG9uc2UiLCJEZWxldGVNb2RlbFJlc3BvbnNlIiwiQ291bnRUb2tlbnNSZXNwb25zZSIsIkNvbXB1dGVUb2tlbnNSZXNwb25zZSIsIkdlbmVyYXRlVmlkZW9zUmVzcG9uc2UiLCJHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbiIsIl9mcm9tQVBJUmVzcG9uc2UiLCJhcGlSZXNwb25zZSIsIl9pc1ZlcnRleEFJIiwib3BlcmF0aW9uIiwib3AiLCJMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlIiwiQ2FuY2VsVHVuaW5nSm9iUmVzcG9uc2UiLCJEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UiLCJMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSIsIkxpc3REb2N1bWVudHNSZXNwb25zZSIsIkxpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2UiLCJVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3VtYWJsZVJlc3BvbnNlIiwiSW1wb3J0RmlsZVJlc3BvbnNlIiwiSW1wb3J0RmlsZU9wZXJhdGlvbiIsIkxpc3RGaWxlc1Jlc3BvbnNlIiwiQ3JlYXRlRmlsZVJlc3BvbnNlIiwiRGVsZXRlRmlsZVJlc3BvbnNlIiwiSW5saW5lZFJlc3BvbnNlIiwiU2luZ2xlRW1iZWRDb250ZW50UmVzcG9uc2UiLCJJbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2UiLCJMaXN0QmF0Y2hKb2JzUmVzcG9uc2UiLCJSZXBsYXlSZXNwb25zZSIsIlJhd1JlZmVyZW5jZUltYWdlIiwidG9SZWZlcmVuY2VJbWFnZUFQSSIsInJlZmVyZW5jZUltYWdlQVBJIiwicmVmZXJlbmNlVHlwZSIsInJlZmVyZW5jZUltYWdlIiwicmVmZXJlbmNlSWQiLCJNYXNrUmVmZXJlbmNlSW1hZ2UiLCJtYXNrSW1hZ2VDb25maWciLCJjb25maWciLCJDb250cm9sUmVmZXJlbmNlSW1hZ2UiLCJjb250cm9sSW1hZ2VDb25maWciLCJTdHlsZVJlZmVyZW5jZUltYWdlIiwic3R5bGVJbWFnZUNvbmZpZyIsIlN1YmplY3RSZWZlcmVuY2VJbWFnZSIsInN1YmplY3RJbWFnZUNvbmZpZyIsIkNvbnRlbnRSZWZlcmVuY2VJbWFnZSIsIkxpdmVTZXJ2ZXJNZXNzYWdlIiwiYW55VGV4dFBhcnRGb3VuZCIsInNlcnZlckNvbnRlbnQiLCJtb2RlbFR1cm4iLCJMaXZlQ2xpZW50VG9vbFJlc3BvbnNlIiwiTGl2ZVNlbmRUb29sUmVzcG9uc2VQYXJhbWV0ZXJzIiwiZnVuY3Rpb25SZXNwb25zZXMiLCJMaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlIiwiYXVkaW9DaHVuayIsImF1ZGlvQ2h1bmtzIiwiVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXNwb25zZSIsIlVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uIiwidE1vZGVsIiwiYXBpQ2xpZW50IiwibW9kZWwiLCJpbmNsdWRlcyIsImlzVmVydGV4QUkiLCJpbmRleE9mIiwidENhY2hlc01vZGVsIiwidHJhbnNmb3JtZWRNb2RlbCIsImdldFByb2plY3QiLCJnZXRMb2NhdGlvbiIsInRCbG9icyIsImJsb2JzIiwiYmxvYiIsInRCbG9iIiwidEltYWdlQmxvYiIsInRyYW5zZm9ybWVkQmxvYiIsInRBdWRpb0Jsb2IiLCJ0UGFydCIsIm9yaWdpbiIsInRQYXJ0cyIsIl9pc0NvbnRlbnQiLCJfaXNGdW5jdGlvbkNhbGxQYXJ0IiwiX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQiLCJ0Q29udGVudCIsInRDb250ZW50c0ZvckVtYmVkIiwiZmxhdE1hcCIsInRDb250ZW50cyIsInJlc3VsdCIsImFjY3VtdWxhdGVkUGFydHMiLCJpc0NvbnRlbnRBcnJheSIsImlzQ29udGVudCIsImZsYXR0ZW5UeXBlQXJyYXlUb0FueU9mIiwidHlwZUxpc3QiLCJyZXN1bHRpbmdTY2hlbWEiLCJsaXN0V2l0aG91dE51bGwiLCJ0eXBlIiwidmFsdWVzIiwidG9VcHBlckNhc2UiLCJUWVBFX1VOU1BFQ0lGSUVEIiwicHJvY2Vzc0pzb25TY2hlbWEiLCJfanNvblNjaGVtYSIsImdlbkFJU2NoZW1hIiwic2NoZW1hRmllbGROYW1lcyIsImxpc3RTY2hlbWFGaWVsZE5hbWVzIiwiZGljdFNjaGVtYUZpZWxkTmFtZXMiLCJpbmNvbWluZ0FueU9mIiwibGlzdFNjaGVtYUZpZWxkVmFsdWUiLCJkaWN0U2NoZW1hRmllbGRWYWx1ZSIsInRTY2hlbWEiLCJzY2hlbWEiLCJ0U3BlZWNoQ29uZmlnIiwic3BlZWNoQ29uZmlnIiwidm9pY2VDb25maWciLCJwcmVidWlsdFZvaWNlQ29uZmlnIiwidm9pY2VOYW1lIiwidExpdmVTcGVlY2hDb25maWciLCJ0VG9vbCIsInRvb2wiLCJmdW5jdGlvbkRlY2xhcmF0aW9ucyIsImZ1bmN0aW9uRGVjbGFyYXRpb24iLCJwYXJhbWV0ZXJzIiwicGFyYW1ldGVyc0pzb25TY2hlbWEiLCJyZXNwb25zZUpzb25TY2hlbWEiLCJ0VG9vbHMiLCJ0b29scyIsInJlc291cmNlTmFtZSIsImNsaWVudCIsInJlc291cmNlUHJlZml4Iiwic3BsaXRzQWZ0ZXJQcmVmaXgiLCJzaG91bGRBcHBlbmRQcmVmaXgiLCJ0Q2FjaGVkQ29udGVudE5hbWUiLCJ0VHVuaW5nSm9iU3RhdHVzIiwic3RhdHVzIiwidEJ5dGVzIiwiZnJvbUltYWdlQnl0ZXMiLCJfaXNGaWxlIiwiaXNHZW5lcmF0ZWRWaWRlbyIsImlzVmlkZW8iLCJ0RmlsZU5hbWUiLCJ2aWRlbyIsInN1ZmZpeCIsInRNb2RlbHNVcmwiLCJiYXNlTW9kZWxzIiwicmVzIiwidEV4dHJhY3RNb2RlbHMiLCJoYXNGaWVsZCIsIm1jcFRvR2VtaW5pVG9vbCIsIm1jcFRvb2wiLCJtY3BUb29sU2NoZW1hIiwiZGVzY3JpcHRpb24iLCJiZWhhdmlvciIsImdlbWluaVRvb2wiLCJtY3BUb29sc1RvR2VtaW5pVG9vbCIsIm1jcFRvb2xzIiwidG9vbE5hbWVzIiwibWNwVG9vbE5hbWUiLCJ0QmF0Y2hKb2JTb3VyY2UiLCJzcmMiLCJzb3VyY2VPYmoiLCJmb3JtYXQiLCJnY3NVcmkiLCJiaWdxdWVyeVVyaSIsImZpbGVOYW1lIiwiaW5saW5lZFJlcXVlc3RzIiwidmVydGV4U291cmNlc0NvdW50IiwiQm9vbGVhbiIsIm1sZGV2U291cmNlc0NvdW50IiwidEJhdGNoSm9iRGVzdGluYXRpb24iLCJkZXN0IiwiZGVzdFN0cmluZyIsInRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbiIsImlubGluZVJlc3BvbnNlc1ZhbCIsImlubGluZVJlc3BvbnNlc09iaiIsInJlc3BvbnNlc0FycmF5IiwiaGFzRW1iZWRkaW5nIiwicmVzcG9uc2VJdGVtIiwicmVzcG9uc2VJdGVtT2JqIiwicmVzcG9uc2VWYWwiLCJyZXNwb25zZU9iaiIsInRCYXRjaEpvYk5hbWUiLCJuYW1lU3RyaW5nIiwibWxkZXZQYXR0ZXJuIiwidGVzdCIsInBvcCIsInZlcnRleFBhdHRlcm4iLCJ0Sm9iU3RhdGUiLCJzdGF0ZSIsInN0YXRlU3RyaW5nIiwiYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldiIsImZyb21GaWxlTmFtZSIsImZyb21JbmxpbmVkUmVzcG9uc2VzIiwiaW5saW5lZFJlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbUlubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMiLCJiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleCIsImZyb21Gb3JtYXQiLCJmcm9tR2NzVXJpIiwiZnJvbUJpZ3F1ZXJ5VXJpIiwiYmF0Y2hKb2JEZXN0aW5hdGlvblRvVmVydGV4IiwiYmF0Y2hKb2JGcm9tTWxkZXYiLCJmcm9tRGlzcGxheU5hbWUiLCJmcm9tU3RhdGUiLCJmcm9tQ3JlYXRlVGltZSIsImZyb21FbmRUaW1lIiwiZnJvbVVwZGF0ZVRpbWUiLCJmcm9tTW9kZWwiLCJmcm9tRGVzdCIsImJhdGNoSm9iRnJvbVZlcnRleCIsImZyb21TdGFydFRpbWUiLCJmcm9tU3JjIiwiYmF0Y2hKb2JTb3VyY2VGcm9tVmVydGV4IiwiZnJvbUNvbXBsZXRpb25TdGF0cyIsImJhdGNoSm9iU291cmNlVG9NbGRldiIsImZyb21JbmxpbmVkUmVxdWVzdHMiLCJpbmxpbmVkUmVxdWVzdFRvTWxkZXYiLCJiYXRjaEpvYlNvdXJjZVRvVmVydGV4IiwiYmxvYlRvTWxkZXYkNCIsImZyb21EYXRhIiwiY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwiY2FuZGlkYXRlRnJvbU1sZGV2JDEiLCJmcm9tQ29udGVudCIsImZyb21DaXRhdGlvbk1ldGFkYXRhIiwiY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxIiwiZnJvbVRva2VuQ291bnQiLCJmcm9tRmluaXNoUmVhc29uIiwiZnJvbUF2Z0xvZ3Byb2JzIiwiZnJvbUdyb3VuZGluZ01ldGFkYXRhIiwiZnJvbUluZGV4IiwiZnJvbUxvZ3Byb2JzUmVzdWx0IiwiZnJvbVNhZmV0eVJhdGluZ3MiLCJmcm9tVXJsQ29udGV4dE1ldGFkYXRhIiwiZnJvbUNpdGF0aW9ucyIsImNvbnRlbnRUb01sZGV2JDQiLCJmcm9tUGFydHMiLCJwYXJ0VG9NbGRldiQ0IiwiZnJvbVJvbGUiLCJjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvTWxkZXYiLCJwYXJlbnRPYmplY3QiLCJjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvVmVydGV4IiwiY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21Db25maWciLCJjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYkNvbmZpZ1RvTWxkZXYiLCJjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImVtYmVkZGluZ3NCYXRjaEpvYlNvdXJjZVRvTWxkZXYiLCJkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2IiwiZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJkZWxldGVSZXNvdXJjZUpvYkZyb21NbGRldiIsImRlbGV0ZVJlc291cmNlSm9iRnJvbVZlcnRleCIsImVtYmVkQ29udGVudEJhdGNoVG9NbGRldiIsImZyb21Db250ZW50cyIsImVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYkMSIsImZyb21UYXNrVHlwZSIsImZyb21UaXRsZSIsImZyb21PdXRwdXREaW1lbnNpb25hbGl0eSIsImZpbGVEYXRhVG9NbGRldiQ0IiwiZnJvbUZpbGVVcmkiLCJmdW5jdGlvbkNhbGxUb01sZGV2JDQiLCJmcm9tSWQiLCJmcm9tQXJncyIsImZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMiIsImZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyIsImZyb21Nb2RlIiwiZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxIiwiZnJvbVN5c3RlbUluc3RydWN0aW9uIiwiZnJvbVRlbXBlcmF0dXJlIiwiZnJvbVRvcFAiLCJmcm9tVG9wSyIsImZyb21DYW5kaWRhdGVDb3VudCIsImZyb21NYXhPdXRwdXRUb2tlbnMiLCJmcm9tU3RvcFNlcXVlbmNlcyIsImZyb21SZXNwb25zZUxvZ3Byb2JzIiwiZnJvbUxvZ3Byb2JzIiwiZnJvbVByZXNlbmNlUGVuYWx0eSIsImZyb21GcmVxdWVuY3lQZW5hbHR5IiwiZnJvbVNlZWQiLCJmcm9tUmVzcG9uc2VNaW1lVHlwZSIsImZyb21SZXNwb25zZVNjaGVtYSIsImZyb21SZXNwb25zZUpzb25TY2hlbWEiLCJmcm9tU2FmZXR5U2V0dGluZ3MiLCJzYWZldHlTZXR0aW5nVG9NbGRldiQxIiwiZnJvbVRvb2xzIiwidG9vbFRvTWxkZXYkNCIsImZyb21Ub29sQ29uZmlnIiwidG9vbENvbmZpZ1RvTWxkZXYkMiIsImZyb21DYWNoZWRDb250ZW50IiwiZnJvbVJlc3BvbnNlTW9kYWxpdGllcyIsImZyb21NZWRpYVJlc29sdXRpb24iLCJmcm9tU3BlZWNoQ29uZmlnIiwiZnJvbVRoaW5raW5nQ29uZmlnIiwiZnJvbUltYWdlQ29uZmlnIiwiaW1hZ2VDb25maWdUb01sZGV2JDEiLCJmcm9tRW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMiLCJnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiQxIiwiZnJvbUNhbmRpZGF0ZXMiLCJmcm9tTW9kZWxWZXJzaW9uIiwiZnJvbVByb21wdEZlZWRiYWNrIiwiZnJvbVJlc3BvbnNlSWQiLCJmcm9tVXNhZ2VNZXRhZGF0YSIsImdldEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYiLCJnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImdvb2dsZU1hcHNUb01sZGV2JDQiLCJmcm9tRW5hYmxlV2lkZ2V0IiwiZ29vZ2xlU2VhcmNoVG9NbGRldiQ0IiwiZnJvbVRpbWVSYW5nZUZpbHRlciIsImZyb21Bc3BlY3RSYXRpbyIsImZyb21JbWFnZVNpemUiLCJsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldiIsImZyb21QYWdlU2l6ZSIsImZyb21QYWdlVG9rZW4iLCJsaXN0QmF0Y2hKb2JzQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRmlsdGVyIiwibGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21NbGRldiIsImZyb21OZXh0UGFnZVRva2VuIiwiZnJvbUJhdGNoSm9icyIsImxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCIsImZyb21FeGVjdXRhYmxlQ29kZSIsImZyb21GaWxlRGF0YSIsImZyb21GdW5jdGlvbkNhbGwiLCJmcm9tRnVuY3Rpb25SZXNwb25zZSIsImZyb21JbmxpbmVEYXRhIiwiZnJvbVRleHQiLCJmcm9tVGhvdWdodCIsImZyb21UaG91Z2h0U2lnbmF0dXJlIiwiZnJvbVZpZGVvTWV0YWRhdGEiLCJmcm9tQ2F0ZWdvcnkiLCJmcm9tVGhyZXNob2xkIiwiZnJvbVJldHJpZXZhbENvbmZpZyIsImZyb21GdW5jdGlvbkNhbGxpbmdDb25maWciLCJmcm9tQ29tcHV0ZXJVc2UiLCJmcm9tRmlsZVNlYXJjaCIsImZyb21Db2RlRXhlY3V0aW9uIiwiZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zIiwiZnJvbUdvb2dsZU1hcHMiLCJmcm9tR29vZ2xlU2VhcmNoIiwiZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCIsImZyb21VcmxDb250ZXh0IiwiUGFnZWRJdGVtIiwiUGFnZXIiLCJyZXF1ZXN0IiwicGFyYW1zIiwicGFnZUludGVybmFsIiwicGFyYW1zSW50ZXJuYWwiLCJyZXF1ZXN0SW50ZXJuYWwiLCJpbml0IiwibmFtZUludGVybmFsIiwic2RrSHR0cFJlc3BvbnNlSW50ZXJuYWwiLCJzZGtIdHRwUmVzcG9uc2UiLCJpZHhJbnRlcm5hbCIsInJlcXVlc3RQYXJhbXMiLCJwYWdlSW50ZXJuYWxTaXplIiwiaW5pdE5leHRQYWdlIiwicGFnZSIsInBhZ2VTaXplIiwicGFnZUxlbmd0aCIsImdldEl0ZW0iLCJpbmRleCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJuZXh0IiwiaGFzTmV4dFBhZ2UiLCJuZXh0UGFnZSIsImRvbmUiLCJyZXR1cm4iLCJCYXRjaGVzIiwibGlzdCIsIlBBR0VEX0lURU1fQkFUQ0hfSk9CUyIsIngiLCJsaXN0SW50ZXJuYWwiLCJjcmVhdGUiLCJmb3JtYXREZXN0aW5hdGlvbiIsImNyZWF0ZUludGVybmFsIiwiY3JlYXRlRW1iZWRkaW5ncyIsImNyZWF0ZUVtYmVkZGluZ3NJbnRlcm5hbCIsImNyZWF0ZUlubGluZWRHZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0IiwiYm9keSIsInVybFBhcmFtcyIsInBhdGgiLCJiYXRjaCIsImlucHV0Q29uZmlnIiwicmVxdWVzdHNXcmFwcGVyIiwicmVxdWVzdHMiLCJuZXdSZXF1ZXN0cyIsInJlcXVlc3REaWN0Iiwic3lzdGVtSW5zdHJ1Y3Rpb25WYWx1ZSIsInJlcXVlc3RDb250ZW50IiwiZ2V0R2NzVXJpIiwiZ2V0QmlncXVlcnlVcmkiLCJuZXdDb25maWciLCJ0aW1lc3RhbXBTdHIiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJkaXNwbGF5TmFtZSIsInF1ZXJ5UGFyYW1zIiwiSlNPTiIsInN0cmluZ2lmeSIsImh0dHBNZXRob2QiLCJhYm9ydFNpZ25hbCIsInRoZW4iLCJodHRwUmVzcG9uc2UiLCJyZXNwIiwiZ2V0IiwiY2FuY2VsIiwianNvblJlc3BvbnNlIiwidHlwZWRSZXNwIiwiZGVsZXRlIiwiYmxvYlRvTWxkZXYkMyIsImNvbnRlbnRUb01sZGV2JDMiLCJwYXJ0VG9NbGRldiQzIiwiY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYiLCJmcm9tVHRsIiwiZnJvbUV4cGlyZVRpbWUiLCJ0b29sVG9NbGRldiQzIiwidG9vbENvbmZpZ1RvTWxkZXYkMSIsImNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleCIsInRvb2xUb1ZlcnRleCQyIiwiZnJvbUttc0tleU5hbWUiLCJjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4IiwiZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwiZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgiLCJmaWxlRGF0YVRvTWxkZXYkMyIsImZ1bmN0aW9uQ2FsbFRvTWxkZXYkMyIsImZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMSIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQyIiwiZnJvbURlc2NyaXB0aW9uIiwiZnJvbVBhcmFtZXRlcnMiLCJmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEiLCJnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4IiwiZ29vZ2xlTWFwc1RvTWxkZXYkMyIsImdvb2dsZVNlYXJjaFRvTWxkZXYkMyIsImxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvTWxkZXYiLCJsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleCIsImxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tQ2FjaGVkQ29udGVudHMiLCJsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgiLCJmcm9tUmV0cmlldmFsIiwiZnJvbUVudGVycHJpc2VXZWJTZWFyY2giLCJ1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldiIsInVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleCIsInVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsInVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJDYWNoZXMiLCJQQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UUyIsInVwZGF0ZSIsIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fdmFsdWVzIiwibyIsIml0ZXJhdG9yIiwibSIsIl9fYXdhaXQiLCJfX2FzeW5jR2VuZXJhdG9yIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJnZW5lcmF0b3IiLCJnIiwiYXBwbHkiLCJxIiwiQXN5bmNJdGVyYXRvciIsInZlcmIiLCJhd2FpdFJldHVybiIsImYiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm4iLCJhIiwiYiIsInJlc3VtZSIsInN0ZXAiLCJzZXR0bGUiLCJyIiwiZnVsZmlsbCIsInNoaWZ0IiwiX19hc3luY1ZhbHVlcyIsIlN1cHByZXNzZWRFcnJvciIsInN1cHByZXNzZWQiLCJtZXNzYWdlIiwiaXNWYWxpZFJlc3BvbnNlIiwiaXNWYWxpZENvbnRlbnQiLCJ2YWxpZGF0ZUhpc3RvcnkiLCJoaXN0b3J5IiwiZXh0cmFjdEN1cmF0ZWRIaXN0b3J5IiwiY29tcHJlaGVuc2l2ZUhpc3RvcnkiLCJjdXJhdGVkSGlzdG9yeSIsIm1vZGVsT3V0cHV0IiwiaXNWYWxpZCIsIkNoYXRzIiwibW9kZWxzTW9kdWxlIiwiQ2hhdCIsInN0cnVjdHVyZWRDbG9uZSIsInNlbmRQcm9taXNlIiwic2VuZE1lc3NhZ2UiLCJpbnB1dENvbnRlbnQiLCJyZXNwb25zZVByb21pc2UiLCJnZW5lcmF0ZUNvbnRlbnQiLCJjb250ZW50cyIsImdldEhpc3RvcnkiLCJjb25jYXQiLCJvdXRwdXRDb250ZW50IiwiZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkiLCJhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5IiwicmVjb3JkSGlzdG9yeSIsImNhdGNoIiwic2VuZE1lc3NhZ2VTdHJlYW0iLCJzdHJlYW1SZXNwb25zZSIsImdlbmVyYXRlQ29udGVudFN0cmVhbSIsInByb2Nlc3NTdHJlYW1SZXNwb25zZSIsImN1cmF0ZWQiLCJhcmd1bWVudHMiLCJwcm9jZXNzU3RyZWFtUmVzcG9uc2VfMSIsImVfMSIsInN0cmVhbVJlc3BvbnNlXzEiLCJzdHJlYW1SZXNwb25zZV8xXzEiLCJjaHVuayIsImVfMV8xIiwidXNlcklucHV0Iiwib3V0cHV0Q29udGVudHMiLCJldmVyeSIsIkFwaUVycm9yIiwib3B0aW9ucyIsInNldFByb3RvdHlwZU9mIiwiY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbUZpbGUiLCJjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYiLCJkZWxldGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYiLCJkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYiLCJnZXRGaWxlUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0RmlsZXNDb25maWdUb01sZGV2IiwibGlzdEZpbGVzUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0RmlsZXNSZXNwb25zZUZyb21NbGRldiIsImZyb21GaWxlcyIsIkZpbGVzIiwiUEFHRURfSVRFTV9GSUxFUyIsInVwbG9hZCIsInVwbG9hZEZpbGUiLCJmaWxlIiwiZG93bmxvYWQiLCJkb3dubG9hZEZpbGUiLCJibG9iVG9NbGRldiQyIiwiY29udGVudFRvTWxkZXYkMiIsInBhcnRUb01sZGV2JDIiLCJmaWxlRGF0YVRvTWxkZXYkMiIsImZ1bmN0aW9uQ2FsbFRvTWxkZXYkMiIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxIiwiZ2VuZXJhdGlvbkNvbmZpZ1RvVmVydGV4JDEiLCJmcm9tTW9kZWxTZWxlY3Rpb25Db25maWciLCJmcm9tQXVkaW9UaW1lc3RhbXAiLCJmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nIiwiZnJvbVJvdXRpbmdDb25maWciLCJnb29nbGVNYXBzVG9NbGRldiQyIiwiZ29vZ2xlU2VhcmNoVG9NbGRldiQyIiwibGl2ZUNvbm5lY3RDb25maWdUb01sZGV2JDEiLCJmcm9tR2VuZXJhdGlvbkNvbmZpZyIsInRvb2xUb01sZGV2JDIiLCJmcm9tU2Vzc2lvblJlc3VtcHRpb24iLCJzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYkMSIsImZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiIsImZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24iLCJmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyIsImZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24iLCJmcm9tUHJvYWN0aXZpdHkiLCJsaXZlQ29ubmVjdENvbmZpZ1RvVmVydGV4IiwidG9vbFRvVmVydGV4JDEiLCJmcm9tRXhwbGljaXRWYWRTaWduYWwiLCJsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb01sZGV2IiwibGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXZlTXVzaWNTZXRDb25maWdQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21NdXNpY0dlbmVyYXRpb25Db25maWciLCJsaXZlTXVzaWNTZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21XZWlnaHRlZFByb21wdHMiLCJsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21NZWRpYSIsImZyb21BdWRpbyIsImZyb21BdWRpb1N0cmVhbUVuZCIsImZyb21BY3Rpdml0eVN0YXJ0IiwiZnJvbUFjdGl2aXR5RW5kIiwibGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvVmVydGV4IiwibGl2ZVNlcnZlck1lc3NhZ2VGcm9tVmVydGV4IiwiZnJvbVNldHVwQ29tcGxldGUiLCJmcm9tU2VydmVyQ29udGVudCIsImZyb21Ub29sQ2FsbCIsImZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiIsInVzYWdlTWV0YWRhdGFGcm9tVmVydGV4IiwiZnJvbUdvQXdheSIsImZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSIsImZyb21Wb2ljZUFjdGl2aXR5RGV0ZWN0aW9uU2lnbmFsIiwiZnJvbUhhbmRsZSIsImZyb21Qcm9tcHRUb2tlbkNvdW50IiwiZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50IiwiZnJvbVJlc3BvbnNlVG9rZW5Db3VudCIsImZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCIsImZyb21UaG91Z2h0c1Rva2VuQ291bnQiLCJmcm9tVG90YWxUb2tlbkNvdW50IiwiZnJvbVByb21wdFRva2Vuc0RldGFpbHMiLCJmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzIiwiZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyIsImZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyIsImZyb21UcmFmZmljVHlwZSIsImJsb2JUb01sZGV2JDEiLCJjYW5kaWRhdGVGcm9tTWxkZXYiLCJjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2IiwiY29tcHV0ZVRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCIsImNvbXB1dGVUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJmcm9tVG9rZW5zSW5mbyIsImNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4IiwiZnJvbVZhbHVlcyIsImZyb21TdGF0aXN0aWNzIiwiY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4IiwiZnJvbVRydW5jYXRlZCIsImNvbnRlbnRUb01sZGV2JDEiLCJwYXJ0VG9NbGRldiQxIiwiY29udHJvbFJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4IiwiZnJvbUNvbnRyb2xUeXBlIiwiZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uIiwiY291bnRUb2tlbnNDb25maWdUb01sZGV2IiwiY291bnRUb2tlbnNDb25maWdUb1ZlcnRleCIsInRvb2xUb1ZlcnRleCIsImdlbmVyYXRpb25Db25maWdUb1ZlcnRleCIsImNvdW50VG9rZW5zUGFyYW1ldGVyc1RvTWxkZXYiLCJjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCIsImNvdW50VG9rZW5zUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tVG90YWxUb2tlbnMiLCJjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleCIsImRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYiLCJkZWxldGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCIsImRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tTWxkZXYiLCJkZWxldGVNb2RlbFJlc3BvbnNlRnJvbVZlcnRleCIsImVkaXRJbWFnZUNvbmZpZ1RvVmVydGV4IiwiZnJvbU91dHB1dEdjc1VyaSIsImZyb21OZWdhdGl2ZVByb21wdCIsImZyb21OdW1iZXJPZkltYWdlcyIsImZyb21HdWlkYW5jZVNjYWxlIiwiZnJvbVNhZmV0eUZpbHRlckxldmVsIiwiZnJvbVBlcnNvbkdlbmVyYXRpb24iLCJmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMiLCJmcm9tSW5jbHVkZVJhaVJlYXNvbiIsImZyb21MYW5ndWFnZSIsImZyb21PdXRwdXRNaW1lVHlwZSIsImZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkiLCJmcm9tQWRkV2F0ZXJtYXJrIiwiZnJvbUxhYmVscyIsImZyb21FZGl0TW9kZSIsImZyb21CYXNlU3RlcHMiLCJlZGl0SW1hZ2VQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleCIsImZyb21Qcm9tcHQiLCJmcm9tUmVmZXJlbmNlSW1hZ2VzIiwicmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbFRvVmVydGV4IiwiZWRpdEltYWdlUmVzcG9uc2VGcm9tVmVydGV4IiwiZnJvbUdlbmVyYXRlZEltYWdlcyIsImdlbmVyYXRlZEltYWdlRnJvbVZlcnRleCIsImVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYiLCJlbWJlZENvbnRlbnRDb25maWdUb1ZlcnRleCIsImZyb21BdXRvVHJ1bmNhdGUiLCJlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21Nb2RlbEZvckVtYmVkQ29udGVudCIsImVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbUVtYmVkZGluZ3MiLCJlbWJlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgiLCJlbmRwb2ludEZyb21WZXJ0ZXgiLCJmcm9tRGVwbG95ZWRNb2RlbElkIiwiZmlsZURhdGFUb01sZGV2JDEiLCJmdW5jdGlvbkNhbGxUb01sZGV2JDEiLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2IiwiZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4IiwiZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiIsInNhZmV0eVNldHRpbmdUb01sZGV2IiwidG9vbFRvTWxkZXYkMSIsInRvb2xDb25maWdUb01sZGV2IiwiaW1hZ2VDb25maWdUb01sZGV2IiwiZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9WZXJ0ZXgiLCJpbWFnZUNvbmZpZ1RvVmVydGV4IiwiZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldiIsImdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRW5oYW5jZVByb21wdCIsImdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYiLCJnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb1ZlcnRleCIsImdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYiLCJnZW5lcmF0ZWRJbWFnZUZyb21NbGRldiIsImZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMiLCJzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2IiwiZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgiLCJzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldiIsImZyb21OdW1iZXJPZlZpZGVvcyIsImZyb21EdXJhdGlvblNlY29uZHMiLCJmcm9tUmVzb2x1dGlvbiIsImZyb21MYXN0RnJhbWUiLCJpbWFnZVRvTWxkZXYiLCJ2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvTWxkZXYiLCJnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4IiwiZnJvbUZwcyIsImZyb21QdWJzdWJUb3BpYyIsImZyb21HZW5lcmF0ZUF1ZGlvIiwiaW1hZ2VUb1ZlcnRleCIsInZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgiLCJmcm9tTWFzayIsInZpZGVvR2VuZXJhdGlvbk1hc2tUb1ZlcnRleCIsImZyb21Db21wcmVzc2lvblF1YWxpdHkiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgiLCJnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tSW1hZ2UiLCJ2aWRlb1RvTWxkZXYiLCJmcm9tU291cmNlIiwiZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb01sZGV2IiwiZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ2aWRlb1RvVmVydGV4IiwiZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb1ZlcnRleCIsImdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2IiwiZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4IiwiaW1hZ2VGcm9tTWxkZXYiLCJmcm9tUmFpRmlsdGVyZWRSZWFzb24iLCJmcm9tU2FmZXR5QXR0cmlidXRlcyIsImltYWdlRnJvbVZlcnRleCIsImZyb21FbmhhbmNlZFByb21wdCIsImdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgiLCJ2aWRlb0Zyb21NbGRldiIsInZpZGVvRnJvbVZlcnRleCIsImdldE1vZGVsUGFyYW1ldGVyc1RvTWxkZXYiLCJnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCIsImdvb2dsZU1hcHNUb01sZGV2JDEiLCJnb29nbGVTZWFyY2hUb01sZGV2JDEiLCJsaXN0TW9kZWxzQ29uZmlnVG9NbGRldiIsImZyb21RdWVyeUJhc2UiLCJsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgiLCJsaXN0TW9kZWxzUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0TW9kZWxzUGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdE1vZGVsc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbU1vZGVscyIsIm1vZGVsRnJvbU1sZGV2IiwibGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleCIsIm1vZGVsRnJvbVZlcnRleCIsIm1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21NYXNrTW9kZSIsImZyb21TZWdtZW50YXRpb25DbGFzc2VzIiwiZnJvbU1hc2tEaWxhdGlvbiIsImZyb21WZXJzaW9uIiwiZnJvbVR1bmVkTW9kZWxJbmZvIiwidHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYiLCJmcm9tSW5wdXRUb2tlbkxpbWl0IiwiZnJvbU91dHB1dFRva2VuTGltaXQiLCJmcm9tU3VwcG9ydGVkQWN0aW9ucyIsImZyb21NYXhUZW1wZXJhdHVyZSIsImZyb21UaGlua2luZyIsImZyb21FbmRwb2ludHMiLCJ0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgiLCJmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCIsImZyb21DaGVja3BvaW50cyIsInByb2R1Y3RJbWFnZVRvVmVydGV4IiwiZnJvbVByb2R1Y3RJbWFnZSIsInJlY29udGV4dEltYWdlQ29uZmlnVG9WZXJ0ZXgiLCJyZWNvbnRleHRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleCIsInJlY29udGV4dEltYWdlU291cmNlVG9WZXJ0ZXgiLCJyZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21QZXJzb25JbWFnZSIsImZyb21Qcm9kdWN0SW1hZ2VzIiwiZnJvbVJlZmVyZW5jZUltYWdlIiwiZnJvbVJlZmVyZW5jZUlkIiwiZnJvbVJlZmVyZW5jZVR5cGUiLCJmcm9tTWFza0ltYWdlQ29uZmlnIiwiZnJvbUNvbnRyb2xJbWFnZUNvbmZpZyIsImZyb21TdHlsZUltYWdlQ29uZmlnIiwiZnJvbVN1YmplY3RJbWFnZUNvbmZpZyIsImZyb21DYXRlZ29yaWVzIiwiZnJvbVNjb3JlcyIsImZyb21Db250ZW50VHlwZSIsInNjcmliYmxlSW1hZ2VUb1ZlcnRleCIsInNlZ21lbnRJbWFnZUNvbmZpZ1RvVmVydGV4IiwiZnJvbU1heFByZWRpY3Rpb25zIiwiZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQiLCJmcm9tQmluYXJ5Q29sb3JUaHJlc2hvbGQiLCJzZWdtZW50SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleCIsInNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21HZW5lcmF0ZWRNYXNrcyIsImZyb21TY3JpYmJsZUltYWdlIiwiZnJvbUJhc2VNb2RlbCIsInVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldiIsInVwZGF0ZU1vZGVsQ29uZmlnVG9WZXJ0ZXgiLCJ1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2IiwidXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ1cHNjYWxlSW1hZ2VBUElDb25maWdJbnRlcm5hbFRvVmVydGV4IiwiZnJvbUVuaGFuY2VJbnB1dEltYWdlIiwiZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yIiwidXBzY2FsZUltYWdlQVBJUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgiLCJmcm9tVXBzY2FsZUZhY3RvciIsInVwc2NhbGVJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImNyZWF0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYiLCJjcmVhdGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldiIsImRlbGV0ZUZpbGVTZWFyY2hTdG9yZUNvbmZpZ1RvTWxkZXYiLCJmcm9tRm9yY2UiLCJkZWxldGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldiIsImdldEZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2IiwiaW1wb3J0RmlsZUNvbmZpZ1RvTWxkZXYiLCJmcm9tQ3VzdG9tTWV0YWRhdGEiLCJmcm9tQ2h1bmtpbmdDb25maWciLCJpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2IiwiaW1wb3J0RmlsZVJlc3BvbnNlRnJvbU1sZGV2IiwiaW1wb3J0RmlsZVBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbUZpbGVTZWFyY2hTdG9yZU5hbWUiLCJsaXN0RmlsZVNlYXJjaFN0b3Jlc0NvbmZpZ1RvTWxkZXYiLCJsaXN0RmlsZVNlYXJjaFN0b3Jlc1BhcmFtZXRlcnNUb01sZGV2IiwibGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZUZyb21NbGRldiIsImZyb21GaWxlU2VhcmNoU3RvcmVzIiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2IiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldiIsInVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2VGcm9tTWxkZXYiLCJDT05URU5UX1RZUEVfSEVBREVSIiwiU0VSVkVSX1RJTUVPVVRfSEVBREVSIiwiVVNFUl9BR0VOVF9IRUFERVIiLCJHT09HTEVfQVBJX0NMSUVOVF9IRUFERVIiLCJTREtfVkVSU0lPTiIsIkxJQlJBUllfTEFCRUwiLCJWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiIsIkdPT0dMRV9BSV9BUElfREVGQVVMVF9WRVJTSU9OIiwiQXBpQ2xpZW50Iiwib3B0cyIsImNsaWVudE9wdGlvbnMiLCJwcm9qZWN0IiwibG9jYXRpb24iLCJhcGlLZXkiLCJpbml0SHR0cE9wdGlvbnMiLCJhcGlWZXJzaW9uIiwiYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24iLCJub3JtYWxpemVBdXRoUGFyYW1ldGVycyIsImdldERlZmF1bHRIZWFkZXJzIiwicGF0Y2hIdHRwT3B0aW9ucyIsImdldEF1dGhIZWFkZXJzIiwiSGVhZGVycyIsImF1dGgiLCJhZGRBdXRoSGVhZGVycyIsImdldEFwaVZlcnNpb24iLCJnZXRSZXF1ZXN0VXJsIiwiZ2V0UmVxdWVzdFVybEludGVybmFsIiwiZ2V0SGVhZGVycyIsInVybEVsZW1lbnQiLCJqb2luIiwiZ2V0QmFzZVJlc291cmNlUGF0aCIsImdldEFwaUtleSIsImdldFdlYnNvY2tldEJhc2VVcmwiLCJ1cmxQYXJ0cyIsIlVSTCIsInByb3RvY29sIiwic2V0QmFzZVVybCIsInVybCIsImNvbnN0cnVjdFVybCIsInByZXBlbmRQcm9qZWN0TG9jYXRpb24iLCJzaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgiLCJwYXRjaGVkSHR0cE9wdGlvbnMiLCJzZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJyZXF1ZXN0SW5pdCIsImluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdCIsInVuYXJ5QXBpQ2FsbCIsImJhc2VIdHRwT3B0aW9ucyIsInJlcXVlc3RIdHRwT3B0aW9ucyIsInBhcnNlIiwicmVxdWVzdFN0cmVhbSIsInNldCIsInN0cmVhbUFwaUNhbGwiLCJ0aW1lb3V0IiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2lnbmFsIiwidGltZW91dEhhbmRsZSIsInNldFRpbWVvdXQiLCJhYm9ydCIsInVucmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV4dHJhQm9keSIsImluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0IiwiZ2V0SGVhZGVyc0ludGVybmFsIiwiYXBpQ2FsbCIsIm1ldGhvZCIsInRocm93RXJyb3JJZk5vdE9LIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYnVmZmVyIiwiZGF0YVByZWZpeCIsImRlbGltaXRlcnMiLCJyZWFkIiwidHJpbSIsImNodW5rU3RyaW5nIiwiZGVjb2RlIiwic3RyZWFtIiwiY2h1bmtKc29uIiwiZXJyb3JKc29uIiwiZXJyb3JNZXNzYWdlIiwiYXBpRXJyb3IiLCJkZWxpbWl0ZXJJbmRleCIsImRlbGltaXRlckxlbmd0aCIsImRlbGltaXRlciIsImV2ZW50U3RyaW5nIiwic3Vic3RyaW5nIiwidHJpbW1lZEV2ZW50IiwicHJvY2Vzc2VkQ2h1bmtTdHJpbmciLCJwYXJ0aWFsUmVzcG9uc2UiLCJSZXNwb25zZSIsInN0YXR1c1RleHQiLCJyZWxlYXNlTG9jayIsImZldGNoIiwidmVyc2lvbkhlYWRlclZhbHVlIiwidXNlckFnZW50RXh0cmEiLCJNYXRoIiwiY2VpbCIsImdldEZpbGVOYW1lIiwiZmlsZVRvVXBsb2FkIiwidXBsb2FkZXIiLCJmaWxlU3RhdCIsInN0YXQiLCJzaXplQnl0ZXMiLCJzaXplIiwidXBsb2FkVXJsIiwiZmV0Y2hVcGxvYWRVcmwiLCJ1cGxvYWRGaWxlVG9GaWxlU2VhcmNoU3RvcmUiLCJmaWxlU2VhcmNoU3RvcmVOYW1lIiwidXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUiLCJkb3dubG9hZGVyIiwiY29uZmlnSHR0cE9wdGlvbnMiLCJvayIsImVycm9yQm9keSIsIkJsb2IiLCJjdXJyZW50Qm9keU9iamVjdCIsInBhcnNlZEJvZHkiLCJkZWVwTWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJzb3VyY2VWYWx1ZSIsInRhcmdldFZhbHVlIiwibWVyZ2VkQm9keSIsIk1DUF9MQUJFTCIsImhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2wiLCJoYXNNY3BUb29sVXNhZ2UiLCJpc01jcENhbGxhYmxlVG9vbCIsInNldE1jcFVzYWdlSGVhZGVyIiwiZXhpc3RpbmdIZWFkZXIiLCJ0cmltU3RhcnQiLCJvYmplY3QiLCJNY3BDYWxsYWJsZVRvb2wiLCJsaXN0QWxsVG9vbHMiLCJtY3BDbGllbnRfMSIsImxpc3RBbGxUb29sc18xIiwibWNwQ2xpZW50IiwibWF4VG9vbHMiLCJjdXJzb3IiLCJudW1Ub29scyIsImxpc3RUb29scyIsIm5leHRDdXJzb3IiLCJtY3BDbGllbnRzIiwiZnVuY3Rpb25OYW1lVG9NY3BDbGllbnQiLCJpbml0aWFsaXplIiwiZnVuY3Rpb25NYXAiLCJjYWxsVG9vbCIsImZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMiLCJyZXF1ZXN0T3B0aW9ucyIsImNhbGxUb29sUmVzcG9uc2UiLCJpc0Vycm9yIiwiaXNNY3BDbGllbnQiLCJtY3BUb1Rvb2wiLCJtYXliZUNvbmZpZyIsImhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMSIsIm9ubWVzc2FnZSIsImV2ZW50Iiwic2VydmVyTWVzc2FnZSIsIkxpdmVNdXNpYyIsIndlYlNvY2tldEZhY3RvcnkiLCJjb25uZWN0Iiwid2Vic29ja2V0QmFzZVVybCIsIm1hcFRvSGVhZGVycyQxIiwib25vcGVuUmVzb2x2ZSIsIm9ub3BlblByb21pc2UiLCJjYWxsYmFja3MiLCJvbm9wZW5Bd2FpdGVkQ2FsbGJhY2siLCJ3ZWJzb2NrZXRDYWxsYmFja3MiLCJvbm9wZW4iLCJvbmVycm9yIiwib25jbG9zZSIsImNvbm4iLCJoZWFkZXJzVG9NYXAkMSIsInNldHVwIiwiY2xpZW50TWVzc2FnZSIsInNlbmQiLCJMaXZlTXVzaWNTZXNzaW9uIiwic2V0V2VpZ2h0ZWRQcm9tcHRzIiwid2VpZ2h0ZWRQcm9tcHRzIiwiY2xpZW50Q29udGVudCIsInNldE11c2ljR2VuZXJhdGlvbkNvbmZpZyIsIm11c2ljR2VuZXJhdGlvbkNvbmZpZyIsInNldENvbmZpZ1BhcmFtZXRlcnMiLCJzZW5kUGxheWJhY2tDb250cm9sIiwicGxheWJhY2tDb250cm9sIiwicGxheSIsIlBMQVkiLCJwYXVzZSIsIlBBVVNFIiwic3RvcCIsIlNUT1AiLCJyZXNldENvbnRleHQiLCJSRVNFVF9DT05URVhUIiwiY2xvc2UiLCJoZWFkZXJNYXAiLCJmb3JFYWNoIiwiRlVOQ1RJT05fUkVTUE9OU0VfUkVRVUlSRVNfSUQiLCJoYW5kbGVXZWJTb2NrZXRNZXNzYWdlIiwianNvbkRhdGEiLCJBcnJheUJ1ZmZlciIsIkxpdmUiLCJtdXNpYyIsImNsaWVudEhlYWRlcnMiLCJtYXBUb0hlYWRlcnMiLCJoZWFkZXJzVG9NYXAiLCJyZXNwb25zZU1vZGFsaXRpZXMiLCJBVURJTyIsImdlbmVyYXRpb25Db25maWciLCJpbnB1dFRvb2xzIiwiY29udmVydGVkVG9vbHMiLCJpc0NhbGxhYmxlVG9vbCIsImNhbGxhYmxlVG9vbCIsImxpdmVDb25uZWN0UGFyYW1ldGVycyIsIlNlc3Npb24iLCJkZWZhdWx0TGl2ZVNlbmRDbGllbnRDb250ZW50UGFyYW1lcnRlcnMiLCJ0dXJuQ29tcGxldGUiLCJ0TGl2ZUNsaWVudENvbnRlbnQiLCJ0dXJucyIsInRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZSIsInRvb2xSZXNwb25zZSIsInNlbmRDbGllbnRDb250ZW50Iiwic2VuZFJlYWx0aW1lSW5wdXQiLCJzZW5kVG9vbFJlc3BvbnNlIiwiREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTIiwic2hvdWxkRGlzYWJsZUFmYyIsImF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZyIsImRpc2FibGUiLCJjYWxsYWJsZVRvb2xzUHJlc2VudCIsIm1heENhbGxzIiwibWF4aW11bVJlbW90ZUNhbGxzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaGFzQ2FsbGFibGVUb29scyIsInNvbWUiLCJmaW5kQWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMiLCJhZmNJbmNvbXBhdGlibGVUb29sSW5kZXhlcyIsInNob3VsZEFwcGVuZEFmY0hpc3RvcnkiLCJpZ25vcmVDYWxsSGlzdG9yeSIsIk1vZGVscyIsInRyYW5zZm9ybWVkUGFyYW1zIiwicHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UiLCJtYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtIiwiZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwiLCJpbmNvbXBhdGlibGVUb29sSW5kZXhlcyIsImZvcm1hdHRlZEluZGV4ZXMiLCJmdW5jdGlvblJlc3BvbnNlQ29udGVudCIsIm1heFJlbW90ZUNhbGxzIiwicmVtb3RlQ2FsbHMiLCJyZXNwb25zZUNvbnRlbnQiLCJmdW5jdGlvblJlc3BvbnNlUGFydHMiLCJnZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbCIsInN0cmVhbUZ1bmN0aW9uQ2FsbCIsInRvb2xDb25maWciLCJmdW5jdGlvbkNhbGxpbmdDb25maWciLCJzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMiLCJkaXNhYmxlQWZjIiwicHJvY2Vzc0FmY1N0cmVhbSIsImdlbmVyYXRlSW1hZ2VzIiwiZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbCIsInBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyIsImdlbmVyYXRlZEltYWdlcyIsImdlbmVyYXRlZEltYWdlIiwic2FmZXR5QXR0cmlidXRlcyIsImNvbnRlbnRUeXBlIiwiZGVmYXVsdENvbmZpZyIsInF1ZXJ5QmFzZSIsImFjdHVhbENvbmZpZyIsImFjdHVhbFBhcmFtcyIsIlBBR0VEX0lURU1fTU9ERUxTIiwiZWRpdEltYWdlIiwicHJvbXB0IiwicmVmZXJlbmNlSW1hZ2VzIiwiaW1nIiwiZWRpdEltYWdlSW50ZXJuYWwiLCJ1cHNjYWxlSW1hZ2UiLCJhcGlDb25maWciLCJudW1iZXJPZkltYWdlcyIsIm1vZGUiLCJhcGlQYXJhbXMiLCJpbWFnZSIsInVwc2NhbGVGYWN0b3IiLCJ1cHNjYWxlSW1hZ2VJbnRlcm5hbCIsImdlbmVyYXRlVmlkZW9zIiwidmlkZW9CeXRlcyIsImdlbmVyYXRlVmlkZW9zSW50ZXJuYWwiLCJyZXNwb25zZVNjaGVtYSIsInRyYW5zZm9ybWVkVG9vbHMiLCJhbGwiLCJuZXdQYXJhbXMiLCJuZXdIZWFkZXJzIiwiaW5pdEFmY1Rvb2xzTWFwIiwiYWZjVG9vbHMiLCJNYXAiLCJ0b29sRGVjbGFyYXRpb24iLCJkZWNsYXJhdGlvbiIsIndlcmVGdW5jdGlvbnNDYWxsZWQiLCJyZW1vdGVDYWxsQ291bnQiLCJhZmNUb29sc01hcCIsIm1vZGVscyIsInJlc3BvbnNlQ29udGVudHMiLCJyZXNwb25zZV8xIiwicmVzcG9uc2VfMV8xIiwicmVzcG9uc2VQYXJ0cyIsInR5cGVkUmVzcG9uc2VDaHVuayIsIm5ld0NvbnRlbnRzIiwidXBkYXRlZENvbnRlbnRzIiwiZV8yIiwiYXBpUmVzcG9uc2VfMSIsImFwaVJlc3BvbnNlXzFfMSIsImVfMl8xIiwiZV8zIiwiYXBpUmVzcG9uc2VfMiIsImFwaVJlc3BvbnNlXzJfMSIsImVfM18xIiwiZW1iZWRDb250ZW50IiwicmVjb250ZXh0SW1hZ2UiLCJzZWdtZW50SW1hZ2UiLCJjb3VudFRva2VucyIsImNvbXB1dGVUb2tlbnMiLCJPcGVyYXRpb25zIiwiZ2V0VmlkZW9zT3BlcmF0aW9uIiwicmF3T3BlcmF0aW9uIiwiZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwiLCJvcGVyYXRpb25OYW1lIiwiZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwiLCJibG9iVG9NbGRldiIsImNvbnRlbnRUb01sZGV2IiwicGFydFRvTWxkZXYiLCJjcmVhdGVBdXRoVG9rZW5Db25maWdUb01sZGV2IiwiZnJvbU5ld1Nlc3Npb25FeHBpcmVUaW1lIiwiZnJvbVVzZXMiLCJmcm9tTGl2ZUNvbm5lY3RDb25zdHJhaW50cyIsImxpdmVDb25uZWN0Q29uc3RyYWludHNUb01sZGV2IiwiZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzIiwiY3JlYXRlQXV0aFRva2VuUGFyYW1ldGVyc1RvTWxkZXYiLCJmaWxlRGF0YVRvTWxkZXYiLCJmdW5jdGlvbkNhbGxUb01sZGV2IiwiZ29vZ2xlTWFwc1RvTWxkZXYiLCJnb29nbGVTZWFyY2hUb01sZGV2IiwibGl2ZUNvbm5lY3RDb25maWdUb01sZGV2IiwidG9vbFRvTWxkZXYiLCJzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYiLCJnZXRGaWVsZE1hc2tzIiwiZmllbGRzIiwiZmllbGQiLCJrayIsImNvbnZlcnRCaWRpU2V0dXBUb1Rva2VuU2V0dXAiLCJzZXR1cEZvck1hc2tHZW5lcmF0aW9uIiwiYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUiLCJpbm5lclNldHVwIiwicHJlRXhpc3RpbmdGaWVsZE1hc2siLCJnZW5lcmF0ZWRNYXNrRnJvbUJpZGkiLCJsb2NrQWRkaXRpb25hbEZpZWxkcyIsImdlbmVyYXRpb25Db25maWdGaWVsZHMiLCJtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmciLCJmaW5hbE1hc2tQYXJ0cyIsIlRva2VucyIsInRyYW5zZm9ybWVkQm9keSIsImRlbGV0ZURvY3VtZW50Q29uZmlnVG9NbGRldiIsImRlbGV0ZURvY3VtZW50UGFyYW1ldGVyc1RvTWxkZXYiLCJnZXREb2N1bWVudFBhcmFtZXRlcnNUb01sZGV2IiwibGlzdERvY3VtZW50c0NvbmZpZ1RvTWxkZXYiLCJsaXN0RG9jdW1lbnRzUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0RG9jdW1lbnRzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tRG9jdW1lbnRzIiwiRG9jdW1lbnRzIiwiUEFHRURfSVRFTV9ET0NVTUVOVFMiLCJwYXJlbnQiLCJGaWxlU2VhcmNoU3RvcmVzIiwiZG9jdW1lbnRzIiwiUEFHRURfSVRFTV9GSUxFX1NFQVJDSF9TVE9SRVMiLCJ1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZUludGVybmFsIiwiaW1wb3J0RmlsZSIsInV1aWQ0SW50ZXJuYWwiLCJjcnlwdG8iLCJnbG9iYWxUaGlzIiwicmFuZG9tVVVJRCIsImJpbmQiLCJ1OCIsIlVpbnQ4QXJyYXkiLCJyYW5kb21CeXRlIiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tIiwiYyIsInV1aWQ0IiwiaXNBYm9ydEVycm9yIiwiZXJyIiwiY2FzdFRvRXJyb3IiLCJjYXVzZSIsInN0YWNrIiwiR2VtaW5pTmV4dEdlbkFQSUNsaWVudEVycm9yIiwiQVBJRXJyb3IiLCJtYWtlTWVzc2FnZSIsIm1zZyIsImdlbmVyYXRlIiwiZXJyb3JSZXNwb25zZSIsIkFQSUNvbm5lY3Rpb25FcnJvciIsIkJhZFJlcXVlc3RFcnJvciIsIkF1dGhlbnRpY2F0aW9uRXJyb3IiLCJQZXJtaXNzaW9uRGVuaWVkRXJyb3IiLCJOb3RGb3VuZEVycm9yIiwiQ29uZmxpY3RFcnJvciIsIlVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciIsIlJhdGVMaW1pdEVycm9yIiwiSW50ZXJuYWxTZXJ2ZXJFcnJvciIsIkFQSVVzZXJBYm9ydEVycm9yIiwiQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciIsInN0YXJ0c1dpdGhTY2hlbWVSZWdleHAiLCJpc0Fic29sdXRlVVJMIiwiaXNBcnJheUludGVybmFsIiwidmFsIiwiaXNSZWFkb25seUFycmF5SW50ZXJuYWwiLCJpc1JlYWRvbmx5QXJyYXkiLCJpc0VtcHR5T2JqIiwiX2siLCJoYXNPd24iLCJ2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlciIsInNhZmVKU09OIiwic2xlZXAkMSIsIm1zIiwiVkVSU0lPTiIsImdldERldGVjdGVkUGxhdGZvcm0iLCJEZW5vIiwiYnVpbGQiLCJFZGdlUnVudGltZSIsInByb2Nlc3MiLCJnZXRQbGF0Zm9ybVByb3BlcnRpZXMiLCJkZXRlY3RlZFBsYXRmb3JtIiwibm9ybWFsaXplUGxhdGZvcm0iLCJvcyIsIm5vcm1hbGl6ZUFyY2giLCJhcmNoIiwidmVyc2lvbiIsImRlbm8iLCJwbGF0Zm9ybSIsImJyb3dzZXJJbmZvIiwiZ2V0QnJvd3NlckluZm8iLCJicm93c2VyIiwibmF2aWdhdG9yIiwiYnJvd3NlclBhdHRlcm5zIiwicGF0dGVybiIsImV4ZWMiLCJ1c2VyQWdlbnQiLCJtYWpvciIsIm1pbm9yIiwicGF0Y2giLCJ0b0xvd2VyQ2FzZSIsIl9wbGF0Zm9ybUhlYWRlcnMiLCJnZXRQbGF0Zm9ybUhlYWRlcnMiLCJnZXREZWZhdWx0RmV0Y2giLCJtYWtlUmVhZGFibGVTdHJlYW0iLCJSZWFkYWJsZVN0cmVhbSIsIlJlYWRhYmxlU3RyZWFtRnJvbSIsIml0ZXJhYmxlIiwiaXRlciIsInN0YXJ0IiwicHVsbCIsImNvbnRyb2xsZXIiLCJlbnF1ZXVlIiwiUmVhZGFibGVTdHJlYW1Ub0FzeW5jSXRlcmFibGUiLCJjYW5jZWxQcm9taXNlIiwiQ2FuY2VsUmVhZGFibGVTdHJlYW0iLCJGYWxsYmFja0VuY29kZXIiLCJib2R5SGVhZGVycyIsImNoZWNrRmlsZVN1cHBvcnQiLCJGaWxlIiwiaXNPbGROb2RlIiwidmVyc2lvbnMiLCJub2RlIiwicGFyc2VJbnQiLCJtYWtlRmlsZSIsImZpbGVCaXRzIiwiZ2V0TmFtZSIsImZpbGVuYW1lIiwiaXNBc3luY0l0ZXJhYmxlIiwiaXNCbG9iTGlrZSIsImFycmF5QnVmZmVyIiwiaXNGaWxlTGlrZSIsImxhc3RNb2RpZmllZCIsImlzUmVzcG9uc2VMaWtlIiwidG9GaWxlIiwicGF0aG5hbWUiLCJnZXRCeXRlcyIsImZpbmQiLCJpc1ZpZXciLCJ2YWx1ZV8xIiwidmFsdWVfMV8xIiwicHJvcHNGb3JFcnJvciIsInByb3BzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIkFQSVJlc291cmNlIiwiX2NsaWVudCIsIl9rZXkiLCJlbmNvZGVVUklQYXRoIiwic3RyIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiRU1QVFkiLCJmcmVlemUiLCJjcmVhdGVQYXRoVGFnRnVuY3Rpb24iLCJwYXRoRW5jb2RlciIsInN0YXRpY3MiLCJwb3N0UGF0aCIsImludmFsaWRTZWdtZW50cyIsInJlZHVjZSIsInByZXZpb3VzVmFsdWUiLCJjdXJyZW50VmFsdWUiLCJlbmNvZGVkIiwiZ2V0UHJvdG90eXBlT2YiLCJwYXRoT25seSIsImludmFsaWRTZWdtZW50UGF0dGVybiIsInNvcnQiLCJsYXN0RW5kIiwidW5kZXJsaW5lIiwiYWNjIiwic2VnbWVudCIsInNwYWNlcyIsInJlcGVhdCIsImFycm93cyIsIkJhc2VJbnRlcmFjdGlvbnMiLCJhcGlfdmVyc2lvbiIsInBvc3QiLCJxdWVyeSIsIkludGVyYWN0aW9ucyIsImNvbmNhdEJ5dGVzIiwiYnVmZmVycyIsImVuY29kZVVURjhfIiwiZW5jb2RlVVRGOCIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImRlY29kZVVURjhfIiwiZGVjb2RlVVRGOCIsImJ5dGVzIiwiTGluZURlY29kZXIiLCJjYXJyaWFnZVJldHVybkluZGV4IiwiYmluYXJ5Q2h1bmsiLCJsaW5lcyIsInBhdHRlcm5JbmRleCIsImZpbmROZXdsaW5lSW5kZXgiLCJjYXJyaWFnZSIsInN1YmFycmF5IiwiZW5kSW5kZXgiLCJwcmVjZWRpbmciLCJsaW5lIiwiZmx1c2giLCJORVdMSU5FX0NIQVJTIiwiTkVXTElORV9SRUdFWFAiLCJzdGFydEluZGV4IiwibmV3bGluZSIsImZpbmREb3VibGVOZXdsaW5lSW5kZXgiLCJsZXZlbE51bWJlcnMiLCJvZmYiLCJpbmZvIiwiZGVidWciLCJwYXJzZUxvZ0xldmVsIiwibWF5YmVMZXZlbCIsInNvdXJjZU5hbWUiLCJsb2dnZXJGb3IiLCJub29wIiwibWFrZUxvZ0ZuIiwiZm5MZXZlbCIsImxvZ2dlciIsImxvZ0xldmVsIiwibm9vcExvZ2dlciIsImNhY2hlZExvZ2dlcnMiLCJXZWFrTWFwIiwiY2FjaGVkTG9nZ2VyIiwibGV2ZWxMb2dnZXIiLCJmb3JtYXRSZXF1ZXN0RGV0YWlscyIsImRldGFpbHMiLCJmcm9tRW50cmllcyIsInJldHJ5T2ZSZXF1ZXN0TG9nSUQiLCJyZXRyeU9mIiwiU3RyZWFtIiwiZnJvbVNTRVJlc3BvbnNlIiwiY29uc3VtZWQiLCJpdGVyYXRvcl8xIiwiX2l0ZXJTU0VNZXNzYWdlcyIsInNzZSIsInJhdyIsImZyb21SZWFkYWJsZVN0cmVhbSIsInJlYWRhYmxlU3RyZWFtIiwiaXRlckxpbmVzIiwiaXRlckxpbmVzXzEiLCJsaW5lRGVjb2RlciIsIml0ZXJfMSIsIml0ZXJfMV8xIiwiaXRlcmF0b3JfMiIsInRlZSIsImxlZnQiLCJyaWdodCIsInRlZUl0ZXJhdG9yIiwicXVldWUiLCJ0b1JlYWRhYmxlU3RyZWFtIiwic2VsZiIsImN0cmwiLCJfaXRlclNTRU1lc3NhZ2VzXzEiLCJlXzQiLCJwcm9kdWN0Iiwic3NlRGVjb2RlciIsIlNTRURlY29kZXIiLCJpdGVyU1NFQ2h1bmtzIiwic3NlQ2h1bmsiLCJlXzRfMSIsIml0ZXJTU0VDaHVua3NfMSIsImVfNSIsIml0ZXJhdG9yXzMiLCJpdGVyYXRvcl8zXzEiLCJuZXdEYXRhIiwiZV81XzEiLCJjaHVua3MiLCJmaWVsZG5hbWUiLCJfIiwicGFydGl0aW9uIiwiZGVmYXVsdFBhcnNlUmVzcG9uc2UiLCJyZXF1ZXN0TG9nSUQiLCJzdGFydFRpbWUiLCJfX3N0cmVhbUNsYXNzIiwiX19iaW5hcnlSZXNwb25zZSIsIm1lZGlhVHlwZSIsImlzSlNPTiIsImR1cmF0aW9uTXMiLCJBUElQcm9taXNlIiwicGFyc2VSZXNwb25zZSIsIl90aGVuVW53cmFwIiwidHJhbnNmb3JtIiwiYXNSZXNwb25zZSIsIndpdGhSZXNwb25zZSIsInBhcnNlZFByb21pc2UiLCJvbmZ1bGZpbGxlZCIsIm9ucmVqZWN0ZWQiLCJmaW5hbGx5Iiwib25maW5hbGx5IiwiYnJhbmRfcHJpdmF0ZU51bGxhYmxlSGVhZGVycyIsIml0ZXJhdGVIZWFkZXJzIiwibnVsbHMiLCJzaG91bGRDbGVhciIsInJvdyIsImRpZENsZWFyIiwiYnVpbGRIZWFkZXJzIiwidGFyZ2V0SGVhZGVycyIsIm51bGxIZWFkZXJzIiwic2VlbkhlYWRlcnMiLCJsb3dlck5hbWUiLCJyZWFkRW52IiwiZW52IiwiQmFzZUdlbWluaU5leHRHZW5BUElDbGllbnQiLCJiYXNlVVJMIiwiREVGQVVMVF9USU1FT1VUIiwiZGVmYXVsdExvZ0xldmVsIiwiZmV0Y2hPcHRpb25zIiwibWF4UmV0cmllcyIsIl9vcHRpb25zIiwiY2xpZW50QWRhcHRlciIsIndpdGhPcHRpb25zIiwiYmFzZVVSTE92ZXJyaWRkZW4iLCJkZWZhdWx0UXVlcnkiLCJ2YWxpZGF0ZUhlYWRlcnMiLCJhdXRoSGVhZGVycyIsImV4aXN0aW5nSGVhZGVycyIsInN0cmluZ2lmeVF1ZXJ5IiwiZ2V0VXNlckFnZW50IiwiZGVmYXVsdElkZW1wb3RlbmN5S2V5IiwibWFrZVN0YXR1c0Vycm9yIiwiYnVpbGRVUkwiLCJkZWZhdWx0QmFzZVVSTCIsInNlYXJjaCIsInByZXBhcmVPcHRpb25zIiwib2xkUGF0aCIsInByZXBhcmVSZXF1ZXN0IiwibWV0aG9kUmVxdWVzdCIsInB1dCIsInJlbWFpbmluZ1JldHJpZXMiLCJtYWtlUmVxdWVzdCIsIm9wdGlvbnNJbnB1dCIsInJldHJpZXNSZW1haW5pbmciLCJyZXEiLCJidWlsZFJlcXVlc3QiLCJyZXRyeUNvdW50IiwicGFkU3RhcnQiLCJyZXRyeUxvZ1N0ciIsImFib3J0ZWQiLCJmZXRjaFdpdGhUaW1lb3V0IiwiaGVhZGVyc1RpbWUiLCJyZXRyeU1lc3NhZ2UiLCJpc1RpbWVvdXQiLCJyZXRyeVJlcXVlc3QiLCJyZXNwb25zZUluZm8iLCJzaG91bGRSZXRyeSIsImVyclRleHQiLCJlcnJKU09OIiwiZXJyTWVzc2FnZSIsImlzUmVhZGFibGVCb2R5IiwiZHVwbGV4IiwiY2xlYXJUaW1lb3V0Iiwic2hvdWxkUmV0cnlIZWFkZXIiLCJyZXNwb25zZUhlYWRlcnMiLCJ0aW1lb3V0TWlsbGlzIiwicmV0cnlBZnRlck1pbGxpc0hlYWRlciIsInRpbWVvdXRNcyIsInBhcnNlRmxvYXQiLCJpc05hTiIsInJldHJ5QWZ0ZXJIZWFkZXIiLCJ0aW1lb3V0U2Vjb25kcyIsImNhbGN1bGF0ZURlZmF1bHRSZXRyeVRpbWVvdXRNaWxsaXMiLCJpbml0aWFsUmV0cnlEZWxheSIsIm1heFJldHJ5RGVsYXkiLCJudW1SZXRyaWVzIiwic2xlZXBTZWNvbmRzIiwibWluIiwicG93Iiwiaml0dGVyIiwiaW5wdXRPcHRpb25zIiwiYnVpbGRCb2R5IiwicmVxSGVhZGVycyIsImlkZW1wb3RlbmN5SGVhZGVycyIsImlkZW1wb3RlbmN5SGVhZGVyIiwiaWRlbXBvdGVuY3lLZXkiLCJBY2NlcHQiLCJ0cnVuYyIsImRlZmF1bHRIZWFkZXJzIiwicmF3SGVhZGVycyIsIkRhdGFWaWV3IiwiRm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJHZW1pbmlOZXh0R2VuQVBJQ2xpZW50IiwiaW50ZXJhY3Rpb25zIiwiR09PR0xFX0FQSV9LRVlfSEVBREVSIiwiUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFIiwiTm9kZUF1dGgiLCJ2ZXJ0ZXhBdXRoT3B0aW9ucyIsImJ1aWxkR29vZ2xlQXV0aE9wdGlvbnMiLCJnb29nbGVBdXRoT3B0aW9ucyIsImdvb2dsZUF1dGgiLCJhZGRLZXlIZWFkZXIiLCJhZGRHb29nbGVBdXRoSGVhZGVycyIsImdldFJlcXVlc3RIZWFkZXJzIiwiYXV0aE9wdGlvbnMiLCJzY29wZXMiLCJOb2RlRG93bmxvYWRlciIsImRvd25sb2FkUGF0aCIsIndyaXRlciIsImZyb21XZWIiLCJwaXBlIiwiZW5jb2RpbmciLCJOb2RlV2ViU29ja2V0RmFjdG9yeSIsIk5vZGVXZWJTb2NrZXQiLCJ3cyIsIldlYlNvY2tldCIsImNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2IiwiX3Jvb3RPYmplY3QiLCJjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjYW5jZWxUdW5pbmdKb2JSZXNwb25zZUZyb21NbGRldiIsImNhbmNlbFR1bmluZ0pvYlJlc3BvbnNlRnJvbVZlcnRleCIsImNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvTWxkZXYiLCJmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lIiwiZnJvbUVwb2NoQ291bnQiLCJmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciIsImZyb21CYXRjaFNpemUiLCJmcm9tTGVhcm5pbmdSYXRlIiwiY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9WZXJ0ZXgiLCJyb290T2JqZWN0IiwiZGlzY3JpbWluYXRvclZhbGlkYXRpb25EYXRhc2V0IiwiZnJvbVZhbGlkYXRpb25EYXRhc2V0IiwidHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleCIsImRpc2NyaW1pbmF0b3JFcG9jaENvdW50IiwiZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZU11bHRpcGxpZXIiLCJkaXNjcmltaW5hdG9yRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5IiwiZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSIsImRpc2NyaW1pbmF0b3JBZGFwdGVyU2l6ZSIsImZyb21BZGFwdGVyU2l6ZSIsImZyb21CZXRhIiwiY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb01sZGV2IiwiZnJvbVByZVR1bmVkTW9kZWwiLCJmcm9tVHJhaW5pbmdEYXRhc2V0IiwidHVuaW5nRGF0YXNldFRvTWxkZXYiLCJjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvVmVydGV4IiwidHVuaW5nRGF0YXNldFRvVmVydGV4IiwiZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYiLCJnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvTWxkZXYiLCJsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvVmVydGV4IiwibGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9NbGRldiIsImxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21NbGRldiIsImZyb21UdW5pbmdKb2JzIiwidHVuaW5nSm9iRnJvbU1sZGV2IiwibGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJ0dW5pbmdKb2JGcm9tVmVydGV4IiwidHVuZWRNb2RlbEZyb21NbGRldiIsImZyb21FbmRwb2ludCIsImZyb21FeGFtcGxlcyIsImRpc2NyaW1pbmF0b3JHY3NVcmkiLCJkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlIiwiZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSIsImZyb21UdW5lZE1vZGVsIiwiZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjIiwiZnJvbVByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjIiwiZnJvbVR1bmluZ0RhdGFTdGF0cyIsImZyb21FbmNyeXB0aW9uU3BlYyIsImZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjIiwiZnJvbUN1c3RvbUJhc2VNb2RlbCIsImZyb21FeHBlcmltZW50IiwiZnJvbU91dHB1dFVyaSIsImZyb21QaXBlbGluZUpvYiIsImZyb21TZXJ2aWNlQWNjb3VudCIsImZyb21WZW9UdW5pbmdTcGVjIiwidHVuaW5nT3BlcmF0aW9uRnJvbU1sZGV2IiwiVHVuaW5ncyIsIlBBR0VEX0lURU1fVFVOSU5HX0pPQlMiLCJnZXRJbnRlcm5hbCIsInR1bmUiLCJiYXNlTW9kZWwiLCJwcmVUdW5lZE1vZGVsIiwidHVuZWRNb2RlbE5hbWUiLCJwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkIiwiY2hlY2twb2ludElkIiwicGFyYW1zUHJpdmF0ZSIsInR1bmVJbnRlcm5hbCIsInR1bmVNbGRldkludGVybmFsIiwidHVuaW5nSm9iIiwiSk9CX1NUQVRFX1FVRVVFRCIsIk1BWF9DSFVOS19TSVpFIiwiTUFYX1JFVFJZX0NPVU5UIiwiSU5JVElBTF9SRVRSWV9ERUxBWV9NUyIsIkRFTEFZX01VTFRJUExJRVIiLCJYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTEQiLCJ1cGxvYWRCbG9iIiwidXBsb2FkQmxvYkludGVybmFsIiwicmVzcG9uc2VKc29uIiwidXBsb2FkQmxvYlRvRmlsZVNlYXJjaFN0b3JlIiwiZmlsZVNpemUiLCJvZmZzZXQiLCJ1cGxvYWRDb21tYW5kIiwiY2h1bmtTaXplIiwiY3VycmVudERlbGF5TXMiLCJzbGVlcCIsImdldEJsb2JTdGF0IiwicmVzb2x2ZVByb21pc2UiLCJOb2RlVXBsb2FkZXIiLCJvcmlnaW5hbFN0YXQiLCJpbmZlck1pbWVUeXBlIiwidXBsb2FkRmlsZUZyb21QYXRoIiwidXBsb2FkRmlsZVRvRmlsZVNlYXJjaFN0b3JlRnJvbVBhdGgiLCJmaWxlUGF0aCIsImZpbGVFeHRlbnNpb24iLCJsYXN0SW5kZXhPZiIsIm1pbWVUeXBlcyIsInVwbG9hZEZpbGVGcm9tUGF0aEludGVybmFsIiwiZmlsZUhhbmRsZSIsImJhc2VuYW1lIiwib3BlbiIsImJ5dGVzUmVhZCIsIkxBTkdVQUdFX0xBQkVMX1BSRUZJWCIsIkdvb2dsZUdlbkFJIiwiX2ludGVyYWN0aW9ucyIsImh0dHBPcHRzIiwibmV4dEdlbkNsaWVudCIsImdldEJvb2xlYW5FbnYiLCJlbnZBcGlLZXkiLCJnZXRBcGlLZXlGcm9tRW52IiwiZW52UHJvamVjdCIsImdldEVudiIsImVudkxvY2F0aW9uIiwiY3JlZGVudGlhbHMiLCJsaXZlIiwiYmF0Y2hlcyIsImNoYXRzIiwiY2FjaGVzIiwiZmlsZXMiLCJvcGVyYXRpb25zIiwiYXV0aFRva2VucyIsInR1bmluZ3MiLCJmaWxlU2VhcmNoU3RvcmVzIiwic3RyaW5nVG9Cb29sZWFuIiwiZW52R29vZ2xlQXBpS2V5IiwiZW52R2VtaW5pQXBpS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google/genai/dist/node/index.mjs\n");

/***/ })

};
;