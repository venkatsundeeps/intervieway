exports.id=797,exports.ids=[797],exports.modules={1865:(r,t,a)=>{"use strict";/*! node-domexception. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */if(!globalThis.DOMException)try{let{MessageChannel:r}=a(1267),t=new r().port1,o=new ArrayBuffer;t.postMessage(o,[o,o])}catch(r){"DOMException"===r.constructor.name&&(globalThis.DOMException=r.constructor)}r.exports=globalThis.DOMException},7650:function(r,t){/**
 * @license
 * web-streams-polyfill v3.3.3
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */(function(r){"use strict";var t,a,o;function noop(){}function typeIsObject(r){return"object"==typeof r&&null!==r||"function"==typeof r}let l=noop;function setFunctionName(r,t){try{Object.defineProperty(r,"name",{value:t,configurable:!0})}catch(r){}}let n=Promise,i=Promise.prototype.then,s=Promise.reject.bind(n);function newPromise(r){return new n(r)}function promiseResolvedWith(r){return newPromise(t=>t(r))}function PerformPromiseThen(r,t,a){return i.call(r,t,a)}function uponPromise(r,t,a){PerformPromiseThen(PerformPromiseThen(r,t,a),void 0,l)}function uponRejection(r,t){uponPromise(r,void 0,t)}function setPromiseIsHandledToTrue(r){PerformPromiseThen(r,void 0,l)}let _queueMicrotask=r=>{if("function"==typeof queueMicrotask)_queueMicrotask=queueMicrotask;else{let r=promiseResolvedWith(void 0);_queueMicrotask=t=>PerformPromiseThen(r,t)}return _queueMicrotask(r)};function reflectCall(r,t,a){if("function"!=typeof r)throw TypeError("Argument is not a function");return Function.prototype.apply.call(r,t,a)}function promiseCall(r,t,a){try{return promiseResolvedWith(reflectCall(r,t,a))}catch(r){return s(r)}}let SimpleQueue=class SimpleQueue{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(r){let t=this._back,a=t;16383===t._elements.length&&(a={_elements:[],_next:void 0}),t._elements.push(r),a!==t&&(this._back=a,t._next=a),++this._size}shift(){let r=this._front,t=r,a=this._cursor,o=a+1,l=r._elements,n=l[a];return 16384===o&&(t=r._next,o=0),--this._size,this._cursor=o,r!==t&&(this._front=t),l[a]=void 0,n}forEach(r){let t=this._cursor,a=this._front,o=a._elements;for(;(t!==o.length||void 0!==a._next)&&(t!==o.length||(o=(a=a._next)._elements,t=0,0!==o.length));)r(o[t]),++t}peek(){let r=this._front,t=this._cursor;return r._elements[t]}};let u=Symbol("[[AbortSteps]]"),d=Symbol("[[ErrorSteps]]"),c=Symbol("[[CancelSteps]]"),m=Symbol("[[PullSteps]]"),b=Symbol("[[ReleaseSteps]]");function ReadableStreamReaderGenericInitialize(r,t){var a;r._ownerReadableStream=t,t._reader=r,"readable"===t._state?defaultReaderClosedPromiseInitialize(r):"closed"===t._state?defaultReaderClosedPromiseInitializeAsResolved(r):(a=t._storedError,defaultReaderClosedPromiseInitialize(r),defaultReaderClosedPromiseReject(r,a))}function ReadableStreamReaderGenericCancel(r,t){let a=r._ownerReadableStream;return ReadableStreamCancel(a,t)}function ReadableStreamReaderGenericRelease(r){let t=r._ownerReadableStream;"readable"===t._state?defaultReaderClosedPromiseReject(r,TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):defaultReaderClosedPromiseResetToRejected(r,TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),t._readableStreamController[b](),t._reader=void 0,r._ownerReadableStream=void 0}function readerLockException(r){return TypeError("Cannot "+r+" a stream using a released reader")}function defaultReaderClosedPromiseInitialize(r){r._closedPromise=newPromise((t,a)=>{r._closedPromise_resolve=t,r._closedPromise_reject=a})}function defaultReaderClosedPromiseInitializeAsResolved(r){defaultReaderClosedPromiseInitialize(r),defaultReaderClosedPromiseResolve(r)}function defaultReaderClosedPromiseReject(r,t){void 0!==r._closedPromise_reject&&(setPromiseIsHandledToTrue(r._closedPromise),r._closedPromise_reject(t),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0)}function defaultReaderClosedPromiseResetToRejected(r,t){defaultReaderClosedPromiseInitialize(r),defaultReaderClosedPromiseReject(r,t)}function defaultReaderClosedPromiseResolve(r){void 0!==r._closedPromise_resolve&&(r._closedPromise_resolve(void 0),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0)}let h=Number.isFinite||function(r){return"number"==typeof r&&isFinite(r)},p=Math.trunc||function(r){return r<0?Math.ceil(r):Math.floor(r)};function isDictionary(r){return"object"==typeof r||"function"==typeof r}function assertDictionary(r,t){if(void 0!==r&&!isDictionary(r))throw TypeError(`${t} is not an object.`)}function assertFunction(r,t){if("function"!=typeof r)throw TypeError(`${t} is not a function.`)}function isObject(r){return"object"==typeof r&&null!==r||"function"==typeof r}function assertObject(r,t){if(!isObject(r))throw TypeError(`${t} is not an object.`)}function assertRequiredArgument(r,t,a){if(void 0===r)throw TypeError(`Parameter ${t} is required in '${a}'.`)}function assertRequiredField(r,t,a){if(void 0===r)throw TypeError(`${t} is required in '${a}'.`)}function convertUnrestrictedDouble(r){return Number(r)}function integerPart(r){var t;return 0===(t=p(r))?0:t}function convertUnsignedLongLongWithEnforceRange(r,t){var a;let o=Number.MAX_SAFE_INTEGER,l=Number(r);if(!h(l=0===(a=l)?0:a))throw TypeError(`${t} is not a finite number`);if((l=integerPart(l))<0||l>o)throw TypeError(`${t} is outside the accepted range of 0 to ${o}, inclusive`);return h(l)&&0!==l?l:0}function assertReadableStream(r,t){if(!IsReadableStream(r))throw TypeError(`${t} is not a ReadableStream.`)}function AcquireReadableStreamDefaultReader(r){return new ReadableStreamDefaultReader(r)}function ReadableStreamAddReadRequest(r,t){r._reader._readRequests.push(t)}function ReadableStreamFulfillReadRequest(r,t,a){let o=r._reader,l=o._readRequests.shift();a?l._closeSteps():l._chunkSteps(t)}function ReadableStreamGetNumReadRequests(r){return r._reader._readRequests.length}function ReadableStreamHasDefaultReader(r){let t=r._reader;return!!(void 0!==t&&IsReadableStreamDefaultReader(t))}let ReadableStreamDefaultReader=class ReadableStreamDefaultReader{constructor(r){if(assertRequiredArgument(r,1,"ReadableStreamDefaultReader"),assertReadableStream(r,"First parameter"),IsReadableStreamLocked(r))throw TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,r),this._readRequests=new SimpleQueue}get closed(){return IsReadableStreamDefaultReader(this)?this._closedPromise:s(defaultReaderBrandCheckException("closed"))}cancel(r){return IsReadableStreamDefaultReader(this)?void 0===this._ownerReadableStream?s(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,r):s(defaultReaderBrandCheckException("cancel"))}read(){let r,t;if(!IsReadableStreamDefaultReader(this))return s(defaultReaderBrandCheckException("read"));if(void 0===this._ownerReadableStream)return s(readerLockException("read from"));let a=newPromise((a,o)=>{r=a,t=o});return ReadableStreamDefaultReaderRead(this,{_chunkSteps:t=>r({value:t,done:!1}),_closeSteps:()=>r({value:void 0,done:!0}),_errorSteps:r=>t(r)}),a}releaseLock(){if(!IsReadableStreamDefaultReader(this))throw defaultReaderBrandCheckException("releaseLock");void 0!==this._ownerReadableStream&&ReadableStreamDefaultReaderRelease(this)}};function IsReadableStreamDefaultReader(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_readRequests"))&&r instanceof ReadableStreamDefaultReader}function ReadableStreamDefaultReaderRead(r,t){let a=r._ownerReadableStream;a._disturbed=!0,"closed"===a._state?t._closeSteps():"errored"===a._state?t._errorSteps(a._storedError):a._readableStreamController[m](t)}function ReadableStreamDefaultReaderRelease(r){ReadableStreamReaderGenericRelease(r);let t=TypeError("Reader was released");ReadableStreamDefaultReaderErrorReadRequests(r,t)}function ReadableStreamDefaultReaderErrorReadRequests(r,t){let a=r._readRequests;r._readRequests=new SimpleQueue,a.forEach(r=>{r._errorSteps(t)})}function defaultReaderBrandCheckException(r){return TypeError(`ReadableStreamDefaultReader.prototype.${r} can only be used on a ReadableStreamDefaultReader`)}Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),setFunctionName(ReadableStreamDefaultReader.prototype.cancel,"cancel"),setFunctionName(ReadableStreamDefaultReader.prototype.read,"read"),setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock,"releaseLock"),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableStreamDefaultReader.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});let S=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype);let ReadableStreamAsyncIteratorImpl=class ReadableStreamAsyncIteratorImpl{constructor(r,t){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=r,this._preventCancel=t}next(){let nextSteps=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?PerformPromiseThen(this._ongoingPromise,nextSteps,nextSteps):nextSteps(),this._ongoingPromise}return(r){let returnSteps=()=>this._returnSteps(r);return this._ongoingPromise?PerformPromiseThen(this._ongoingPromise,returnSteps,returnSteps):returnSteps()}_nextSteps(){let r,t;if(this._isFinished)return Promise.resolve({value:void 0,done:!0});let a=this._reader,o=newPromise((a,o)=>{r=a,t=o});return ReadableStreamDefaultReaderRead(a,{_chunkSteps:t=>{this._ongoingPromise=void 0,_queueMicrotask(()=>r({value:t,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,ReadableStreamReaderGenericRelease(a),r({value:void 0,done:!0})},_errorSteps:r=>{this._ongoingPromise=void 0,this._isFinished=!0,ReadableStreamReaderGenericRelease(a),t(r)}}),o}_returnSteps(r){if(this._isFinished)return Promise.resolve({value:r,done:!0});this._isFinished=!0;let t=this._reader;if(!this._preventCancel){let a=ReadableStreamReaderGenericCancel(t,r);return ReadableStreamReaderGenericRelease(t),PerformPromiseThen(a,()=>({value:r,done:!0}),void 0)}return ReadableStreamReaderGenericRelease(t),promiseResolvedWith({value:r,done:!0})}};let y={next(){return IsReadableStreamAsyncIterator(this)?this._asyncIteratorImpl.next():s(streamAsyncIteratorBrandCheckException("next"))},return(r){return IsReadableStreamAsyncIterator(this)?this._asyncIteratorImpl.return(r):s(streamAsyncIteratorBrandCheckException("return"))}};function AcquireReadableStreamAsyncIterator(r,t){let a=AcquireReadableStreamDefaultReader(r),o=new ReadableStreamAsyncIteratorImpl(a,t),l=Object.create(y);return l._asyncIteratorImpl=o,l}function IsReadableStreamAsyncIterator(r){if(!typeIsObject(r)||!Object.prototype.hasOwnProperty.call(r,"_asyncIteratorImpl"))return!1;try{return r._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl}catch(r){return!1}}function streamAsyncIteratorBrandCheckException(r){return TypeError(`ReadableStreamAsyncIterator.${r} can only be used on a ReadableSteamAsyncIterator`)}Object.setPrototypeOf(y,S);let R=Number.isNaN||function(r){return r!=r};function CreateArrayFromList(r){return r.slice()}function CopyDataBlockBytes(r,t,a,o,l){new Uint8Array(r).set(new Uint8Array(a,o,l),t)}let TransferArrayBuffer=r=>(TransferArrayBuffer="function"==typeof r.transfer?r=>r.transfer():"function"==typeof structuredClone?r=>structuredClone(r,{transfer:[r]}):r=>r)(r),IsDetachedBuffer=r=>(IsDetachedBuffer="boolean"==typeof r.detached?r=>r.detached:r=>0===r.byteLength)(r);function ArrayBufferSlice(r,t,a){if(r.slice)return r.slice(t,a);let o=a-t,l=new ArrayBuffer(o);return CopyDataBlockBytes(l,0,r,t,o),l}function GetMethod(r,t){let a=r[t];if(null!=a){if("function"!=typeof a)throw TypeError(`${String(t)} is not a function`);return a}}function CreateAsyncFromSyncIterator(r){let t={[Symbol.iterator]:()=>r.iterator},a=async function*(){return yield*t}(),o=a.next;return{iterator:a,nextMethod:o,done:!1}}let g=null!==(o=null!==(t=Symbol.asyncIterator)&&void 0!==t?t:null===(a=Symbol.for)||void 0===a?void 0:a.call(Symbol,"Symbol.asyncIterator"))&&void 0!==o?o:"@@asyncIterator";function GetIterator(r,t="sync",a){if(void 0===a){if("async"===t){if(void 0===(a=GetMethod(r,g))){let t=GetMethod(r,Symbol.iterator),a=GetIterator(r,"sync",t);return CreateAsyncFromSyncIterator(a)}}else a=GetMethod(r,Symbol.iterator)}if(void 0===a)throw TypeError("The object is not iterable");let o=reflectCall(a,r,[]);if(!typeIsObject(o))throw TypeError("The iterator method must return an object");let l=o.next;return{iterator:o,nextMethod:l,done:!1}}function IteratorNext(r){let t=reflectCall(r.nextMethod,r.iterator,[]);if(!typeIsObject(t))throw TypeError("The iterator.next() method must return an object");return t}function IteratorComplete(r){return!!r.done}function IteratorValue(r){return r.value}function IsNonNegativeNumber(r){return!("number"!=typeof r||R(r))&&!(r<0)}function CloneAsUint8Array(r){let t=ArrayBufferSlice(r.buffer,r.byteOffset,r.byteOffset+r.byteLength);return new Uint8Array(t)}function DequeueValue(r){let t=r._queue.shift();return r._queueTotalSize-=t.size,r._queueTotalSize<0&&(r._queueTotalSize=0),t.value}function EnqueueValueWithSize(r,t,a){if(!IsNonNegativeNumber(a)||a===1/0)throw RangeError("Size must be a finite, non-NaN, non-negative number.");r._queue.push({value:t,size:a}),r._queueTotalSize+=a}function PeekQueueValue(r){let t=r._queue.peek();return t.value}function ResetQueue(r){r._queue=new SimpleQueue,r._queueTotalSize=0}function isDataViewConstructor(r){return r===DataView}function isDataView(r){return isDataViewConstructor(r.constructor)}function arrayBufferViewElementSize(r){return isDataViewConstructor(r)?1:r.BYTES_PER_ELEMENT}let ReadableStreamBYOBRequest=class ReadableStreamBYOBRequest{constructor(){throw TypeError("Illegal constructor")}get view(){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("view");return this._view}respond(r){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respond");if(assertRequiredArgument(r,1,"respond"),r=convertUnsignedLongLongWithEnforceRange(r,"First parameter"),void 0===this._associatedReadableByteStreamController)throw TypeError("This BYOB request has been invalidated");if(IsDetachedBuffer(this._view.buffer))throw TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,r)}respondWithNewView(r){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respondWithNewView");if(assertRequiredArgument(r,1,"respondWithNewView"),!ArrayBuffer.isView(r))throw TypeError("You can only respond with array buffer views");if(void 0===this._associatedReadableByteStreamController)throw TypeError("This BYOB request has been invalidated");if(IsDetachedBuffer(r.buffer))throw TypeError("The given view's buffer has been detached and so cannot be used as a response");ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,r)}};Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),setFunctionName(ReadableStreamBYOBRequest.prototype.respond,"respond"),setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView,"respondWithNewView"),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableStreamBYOBRequest.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});let ReadableByteStreamController=class ReadableByteStreamController{constructor(){throw TypeError("Illegal constructor")}get byobRequest(){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("byobRequest");return ReadableByteStreamControllerGetBYOBRequest(this)}get desiredSize(){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("desiredSize");return ReadableByteStreamControllerGetDesiredSize(this)}close(){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("close");if(this._closeRequested)throw TypeError("The stream has already been closed; do not close it again!");let r=this._controlledReadableByteStream._state;if("readable"!==r)throw TypeError(`The stream (in ${r} state) is not in the readable state and cannot be closed`);ReadableByteStreamControllerClose(this)}enqueue(r){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("enqueue");if(assertRequiredArgument(r,1,"enqueue"),!ArrayBuffer.isView(r))throw TypeError("chunk must be an array buffer view");if(0===r.byteLength)throw TypeError("chunk must have non-zero byteLength");if(0===r.buffer.byteLength)throw TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw TypeError("stream is closed or draining");let t=this._controlledReadableByteStream._state;if("readable"!==t)throw TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`);ReadableByteStreamControllerEnqueue(this,r)}error(r){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("error");ReadableByteStreamControllerError(this,r)}[c](r){ReadableByteStreamControllerClearPendingPullIntos(this),ResetQueue(this);let t=this._cancelAlgorithm(r);return ReadableByteStreamControllerClearAlgorithms(this),t}[m](r){let t=this._controlledReadableByteStream;if(this._queueTotalSize>0){ReadableByteStreamControllerFillReadRequestFromQueue(this,r);return}let a=this._autoAllocateChunkSize;if(void 0!==a){let t;try{t=new ArrayBuffer(a)}catch(t){r._errorSteps(t);return}let o={buffer:t,bufferByteLength:a,byteOffset:0,byteLength:a,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(o)}ReadableStreamAddReadRequest(t,r),ReadableByteStreamControllerCallPullIfNeeded(this)}[b](){if(this._pendingPullIntos.length>0){let r=this._pendingPullIntos.peek();r.readerType="none",this._pendingPullIntos=new SimpleQueue,this._pendingPullIntos.push(r)}}};function IsReadableByteStreamController(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_controlledReadableByteStream"))&&r instanceof ReadableByteStreamController}function IsReadableStreamBYOBRequest(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_associatedReadableByteStreamController"))&&r instanceof ReadableStreamBYOBRequest}function ReadableByteStreamControllerCallPullIfNeeded(r){let t=ReadableByteStreamControllerShouldCallPull(r);if(!t)return;if(r._pulling){r._pullAgain=!0;return}r._pulling=!0;let a=r._pullAlgorithm();uponPromise(a,()=>(r._pulling=!1,r._pullAgain&&(r._pullAgain=!1,ReadableByteStreamControllerCallPullIfNeeded(r)),null),t=>(ReadableByteStreamControllerError(r,t),null))}function ReadableByteStreamControllerClearPendingPullIntos(r){ReadableByteStreamControllerInvalidateBYOBRequest(r),r._pendingPullIntos=new SimpleQueue}function ReadableByteStreamControllerCommitPullIntoDescriptor(r,t){let a=!1;"closed"===r._state&&(a=!0);let o=ReadableByteStreamControllerConvertPullIntoDescriptor(t);"default"===t.readerType?ReadableStreamFulfillReadRequest(r,o,a):ReadableStreamFulfillReadIntoRequest(r,o,a)}function ReadableByteStreamControllerConvertPullIntoDescriptor(r){let t=r.bytesFilled,a=r.elementSize;return new r.viewConstructor(r.buffer,r.byteOffset,t/a)}function ReadableByteStreamControllerEnqueueChunkToQueue(r,t,a,o){r._queue.push({buffer:t,byteOffset:a,byteLength:o}),r._queueTotalSize+=o}function ReadableByteStreamControllerEnqueueClonedChunkToQueue(r,t,a,o){let l;try{l=ArrayBufferSlice(t,a,a+o)}catch(t){throw ReadableByteStreamControllerError(r,t),t}ReadableByteStreamControllerEnqueueChunkToQueue(r,l,0,o)}function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(r,t){t.bytesFilled>0&&ReadableByteStreamControllerEnqueueClonedChunkToQueue(r,t.buffer,t.byteOffset,t.bytesFilled),ReadableByteStreamControllerShiftPendingPullInto(r)}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(r,t){let a=Math.min(r._queueTotalSize,t.byteLength-t.bytesFilled),o=t.bytesFilled+a,l=a,n=!1,i=o%t.elementSize,s=o-i;s>=t.minimumFill&&(l=s-t.bytesFilled,n=!0);let u=r._queue;for(;l>0;){let a=u.peek(),o=Math.min(l,a.byteLength),n=t.byteOffset+t.bytesFilled;CopyDataBlockBytes(t.buffer,n,a.buffer,a.byteOffset,o),a.byteLength===o?u.shift():(a.byteOffset+=o,a.byteLength-=o),r._queueTotalSize-=o,ReadableByteStreamControllerFillHeadPullIntoDescriptor(r,o,t),l-=o}return n}function ReadableByteStreamControllerFillHeadPullIntoDescriptor(r,t,a){a.bytesFilled+=t}function ReadableByteStreamControllerHandleQueueDrain(r){0===r._queueTotalSize&&r._closeRequested?(ReadableByteStreamControllerClearAlgorithms(r),ReadableStreamClose(r._controlledReadableByteStream)):ReadableByteStreamControllerCallPullIfNeeded(r)}function ReadableByteStreamControllerInvalidateBYOBRequest(r){null!==r._byobRequest&&(r._byobRequest._associatedReadableByteStreamController=void 0,r._byobRequest._view=null,r._byobRequest=null)}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(r){for(;r._pendingPullIntos.length>0;){if(0===r._queueTotalSize)return;let t=r._pendingPullIntos.peek();ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(r,t)&&(ReadableByteStreamControllerShiftPendingPullInto(r),ReadableByteStreamControllerCommitPullIntoDescriptor(r._controlledReadableByteStream,t))}}function ReadableByteStreamControllerProcessReadRequestsUsingQueue(r){let t=r._controlledReadableByteStream._reader;for(;t._readRequests.length>0;){if(0===r._queueTotalSize)return;let a=t._readRequests.shift();ReadableByteStreamControllerFillReadRequestFromQueue(r,a)}}function ReadableByteStreamControllerPullInto(r,t,a,o){let l;let n=r._controlledReadableByteStream,i=t.constructor,s=arrayBufferViewElementSize(i),{byteOffset:u,byteLength:d}=t,c=a*s;try{l=TransferArrayBuffer(t.buffer)}catch(r){o._errorSteps(r);return}let m={buffer:l,bufferByteLength:l.byteLength,byteOffset:u,byteLength:d,bytesFilled:0,minimumFill:c,elementSize:s,viewConstructor:i,readerType:"byob"};if(r._pendingPullIntos.length>0){r._pendingPullIntos.push(m),ReadableStreamAddReadIntoRequest(n,o);return}if("closed"===n._state){let r=new i(m.buffer,m.byteOffset,0);o._closeSteps(r);return}if(r._queueTotalSize>0){if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(r,m)){let t=ReadableByteStreamControllerConvertPullIntoDescriptor(m);ReadableByteStreamControllerHandleQueueDrain(r),o._chunkSteps(t);return}if(r._closeRequested){let t=TypeError("Insufficient bytes to fill elements in the given buffer");ReadableByteStreamControllerError(r,t),o._errorSteps(t);return}}r._pendingPullIntos.push(m),ReadableStreamAddReadIntoRequest(n,o),ReadableByteStreamControllerCallPullIfNeeded(r)}function ReadableByteStreamControllerRespondInClosedState(r,t){"none"===t.readerType&&ReadableByteStreamControllerShiftPendingPullInto(r);let a=r._controlledReadableByteStream;if(ReadableStreamHasBYOBReader(a))for(;ReadableStreamGetNumReadIntoRequests(a)>0;){let t=ReadableByteStreamControllerShiftPendingPullInto(r);ReadableByteStreamControllerCommitPullIntoDescriptor(a,t)}}function ReadableByteStreamControllerRespondInReadableState(r,t,a){if(ReadableByteStreamControllerFillHeadPullIntoDescriptor(r,t,a),"none"===a.readerType){ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(r,a),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(r);return}if(a.bytesFilled<a.minimumFill)return;ReadableByteStreamControllerShiftPendingPullInto(r);let o=a.bytesFilled%a.elementSize;if(o>0){let t=a.byteOffset+a.bytesFilled;ReadableByteStreamControllerEnqueueClonedChunkToQueue(r,a.buffer,t-o,o)}a.bytesFilled-=o,ReadableByteStreamControllerCommitPullIntoDescriptor(r._controlledReadableByteStream,a),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(r)}function ReadableByteStreamControllerRespondInternal(r,t){let a=r._pendingPullIntos.peek();ReadableByteStreamControllerInvalidateBYOBRequest(r);let o=r._controlledReadableByteStream._state;"closed"===o?ReadableByteStreamControllerRespondInClosedState(r,a):ReadableByteStreamControllerRespondInReadableState(r,t,a),ReadableByteStreamControllerCallPullIfNeeded(r)}function ReadableByteStreamControllerShiftPendingPullInto(r){let t=r._pendingPullIntos.shift();return t}function ReadableByteStreamControllerShouldCallPull(r){let t=r._controlledReadableByteStream;if("readable"!==t._state||r._closeRequested||!r._started)return!1;if(ReadableStreamHasDefaultReader(t)&&ReadableStreamGetNumReadRequests(t)>0||ReadableStreamHasBYOBReader(t)&&ReadableStreamGetNumReadIntoRequests(t)>0)return!0;let a=ReadableByteStreamControllerGetDesiredSize(r);return a>0}function ReadableByteStreamControllerClearAlgorithms(r){r._pullAlgorithm=void 0,r._cancelAlgorithm=void 0}function ReadableByteStreamControllerClose(r){let t=r._controlledReadableByteStream;if(!r._closeRequested&&"readable"===t._state){if(r._queueTotalSize>0){r._closeRequested=!0;return}if(r._pendingPullIntos.length>0){let t=r._pendingPullIntos.peek();if(t.bytesFilled%t.elementSize!=0){let t=TypeError("Insufficient bytes to fill elements in the given buffer");throw ReadableByteStreamControllerError(r,t),t}}ReadableByteStreamControllerClearAlgorithms(r),ReadableStreamClose(t)}}function ReadableByteStreamControllerEnqueue(r,t){let a=r._controlledReadableByteStream;if(r._closeRequested||"readable"!==a._state)return;let{buffer:o,byteOffset:l,byteLength:n}=t;if(IsDetachedBuffer(o))throw TypeError("chunk's buffer is detached and so cannot be enqueued");let i=TransferArrayBuffer(o);if(r._pendingPullIntos.length>0){let t=r._pendingPullIntos.peek();if(IsDetachedBuffer(t.buffer))throw TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");ReadableByteStreamControllerInvalidateBYOBRequest(r),t.buffer=TransferArrayBuffer(t.buffer),"none"===t.readerType&&ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(r,t)}if(ReadableStreamHasDefaultReader(a)){if(ReadableByteStreamControllerProcessReadRequestsUsingQueue(r),0===ReadableStreamGetNumReadRequests(a))ReadableByteStreamControllerEnqueueChunkToQueue(r,i,l,n);else{r._pendingPullIntos.length>0&&ReadableByteStreamControllerShiftPendingPullInto(r);let t=new Uint8Array(i,l,n);ReadableStreamFulfillReadRequest(a,t,!1)}}else ReadableStreamHasBYOBReader(a)?(ReadableByteStreamControllerEnqueueChunkToQueue(r,i,l,n),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(r)):ReadableByteStreamControllerEnqueueChunkToQueue(r,i,l,n);ReadableByteStreamControllerCallPullIfNeeded(r)}function ReadableByteStreamControllerError(r,t){let a=r._controlledReadableByteStream;"readable"===a._state&&(ReadableByteStreamControllerClearPendingPullIntos(r),ResetQueue(r),ReadableByteStreamControllerClearAlgorithms(r),ReadableStreamError(a,t))}function ReadableByteStreamControllerFillReadRequestFromQueue(r,t){let a=r._queue.shift();r._queueTotalSize-=a.byteLength,ReadableByteStreamControllerHandleQueueDrain(r);let o=new Uint8Array(a.buffer,a.byteOffset,a.byteLength);t._chunkSteps(o)}function ReadableByteStreamControllerGetBYOBRequest(r){if(null===r._byobRequest&&r._pendingPullIntos.length>0){let t=r._pendingPullIntos.peek(),a=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled),o=Object.create(ReadableStreamBYOBRequest.prototype);SetUpReadableStreamBYOBRequest(o,r,a),r._byobRequest=o}return r._byobRequest}function ReadableByteStreamControllerGetDesiredSize(r){let t=r._controlledReadableByteStream._state;return"errored"===t?null:"closed"===t?0:r._strategyHWM-r._queueTotalSize}function ReadableByteStreamControllerRespond(r,t){let a=r._pendingPullIntos.peek(),o=r._controlledReadableByteStream._state;if("closed"===o){if(0!==t)throw TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(0===t)throw TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(a.bytesFilled+t>a.byteLength)throw RangeError("bytesWritten out of range")}a.buffer=TransferArrayBuffer(a.buffer),ReadableByteStreamControllerRespondInternal(r,t)}function ReadableByteStreamControllerRespondWithNewView(r,t){let a=r._pendingPullIntos.peek(),o=r._controlledReadableByteStream._state;if("closed"===o){if(0!==t.byteLength)throw TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(0===t.byteLength)throw TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(a.byteOffset+a.bytesFilled!==t.byteOffset)throw RangeError("The region specified by view does not match byobRequest");if(a.bufferByteLength!==t.buffer.byteLength)throw RangeError("The buffer of view has different capacity than byobRequest");if(a.bytesFilled+t.byteLength>a.byteLength)throw RangeError("The region specified by view is larger than byobRequest");let l=t.byteLength;a.buffer=TransferArrayBuffer(t.buffer),ReadableByteStreamControllerRespondInternal(r,l)}function SetUpReadableByteStreamController(r,t,a,o,l,n,i){t._controlledReadableByteStream=r,t._pullAgain=!1,t._pulling=!1,t._byobRequest=null,t._queue=t._queueTotalSize=void 0,ResetQueue(t),t._closeRequested=!1,t._started=!1,t._strategyHWM=n,t._pullAlgorithm=o,t._cancelAlgorithm=l,t._autoAllocateChunkSize=i,t._pendingPullIntos=new SimpleQueue,r._readableStreamController=t;let s=a();uponPromise(promiseResolvedWith(s),()=>(t._started=!0,ReadableByteStreamControllerCallPullIfNeeded(t),null),r=>(ReadableByteStreamControllerError(t,r),null))}function SetUpReadableByteStreamControllerFromUnderlyingSource(r,t,a){let o,l,n;let i=Object.create(ReadableByteStreamController.prototype);o=void 0!==t.start?()=>t.start(i):()=>void 0,l=void 0!==t.pull?()=>t.pull(i):()=>promiseResolvedWith(void 0),n=void 0!==t.cancel?r=>t.cancel(r):()=>promiseResolvedWith(void 0);let s=t.autoAllocateChunkSize;if(0===s)throw TypeError("autoAllocateChunkSize must be greater than 0");SetUpReadableByteStreamController(r,i,o,l,n,a,s)}function SetUpReadableStreamBYOBRequest(r,t,a){r._associatedReadableByteStreamController=t,r._view=a}function byobRequestBrandCheckException(r){return TypeError(`ReadableStreamBYOBRequest.prototype.${r} can only be used on a ReadableStreamBYOBRequest`)}function byteStreamControllerBrandCheckException(r){return TypeError(`ReadableByteStreamController.prototype.${r} can only be used on a ReadableByteStreamController`)}function convertReaderOptions(r,t){assertDictionary(r,t);let a=null==r?void 0:r.mode;return{mode:void 0===a?void 0:convertReadableStreamReaderMode(a,`${t} has member 'mode' that`)}}function convertReadableStreamReaderMode(r,t){if("byob"!=(r=`${r}`))throw TypeError(`${t} '${r}' is not a valid enumeration value for ReadableStreamReaderMode`);return r}function convertByobReadOptions(r,t){var a;assertDictionary(r,t);let o=null!==(a=null==r?void 0:r.min)&&void 0!==a?a:1;return{min:convertUnsignedLongLongWithEnforceRange(o,`${t} has member 'min' that`)}}function ReadableStreamAddReadIntoRequest(r,t){r._reader._readIntoRequests.push(t)}function ReadableStreamFulfillReadIntoRequest(r,t,a){let o=r._reader,l=o._readIntoRequests.shift();a?l._closeSteps(t):l._chunkSteps(t)}function ReadableStreamGetNumReadIntoRequests(r){return r._reader._readIntoRequests.length}function ReadableStreamHasBYOBReader(r){let t=r._reader;return!!(void 0!==t&&IsReadableStreamBYOBReader(t))}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),setFunctionName(ReadableByteStreamController.prototype.close,"close"),setFunctionName(ReadableByteStreamController.prototype.enqueue,"enqueue"),setFunctionName(ReadableByteStreamController.prototype.error,"error"),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableByteStreamController.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:!0});let ReadableStreamBYOBReader=class ReadableStreamBYOBReader{constructor(r){if(assertRequiredArgument(r,1,"ReadableStreamBYOBReader"),assertReadableStream(r,"First parameter"),IsReadableStreamLocked(r))throw TypeError("This stream has already been locked for exclusive reading by another reader");if(!IsReadableByteStreamController(r._readableStreamController))throw TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");ReadableStreamReaderGenericInitialize(this,r),this._readIntoRequests=new SimpleQueue}get closed(){return IsReadableStreamBYOBReader(this)?this._closedPromise:s(byobReaderBrandCheckException("closed"))}cancel(r){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?s(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,r):s(byobReaderBrandCheckException("cancel"))}read(r,t={}){let a,o,l;if(!IsReadableStreamBYOBReader(this))return s(byobReaderBrandCheckException("read"));if(!ArrayBuffer.isView(r))return s(TypeError("view must be an array buffer view"));if(0===r.byteLength)return s(TypeError("view must have non-zero byteLength"));if(0===r.buffer.byteLength)return s(TypeError("view's buffer must have non-zero byteLength"));if(IsDetachedBuffer(r.buffer))return s(TypeError("view's buffer has been detached"));try{a=convertByobReadOptions(t,"options")}catch(r){return s(r)}let n=a.min;if(0===n)return s(TypeError("options.min must be greater than 0"));if(isDataView(r)){if(n>r.byteLength)return s(RangeError("options.min must be less than or equal to view's byteLength"))}else if(n>r.length)return s(RangeError("options.min must be less than or equal to view's length"));if(void 0===this._ownerReadableStream)return s(readerLockException("read from"));let i=newPromise((r,t)=>{o=r,l=t});return ReadableStreamBYOBReaderRead(this,r,n,{_chunkSteps:r=>o({value:r,done:!1}),_closeSteps:r=>o({value:r,done:!0}),_errorSteps:r=>l(r)}),i}releaseLock(){if(!IsReadableStreamBYOBReader(this))throw byobReaderBrandCheckException("releaseLock");void 0!==this._ownerReadableStream&&ReadableStreamBYOBReaderRelease(this)}};function IsReadableStreamBYOBReader(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_readIntoRequests"))&&r instanceof ReadableStreamBYOBReader}function ReadableStreamBYOBReaderRead(r,t,a,o){let l=r._ownerReadableStream;l._disturbed=!0,"errored"===l._state?o._errorSteps(l._storedError):ReadableByteStreamControllerPullInto(l._readableStreamController,t,a,o)}function ReadableStreamBYOBReaderRelease(r){ReadableStreamReaderGenericRelease(r);let t=TypeError("Reader was released");ReadableStreamBYOBReaderErrorReadIntoRequests(r,t)}function ReadableStreamBYOBReaderErrorReadIntoRequests(r,t){let a=r._readIntoRequests;r._readIntoRequests=new SimpleQueue,a.forEach(r=>{r._errorSteps(t)})}function byobReaderBrandCheckException(r){return TypeError(`ReadableStreamBYOBReader.prototype.${r} can only be used on a ReadableStreamBYOBReader`)}function ExtractHighWaterMark(r,t){let{highWaterMark:a}=r;if(void 0===a)return t;if(R(a)||a<0)throw RangeError("Invalid highWaterMark");return a}function ExtractSizeAlgorithm(r){let{size:t}=r;return t||(()=>1)}function convertQueuingStrategy(r,t){assertDictionary(r,t);let a=null==r?void 0:r.highWaterMark,o=null==r?void 0:r.size;return{highWaterMark:void 0===a?void 0:convertUnrestrictedDouble(a),size:void 0===o?void 0:convertQueuingStrategySize(o,`${t} has member 'size' that`)}}function convertQueuingStrategySize(r,t){return assertFunction(r,t),t=>convertUnrestrictedDouble(r(t))}function convertUnderlyingSink(r,t){assertDictionary(r,t);let a=null==r?void 0:r.abort,o=null==r?void 0:r.close,l=null==r?void 0:r.start,n=null==r?void 0:r.type,i=null==r?void 0:r.write;return{abort:void 0===a?void 0:convertUnderlyingSinkAbortCallback(a,r,`${t} has member 'abort' that`),close:void 0===o?void 0:convertUnderlyingSinkCloseCallback(o,r,`${t} has member 'close' that`),start:void 0===l?void 0:convertUnderlyingSinkStartCallback(l,r,`${t} has member 'start' that`),write:void 0===i?void 0:convertUnderlyingSinkWriteCallback(i,r,`${t} has member 'write' that`),type:n}}function convertUnderlyingSinkAbortCallback(r,t,a){return assertFunction(r,a),a=>promiseCall(r,t,[a])}function convertUnderlyingSinkCloseCallback(r,t,a){return assertFunction(r,a),()=>promiseCall(r,t,[])}function convertUnderlyingSinkStartCallback(r,t,a){return assertFunction(r,a),a=>reflectCall(r,t,[a])}function convertUnderlyingSinkWriteCallback(r,t,a){return assertFunction(r,a),(a,o)=>promiseCall(r,t,[a,o])}function assertWritableStream(r,t){if(!IsWritableStream(r))throw TypeError(`${t} is not a WritableStream.`)}function isAbortSignal(r){if("object"!=typeof r||null===r)return!1;try{return"boolean"==typeof r.aborted}catch(r){return!1}}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),setFunctionName(ReadableStreamBYOBReader.prototype.cancel,"cancel"),setFunctionName(ReadableStreamBYOBReader.prototype.read,"read"),setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock,"releaseLock"),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableStreamBYOBReader.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});let C="function"==typeof AbortController;function createAbortController(){if(C)return new AbortController}let WritableStream=class WritableStream{constructor(r={},t={}){void 0===r?r=null:assertObject(r,"First parameter");let a=convertQueuingStrategy(t,"Second parameter"),o=convertUnderlyingSink(r,"First parameter");InitializeWritableStream(this);let l=o.type;if(void 0!==l)throw RangeError("Invalid type is specified");let n=ExtractSizeAlgorithm(a),i=ExtractHighWaterMark(a,1);SetUpWritableStreamDefaultControllerFromUnderlyingSink(this,o,i,n)}get locked(){if(!IsWritableStream(this))throw streamBrandCheckException$2("locked");return IsWritableStreamLocked(this)}abort(r){return IsWritableStream(this)?IsWritableStreamLocked(this)?s(TypeError("Cannot abort a stream that already has a writer")):WritableStreamAbort(this,r):s(streamBrandCheckException$2("abort"))}close(){return IsWritableStream(this)?IsWritableStreamLocked(this)?s(TypeError("Cannot close a stream that already has a writer")):WritableStreamCloseQueuedOrInFlight(this)?s(TypeError("Cannot close an already-closing stream")):WritableStreamClose(this):s(streamBrandCheckException$2("close"))}getWriter(){if(!IsWritableStream(this))throw streamBrandCheckException$2("getWriter");return new WritableStreamDefaultWriter(this)}};function CreateWritableStream(r,t,a,o,l=1,n=()=>1){let i=Object.create(WritableStream.prototype);InitializeWritableStream(i);let s=Object.create(WritableStreamDefaultController.prototype);return SetUpWritableStreamDefaultController(i,s,r,t,a,o,l,n),i}function InitializeWritableStream(r){r._state="writable",r._storedError=void 0,r._writer=void 0,r._writableStreamController=void 0,r._writeRequests=new SimpleQueue,r._inFlightWriteRequest=void 0,r._closeRequest=void 0,r._inFlightCloseRequest=void 0,r._pendingAbortRequest=void 0,r._backpressure=!1}function IsWritableStream(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_writableStreamController"))&&r instanceof WritableStream}function IsWritableStreamLocked(r){return void 0!==r._writer}function WritableStreamAbort(r,t){var a;if("closed"===r._state||"errored"===r._state)return promiseResolvedWith(void 0);r._writableStreamController._abortReason=t,null===(a=r._writableStreamController._abortController)||void 0===a||a.abort(t);let o=r._state;if("closed"===o||"errored"===o)return promiseResolvedWith(void 0);if(void 0!==r._pendingAbortRequest)return r._pendingAbortRequest._promise;let l=!1;"erroring"===o&&(l=!0,t=void 0);let n=newPromise((a,o)=>{r._pendingAbortRequest={_promise:void 0,_resolve:a,_reject:o,_reason:t,_wasAlreadyErroring:l}});return r._pendingAbortRequest._promise=n,l||WritableStreamStartErroring(r,t),n}function WritableStreamClose(r){let t=r._state;if("closed"===t||"errored"===t)return s(TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));let a=newPromise((t,a)=>{r._closeRequest={_resolve:t,_reject:a}}),o=r._writer;return void 0!==o&&r._backpressure&&"writable"===t&&defaultWriterReadyPromiseResolve(o),WritableStreamDefaultControllerClose(r._writableStreamController),a}function WritableStreamAddWriteRequest(r){let t=newPromise((t,a)=>{r._writeRequests.push({_resolve:t,_reject:a})});return t}function WritableStreamDealWithRejection(r,t){let a=r._state;if("writable"===a){WritableStreamStartErroring(r,t);return}WritableStreamFinishErroring(r)}function WritableStreamStartErroring(r,t){let a=r._writableStreamController;r._state="erroring",r._storedError=t;let o=r._writer;void 0!==o&&WritableStreamDefaultWriterEnsureReadyPromiseRejected(o,t),!WritableStreamHasOperationMarkedInFlight(r)&&a._started&&WritableStreamFinishErroring(r)}function WritableStreamFinishErroring(r){r._state="errored",r._writableStreamController[d]();let t=r._storedError;if(r._writeRequests.forEach(r=>{r._reject(t)}),r._writeRequests=new SimpleQueue,void 0===r._pendingAbortRequest){WritableStreamRejectCloseAndClosedPromiseIfNeeded(r);return}let a=r._pendingAbortRequest;if(r._pendingAbortRequest=void 0,a._wasAlreadyErroring){a._reject(t),WritableStreamRejectCloseAndClosedPromiseIfNeeded(r);return}let o=r._writableStreamController[u](a._reason);uponPromise(o,()=>(a._resolve(),WritableStreamRejectCloseAndClosedPromiseIfNeeded(r),null),t=>(a._reject(t),WritableStreamRejectCloseAndClosedPromiseIfNeeded(r),null))}function WritableStreamFinishInFlightWrite(r){r._inFlightWriteRequest._resolve(void 0),r._inFlightWriteRequest=void 0}function WritableStreamFinishInFlightWriteWithError(r,t){r._inFlightWriteRequest._reject(t),r._inFlightWriteRequest=void 0,WritableStreamDealWithRejection(r,t)}function WritableStreamFinishInFlightClose(r){r._inFlightCloseRequest._resolve(void 0),r._inFlightCloseRequest=void 0;let t=r._state;"erroring"===t&&(r._storedError=void 0,void 0!==r._pendingAbortRequest&&(r._pendingAbortRequest._resolve(),r._pendingAbortRequest=void 0)),r._state="closed";let a=r._writer;void 0!==a&&defaultWriterClosedPromiseResolve(a)}function WritableStreamFinishInFlightCloseWithError(r,t){r._inFlightCloseRequest._reject(t),r._inFlightCloseRequest=void 0,void 0!==r._pendingAbortRequest&&(r._pendingAbortRequest._reject(t),r._pendingAbortRequest=void 0),WritableStreamDealWithRejection(r,t)}function WritableStreamCloseQueuedOrInFlight(r){return void 0!==r._closeRequest||void 0!==r._inFlightCloseRequest}function WritableStreamHasOperationMarkedInFlight(r){return void 0!==r._inFlightWriteRequest||void 0!==r._inFlightCloseRequest}function WritableStreamMarkCloseRequestInFlight(r){r._inFlightCloseRequest=r._closeRequest,r._closeRequest=void 0}function WritableStreamMarkFirstWriteRequestInFlight(r){r._inFlightWriteRequest=r._writeRequests.shift()}function WritableStreamRejectCloseAndClosedPromiseIfNeeded(r){void 0!==r._closeRequest&&(r._closeRequest._reject(r._storedError),r._closeRequest=void 0);let t=r._writer;void 0!==t&&defaultWriterClosedPromiseReject(t,r._storedError)}function WritableStreamUpdateBackpressure(r,t){let a=r._writer;void 0!==a&&t!==r._backpressure&&(t?defaultWriterReadyPromiseReset(a):defaultWriterReadyPromiseResolve(a)),r._backpressure=t}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),setFunctionName(WritableStream.prototype.abort,"abort"),setFunctionName(WritableStream.prototype.close,"close"),setFunctionName(WritableStream.prototype.getWriter,"getWriter"),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(WritableStream.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:!0});let WritableStreamDefaultWriter=class WritableStreamDefaultWriter{constructor(r){if(assertRequiredArgument(r,1,"WritableStreamDefaultWriter"),assertWritableStream(r,"First parameter"),IsWritableStreamLocked(r))throw TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=r,r._writer=this;let t=r._state;if("writable"===t)!WritableStreamCloseQueuedOrInFlight(r)&&r._backpressure?defaultWriterReadyPromiseInitialize(this):(defaultWriterReadyPromiseInitialize(this),defaultWriterReadyPromiseResolve(this)),defaultWriterClosedPromiseInitialize(this);else if("erroring"===t)defaultWriterReadyPromiseInitializeAsRejected(this,r._storedError),defaultWriterClosedPromiseInitialize(this);else if("closed"===t)defaultWriterReadyPromiseInitialize(this),defaultWriterReadyPromiseResolve(this),defaultWriterClosedPromiseInitializeAsResolved(this);else{let t=r._storedError;defaultWriterReadyPromiseInitializeAsRejected(this,t),defaultWriterClosedPromiseInitialize(this),defaultWriterClosedPromiseReject(this,t)}}get closed(){return IsWritableStreamDefaultWriter(this)?this._closedPromise:s(defaultWriterBrandCheckException("closed"))}get desiredSize(){if(!IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("desiredSize");if(void 0===this._ownerWritableStream)throw defaultWriterLockException("desiredSize");return WritableStreamDefaultWriterGetDesiredSize(this)}get ready(){return IsWritableStreamDefaultWriter(this)?this._readyPromise:s(defaultWriterBrandCheckException("ready"))}abort(r){return IsWritableStreamDefaultWriter(this)?void 0===this._ownerWritableStream?s(defaultWriterLockException("abort")):WritableStreamDefaultWriterAbort(this,r):s(defaultWriterBrandCheckException("abort"))}close(){if(!IsWritableStreamDefaultWriter(this))return s(defaultWriterBrandCheckException("close"));let r=this._ownerWritableStream;return void 0===r?s(defaultWriterLockException("close")):WritableStreamCloseQueuedOrInFlight(r)?s(TypeError("Cannot close an already-closing stream")):WritableStreamDefaultWriterClose(this)}releaseLock(){if(!IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("releaseLock");let r=this._ownerWritableStream;void 0!==r&&WritableStreamDefaultWriterRelease(this)}write(r){return IsWritableStreamDefaultWriter(this)?void 0===this._ownerWritableStream?s(defaultWriterLockException("write to")):WritableStreamDefaultWriterWrite(this,r):s(defaultWriterBrandCheckException("write"))}};function IsWritableStreamDefaultWriter(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_ownerWritableStream"))&&r instanceof WritableStreamDefaultWriter}function WritableStreamDefaultWriterAbort(r,t){let a=r._ownerWritableStream;return WritableStreamAbort(a,t)}function WritableStreamDefaultWriterClose(r){let t=r._ownerWritableStream;return WritableStreamClose(t)}function WritableStreamDefaultWriterCloseWithErrorPropagation(r){let t=r._ownerWritableStream,a=t._state;return WritableStreamCloseQueuedOrInFlight(t)||"closed"===a?promiseResolvedWith(void 0):"errored"===a?s(t._storedError):WritableStreamDefaultWriterClose(r)}function WritableStreamDefaultWriterEnsureClosedPromiseRejected(r,t){"pending"===r._closedPromiseState?defaultWriterClosedPromiseReject(r,t):defaultWriterClosedPromiseResetToRejected(r,t)}function WritableStreamDefaultWriterEnsureReadyPromiseRejected(r,t){"pending"===r._readyPromiseState?defaultWriterReadyPromiseReject(r,t):defaultWriterReadyPromiseResetToRejected(r,t)}function WritableStreamDefaultWriterGetDesiredSize(r){let t=r._ownerWritableStream,a=t._state;return"errored"===a||"erroring"===a?null:"closed"===a?0:WritableStreamDefaultControllerGetDesiredSize(t._writableStreamController)}function WritableStreamDefaultWriterRelease(r){let t=r._ownerWritableStream,a=TypeError("Writer was released and can no longer be used to monitor the stream's closedness");WritableStreamDefaultWriterEnsureReadyPromiseRejected(r,a),WritableStreamDefaultWriterEnsureClosedPromiseRejected(r,a),t._writer=void 0,r._ownerWritableStream=void 0}function WritableStreamDefaultWriterWrite(r,t){let a=r._ownerWritableStream,o=a._writableStreamController,l=WritableStreamDefaultControllerGetChunkSize(o,t);if(a!==r._ownerWritableStream)return s(defaultWriterLockException("write to"));let n=a._state;if("errored"===n)return s(a._storedError);if(WritableStreamCloseQueuedOrInFlight(a)||"closed"===n)return s(TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===n)return s(a._storedError);let i=WritableStreamAddWriteRequest(a);return WritableStreamDefaultControllerWrite(o,t,l),i}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),setFunctionName(WritableStreamDefaultWriter.prototype.abort,"abort"),setFunctionName(WritableStreamDefaultWriter.prototype.close,"close"),setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock,"releaseLock"),setFunctionName(WritableStreamDefaultWriter.prototype.write,"write"),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(WritableStreamDefaultWriter.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});let _={};let WritableStreamDefaultController=class WritableStreamDefaultController{constructor(){throw TypeError("Illegal constructor")}get abortReason(){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("abortReason");return this._abortReason}get signal(){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("signal");if(void 0===this._abortController)throw TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(r){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("error");let t=this._controlledWritableStream._state;"writable"===t&&WritableStreamDefaultControllerError(this,r)}[u](r){let t=this._abortAlgorithm(r);return WritableStreamDefaultControllerClearAlgorithms(this),t}[d](){ResetQueue(this)}};function IsWritableStreamDefaultController(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_controlledWritableStream"))&&r instanceof WritableStreamDefaultController}function SetUpWritableStreamDefaultController(r,t,a,o,l,n,i,s){t._controlledWritableStream=r,r._writableStreamController=t,t._queue=void 0,t._queueTotalSize=void 0,ResetQueue(t),t._abortReason=void 0,t._abortController=createAbortController(),t._started=!1,t._strategySizeAlgorithm=s,t._strategyHWM=i,t._writeAlgorithm=o,t._closeAlgorithm=l,t._abortAlgorithm=n;let u=WritableStreamDefaultControllerGetBackpressure(t);WritableStreamUpdateBackpressure(r,u);let d=a(),c=promiseResolvedWith(d);uponPromise(c,()=>(t._started=!0,WritableStreamDefaultControllerAdvanceQueueIfNeeded(t),null),a=>(t._started=!0,WritableStreamDealWithRejection(r,a),null))}function SetUpWritableStreamDefaultControllerFromUnderlyingSink(r,t,a,o){let l,n;let i=Object.create(WritableStreamDefaultController.prototype);l=void 0!==t.start?()=>t.start(i):()=>void 0,n=void 0!==t.write?r=>t.write(r,i):()=>promiseResolvedWith(void 0),SetUpWritableStreamDefaultController(r,i,l,n,void 0!==t.close?()=>t.close():()=>promiseResolvedWith(void 0),void 0!==t.abort?r=>t.abort(r):()=>promiseResolvedWith(void 0),a,o)}function WritableStreamDefaultControllerClearAlgorithms(r){r._writeAlgorithm=void 0,r._closeAlgorithm=void 0,r._abortAlgorithm=void 0,r._strategySizeAlgorithm=void 0}function WritableStreamDefaultControllerClose(r){EnqueueValueWithSize(r,_,0),WritableStreamDefaultControllerAdvanceQueueIfNeeded(r)}function WritableStreamDefaultControllerGetChunkSize(r,t){try{return r._strategySizeAlgorithm(t)}catch(t){return WritableStreamDefaultControllerErrorIfNeeded(r,t),1}}function WritableStreamDefaultControllerGetDesiredSize(r){return r._strategyHWM-r._queueTotalSize}function WritableStreamDefaultControllerWrite(r,t,a){try{EnqueueValueWithSize(r,t,a)}catch(t){WritableStreamDefaultControllerErrorIfNeeded(r,t);return}let o=r._controlledWritableStream;if(!WritableStreamCloseQueuedOrInFlight(o)&&"writable"===o._state){let t=WritableStreamDefaultControllerGetBackpressure(r);WritableStreamUpdateBackpressure(o,t)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(r)}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(r){let t=r._controlledWritableStream;if(!r._started||void 0!==t._inFlightWriteRequest)return;let a=t._state;if("erroring"===a){WritableStreamFinishErroring(t);return}if(0===r._queue.length)return;let o=PeekQueueValue(r);o===_?WritableStreamDefaultControllerProcessClose(r):WritableStreamDefaultControllerProcessWrite(r,o)}function WritableStreamDefaultControllerErrorIfNeeded(r,t){"writable"===r._controlledWritableStream._state&&WritableStreamDefaultControllerError(r,t)}function WritableStreamDefaultControllerProcessClose(r){let t=r._controlledWritableStream;WritableStreamMarkCloseRequestInFlight(t),DequeueValue(r);let a=r._closeAlgorithm();WritableStreamDefaultControllerClearAlgorithms(r),uponPromise(a,()=>(WritableStreamFinishInFlightClose(t),null),r=>(WritableStreamFinishInFlightCloseWithError(t,r),null))}function WritableStreamDefaultControllerProcessWrite(r,t){let a=r._controlledWritableStream;WritableStreamMarkFirstWriteRequestInFlight(a);let o=r._writeAlgorithm(t);uponPromise(o,()=>{WritableStreamFinishInFlightWrite(a);let t=a._state;if(DequeueValue(r),!WritableStreamCloseQueuedOrInFlight(a)&&"writable"===t){let t=WritableStreamDefaultControllerGetBackpressure(r);WritableStreamUpdateBackpressure(a,t)}return WritableStreamDefaultControllerAdvanceQueueIfNeeded(r),null},t=>("writable"===a._state&&WritableStreamDefaultControllerClearAlgorithms(r),WritableStreamFinishInFlightWriteWithError(a,t),null))}function WritableStreamDefaultControllerGetBackpressure(r){let t=WritableStreamDefaultControllerGetDesiredSize(r);return t<=0}function WritableStreamDefaultControllerError(r,t){let a=r._controlledWritableStream;WritableStreamDefaultControllerClearAlgorithms(r),WritableStreamStartErroring(a,t)}function streamBrandCheckException$2(r){return TypeError(`WritableStream.prototype.${r} can only be used on a WritableStream`)}function defaultControllerBrandCheckException$2(r){return TypeError(`WritableStreamDefaultController.prototype.${r} can only be used on a WritableStreamDefaultController`)}function defaultWriterBrandCheckException(r){return TypeError(`WritableStreamDefaultWriter.prototype.${r} can only be used on a WritableStreamDefaultWriter`)}function defaultWriterLockException(r){return TypeError("Cannot "+r+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(r){r._closedPromise=newPromise((t,a)=>{r._closedPromise_resolve=t,r._closedPromise_reject=a,r._closedPromiseState="pending"})}function defaultWriterClosedPromiseInitializeAsResolved(r){defaultWriterClosedPromiseInitialize(r),defaultWriterClosedPromiseResolve(r)}function defaultWriterClosedPromiseReject(r,t){void 0!==r._closedPromise_reject&&(setPromiseIsHandledToTrue(r._closedPromise),r._closedPromise_reject(t),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0,r._closedPromiseState="rejected")}function defaultWriterClosedPromiseResetToRejected(r,t){defaultWriterClosedPromiseInitialize(r),defaultWriterClosedPromiseReject(r,t)}function defaultWriterClosedPromiseResolve(r){void 0!==r._closedPromise_resolve&&(r._closedPromise_resolve(void 0),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0,r._closedPromiseState="resolved")}function defaultWriterReadyPromiseInitialize(r){r._readyPromise=newPromise((t,a)=>{r._readyPromise_resolve=t,r._readyPromise_reject=a}),r._readyPromiseState="pending"}function defaultWriterReadyPromiseInitializeAsRejected(r,t){defaultWriterReadyPromiseInitialize(r),defaultWriterReadyPromiseReject(r,t)}function defaultWriterReadyPromiseReject(r,t){void 0!==r._readyPromise_reject&&(setPromiseIsHandledToTrue(r._readyPromise),r._readyPromise_reject(t),r._readyPromise_resolve=void 0,r._readyPromise_reject=void 0,r._readyPromiseState="rejected")}function defaultWriterReadyPromiseReset(r){defaultWriterReadyPromiseInitialize(r)}function defaultWriterReadyPromiseResetToRejected(r,t){defaultWriterReadyPromiseInitializeAsRejected(r,t)}function defaultWriterReadyPromiseResolve(r){void 0!==r._readyPromise_resolve&&(r._readyPromise_resolve(void 0),r._readyPromise_resolve=void 0,r._readyPromise_reject=void 0,r._readyPromiseState="fulfilled")}function getGlobals(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof global?global:void 0}Object.defineProperties(WritableStreamDefaultController.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(WritableStreamDefaultController.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});let v=getGlobals();function isDOMExceptionConstructor(r){if(!("function"==typeof r||"object"==typeof r)||"DOMException"!==r.name)return!1;try{return new r,!0}catch(r){return!1}}function getFromGlobal(){let r=null==v?void 0:v.DOMException;return isDOMExceptionConstructor(r)?r:void 0}function createPolyfill(){let ctor=function(r,t){this.message=r||"",this.name=t||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return setFunctionName(ctor,"DOMException"),ctor.prototype=Object.create(Error.prototype),Object.defineProperty(ctor.prototype,"constructor",{value:ctor,writable:!0,configurable:!0}),ctor}let w=getFromGlobal()||createPolyfill();function ReadableStreamPipeTo(r,t,a,o,l,n){let i=AcquireReadableStreamDefaultReader(r),s=new WritableStreamDefaultWriter(t);r._disturbed=!0;let u=!1,d=promiseResolvedWith(void 0);return newPromise((c,m)=>{let b;if(void 0!==n){if(b=()=>{let a=void 0!==n.reason?n.reason:new w("Aborted","AbortError"),i=[];o||i.push(()=>"writable"===t._state?WritableStreamAbort(t,a):promiseResolvedWith(void 0)),l||i.push(()=>"readable"===r._state?ReadableStreamCancel(r,a):promiseResolvedWith(void 0)),shutdownWithAction(()=>Promise.all(i.map(r=>r())),!0,a)},n.aborted){b();return}n.addEventListener("abort",b)}function pipeLoop(){return newPromise((r,t)=>{function next(a){a?r():PerformPromiseThen(pipeStep(),next,t)}next(!1)})}function pipeStep(){return u?promiseResolvedWith(!0):PerformPromiseThen(s._readyPromise,()=>newPromise((r,t)=>{ReadableStreamDefaultReaderRead(i,{_chunkSteps:t=>{d=PerformPromiseThen(WritableStreamDefaultWriterWrite(s,t),void 0,noop),r(!1)},_closeSteps:()=>r(!0),_errorSteps:t})}))}if(isOrBecomesErrored(r,i._closedPromise,r=>(o?shutdown(!0,r):shutdownWithAction(()=>WritableStreamAbort(t,r),!0,r),null)),isOrBecomesErrored(t,s._closedPromise,t=>(l?shutdown(!0,t):shutdownWithAction(()=>ReadableStreamCancel(r,t),!0,t),null)),isOrBecomesClosed(r,i._closedPromise,()=>(a?shutdown():shutdownWithAction(()=>WritableStreamDefaultWriterCloseWithErrorPropagation(s)),null)),WritableStreamCloseQueuedOrInFlight(t)||"closed"===t._state){let t=TypeError("the destination writable stream closed before all data could be piped to it");l?shutdown(!0,t):shutdownWithAction(()=>ReadableStreamCancel(r,t),!0,t)}function waitForWritesToFinish(){let r=d;return PerformPromiseThen(d,()=>r!==d?waitForWritesToFinish():void 0)}function isOrBecomesErrored(r,t,a){"errored"===r._state?a(r._storedError):uponRejection(t,a)}function isOrBecomesClosed(r,t,a){"closed"===r._state?a():uponPromise(t,a)}function shutdownWithAction(r,a,o){!u&&((u=!0,"writable"!==t._state||WritableStreamCloseQueuedOrInFlight(t))?doTheRest():uponPromise(waitForWritesToFinish(),doTheRest));function doTheRest(){return uponPromise(r(),()=>finalize(a,o),r=>finalize(!0,r)),null}}function shutdown(r,a){!u&&((u=!0,"writable"!==t._state||WritableStreamCloseQueuedOrInFlight(t))?finalize(r,a):uponPromise(waitForWritesToFinish(),()=>finalize(r,a)))}function finalize(r,t){return WritableStreamDefaultWriterRelease(s),ReadableStreamReaderGenericRelease(i),void 0!==n&&n.removeEventListener("abort",b),r?m(t):c(void 0),null}setPromiseIsHandledToTrue(pipeLoop())})}let ReadableStreamDefaultController=class ReadableStreamDefaultController{constructor(){throw TypeError("Illegal constructor")}get desiredSize(){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("desiredSize");return ReadableStreamDefaultControllerGetDesiredSize(this)}close(){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("close");if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw TypeError("The stream is not in a state that permits close");ReadableStreamDefaultControllerClose(this)}enqueue(r){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("enqueue");if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw TypeError("The stream is not in a state that permits enqueue");return ReadableStreamDefaultControllerEnqueue(this,r)}error(r){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("error");ReadableStreamDefaultControllerError(this,r)}[c](r){ResetQueue(this);let t=this._cancelAlgorithm(r);return ReadableStreamDefaultControllerClearAlgorithms(this),t}[m](r){let t=this._controlledReadableStream;if(this._queue.length>0){let a=DequeueValue(this);this._closeRequested&&0===this._queue.length?(ReadableStreamDefaultControllerClearAlgorithms(this),ReadableStreamClose(t)):ReadableStreamDefaultControllerCallPullIfNeeded(this),r._chunkSteps(a)}else ReadableStreamAddReadRequest(t,r),ReadableStreamDefaultControllerCallPullIfNeeded(this)}[b](){}};function IsReadableStreamDefaultController(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_controlledReadableStream"))&&r instanceof ReadableStreamDefaultController}function ReadableStreamDefaultControllerCallPullIfNeeded(r){let t=ReadableStreamDefaultControllerShouldCallPull(r);if(!t)return;if(r._pulling){r._pullAgain=!0;return}r._pulling=!0;let a=r._pullAlgorithm();uponPromise(a,()=>(r._pulling=!1,r._pullAgain&&(r._pullAgain=!1,ReadableStreamDefaultControllerCallPullIfNeeded(r)),null),t=>(ReadableStreamDefaultControllerError(r,t),null))}function ReadableStreamDefaultControllerShouldCallPull(r){let t=r._controlledReadableStream;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(r)||!r._started)return!1;if(IsReadableStreamLocked(t)&&ReadableStreamGetNumReadRequests(t)>0)return!0;let a=ReadableStreamDefaultControllerGetDesiredSize(r);return a>0}function ReadableStreamDefaultControllerClearAlgorithms(r){r._pullAlgorithm=void 0,r._cancelAlgorithm=void 0,r._strategySizeAlgorithm=void 0}function ReadableStreamDefaultControllerClose(r){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(r))return;let t=r._controlledReadableStream;r._closeRequested=!0,0===r._queue.length&&(ReadableStreamDefaultControllerClearAlgorithms(r),ReadableStreamClose(t))}function ReadableStreamDefaultControllerEnqueue(r,t){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(r))return;let a=r._controlledReadableStream;if(IsReadableStreamLocked(a)&&ReadableStreamGetNumReadRequests(a)>0)ReadableStreamFulfillReadRequest(a,t,!1);else{let a;try{a=r._strategySizeAlgorithm(t)}catch(t){throw ReadableStreamDefaultControllerError(r,t),t}try{EnqueueValueWithSize(r,t,a)}catch(t){throw ReadableStreamDefaultControllerError(r,t),t}}ReadableStreamDefaultControllerCallPullIfNeeded(r)}function ReadableStreamDefaultControllerError(r,t){let a=r._controlledReadableStream;"readable"===a._state&&(ResetQueue(r),ReadableStreamDefaultControllerClearAlgorithms(r),ReadableStreamError(a,t))}function ReadableStreamDefaultControllerGetDesiredSize(r){let t=r._controlledReadableStream._state;return"errored"===t?null:"closed"===t?0:r._strategyHWM-r._queueTotalSize}function ReadableStreamDefaultControllerHasBackpressure(r){return!ReadableStreamDefaultControllerShouldCallPull(r)}function ReadableStreamDefaultControllerCanCloseOrEnqueue(r){let t=r._controlledReadableStream._state;return!r._closeRequested&&"readable"===t}function SetUpReadableStreamDefaultController(r,t,a,o,l,n,i){t._controlledReadableStream=r,t._queue=void 0,t._queueTotalSize=void 0,ResetQueue(t),t._started=!1,t._closeRequested=!1,t._pullAgain=!1,t._pulling=!1,t._strategySizeAlgorithm=i,t._strategyHWM=n,t._pullAlgorithm=o,t._cancelAlgorithm=l,r._readableStreamController=t;let s=a();uponPromise(promiseResolvedWith(s),()=>(t._started=!0,ReadableStreamDefaultControllerCallPullIfNeeded(t),null),r=>(ReadableStreamDefaultControllerError(t,r),null))}function SetUpReadableStreamDefaultControllerFromUnderlyingSource(r,t,a,o){let l,n;let i=Object.create(ReadableStreamDefaultController.prototype);l=void 0!==t.start?()=>t.start(i):()=>void 0,n=void 0!==t.pull?()=>t.pull(i):()=>promiseResolvedWith(void 0),SetUpReadableStreamDefaultController(r,i,l,n,void 0!==t.cancel?r=>t.cancel(r):()=>promiseResolvedWith(void 0),a,o)}function defaultControllerBrandCheckException$1(r){return TypeError(`ReadableStreamDefaultController.prototype.${r} can only be used on a ReadableStreamDefaultController`)}function ReadableStreamTee(r,t){return IsReadableByteStreamController(r._readableStreamController)?ReadableByteStreamTee(r):ReadableStreamDefaultTee(r)}function ReadableStreamDefaultTee(r,t){let a,o,l,n,i;let s=AcquireReadableStreamDefaultReader(r),u=!1,d=!1,c=!1,m=!1,b=newPromise(r=>{i=r});function pullAlgorithm(){return u?d=!0:(u=!0,ReadableStreamDefaultReaderRead(s,{_chunkSteps:r=>{_queueMicrotask(()=>{d=!1,c||ReadableStreamDefaultControllerEnqueue(l._readableStreamController,r),m||ReadableStreamDefaultControllerEnqueue(n._readableStreamController,r),u=!1,d&&pullAlgorithm()})},_closeSteps:()=>{u=!1,c||ReadableStreamDefaultControllerClose(l._readableStreamController),m||ReadableStreamDefaultControllerClose(n._readableStreamController),c&&m||i(void 0)},_errorSteps:()=>{u=!1}})),promiseResolvedWith(void 0)}function cancel2Algorithm(t){if(m=!0,o=t,c){let t=CreateArrayFromList([a,o]),l=ReadableStreamCancel(r,t);i(l)}return b}function startAlgorithm(){}return l=CreateReadableStream(startAlgorithm,pullAlgorithm,function(t){if(c=!0,a=t,m){let t=CreateArrayFromList([a,o]),l=ReadableStreamCancel(r,t);i(l)}return b}),n=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel2Algorithm),uponRejection(s._closedPromise,r=>(ReadableStreamDefaultControllerError(l._readableStreamController,r),ReadableStreamDefaultControllerError(n._readableStreamController,r),c&&m||i(void 0),null)),[l,n]}function ReadableByteStreamTee(r){let t,a,o,l,n,i=AcquireReadableStreamDefaultReader(r),s=!1,u=!1,d=!1,c=!1,m=!1,b=newPromise(r=>{n=r});function forwardReaderError(r){uponRejection(r._closedPromise,t=>(r!==i||(ReadableByteStreamControllerError(o._readableStreamController,t),ReadableByteStreamControllerError(l._readableStreamController,t),c&&m||n(void 0)),null))}function pullWithDefaultReader(){IsReadableStreamBYOBReader(i)&&(ReadableStreamReaderGenericRelease(i),forwardReaderError(i=AcquireReadableStreamDefaultReader(r))),ReadableStreamDefaultReaderRead(i,{_chunkSteps:t=>{_queueMicrotask(()=>{u=!1,d=!1;let a=t;if(!c&&!m)try{a=CloneAsUint8Array(t)}catch(t){ReadableByteStreamControllerError(o._readableStreamController,t),ReadableByteStreamControllerError(l._readableStreamController,t),n(ReadableStreamCancel(r,t));return}c||ReadableByteStreamControllerEnqueue(o._readableStreamController,t),m||ReadableByteStreamControllerEnqueue(l._readableStreamController,a),s=!1,u?pull1Algorithm():d&&pull2Algorithm()})},_closeSteps:()=>{s=!1,c||ReadableByteStreamControllerClose(o._readableStreamController),m||ReadableByteStreamControllerClose(l._readableStreamController),o._readableStreamController._pendingPullIntos.length>0&&ReadableByteStreamControllerRespond(o._readableStreamController,0),l._readableStreamController._pendingPullIntos.length>0&&ReadableByteStreamControllerRespond(l._readableStreamController,0),c&&m||n(void 0)},_errorSteps:()=>{s=!1}})}function pullWithBYOBReader(t,a){IsReadableStreamDefaultReader(i)&&(ReadableStreamReaderGenericRelease(i),forwardReaderError(i=new ReadableStreamBYOBReader(r)));let b=a?l:o,h=a?o:l;ReadableStreamBYOBReaderRead(i,t,1,{_chunkSteps:t=>{_queueMicrotask(()=>{u=!1,d=!1;let o=a?m:c,l=a?c:m;if(l)o||ReadableByteStreamControllerRespondWithNewView(b._readableStreamController,t);else{let a;try{a=CloneAsUint8Array(t)}catch(t){ReadableByteStreamControllerError(b._readableStreamController,t),ReadableByteStreamControllerError(h._readableStreamController,t),n(ReadableStreamCancel(r,t));return}o||ReadableByteStreamControllerRespondWithNewView(b._readableStreamController,t),ReadableByteStreamControllerEnqueue(h._readableStreamController,a)}s=!1,u?pull1Algorithm():d&&pull2Algorithm()})},_closeSteps:r=>{s=!1;let t=a?m:c,o=a?c:m;t||ReadableByteStreamControllerClose(b._readableStreamController),o||ReadableByteStreamControllerClose(h._readableStreamController),void 0!==r&&(t||ReadableByteStreamControllerRespondWithNewView(b._readableStreamController,r),!o&&h._readableStreamController._pendingPullIntos.length>0&&ReadableByteStreamControllerRespond(h._readableStreamController,0)),t&&o||n(void 0)},_errorSteps:()=>{s=!1}})}function pull1Algorithm(){if(s)return u=!0,promiseResolvedWith(void 0);s=!0;let r=ReadableByteStreamControllerGetBYOBRequest(o._readableStreamController);return null===r?pullWithDefaultReader():pullWithBYOBReader(r._view,!1),promiseResolvedWith(void 0)}function pull2Algorithm(){if(s)return d=!0,promiseResolvedWith(void 0);s=!0;let r=ReadableByteStreamControllerGetBYOBRequest(l._readableStreamController);return null===r?pullWithDefaultReader():pullWithBYOBReader(r._view,!0),promiseResolvedWith(void 0)}function cancel2Algorithm(o){if(m=!0,a=o,c){let o=CreateArrayFromList([t,a]),l=ReadableStreamCancel(r,o);n(l)}return b}function startAlgorithm(){}return o=CreateReadableByteStream(startAlgorithm,pull1Algorithm,function(o){if(c=!0,t=o,m){let o=CreateArrayFromList([t,a]),l=ReadableStreamCancel(r,o);n(l)}return b}),l=CreateReadableByteStream(startAlgorithm,pull2Algorithm,cancel2Algorithm),forwardReaderError(i),[o,l]}function isReadableStreamLike(r){return typeIsObject(r)&&void 0!==r.getReader}function ReadableStreamFrom(r){return isReadableStreamLike(r)?ReadableStreamFromDefaultReader(r.getReader()):ReadableStreamFromIterable(r)}function ReadableStreamFromIterable(r){let t;let a=GetIterator(r,"async"),o=noop;return t=CreateReadableStream(o,function(){let r;try{r=IteratorNext(a)}catch(r){return s(r)}let o=promiseResolvedWith(r);return PerformPromiseThen(o,r=>{if(!typeIsObject(r))throw TypeError("The promise returned by the iterator.next() method must fulfill with an object");let a=IteratorComplete(r);if(a)ReadableStreamDefaultControllerClose(t._readableStreamController);else{let a=IteratorValue(r);ReadableStreamDefaultControllerEnqueue(t._readableStreamController,a)}},void 0)},function(r){let t,o;let l=a.iterator;try{t=GetMethod(l,"return")}catch(r){return s(r)}if(void 0===t)return promiseResolvedWith(void 0);try{o=reflectCall(t,l,[r])}catch(r){return s(r)}let n=promiseResolvedWith(o);return PerformPromiseThen(n,r=>{if(!typeIsObject(r))throw TypeError("The promise returned by the iterator.return() method must fulfill with an object")},void 0)},0)}function ReadableStreamFromDefaultReader(r){let t;let a=noop;return t=CreateReadableStream(a,function(){let a;try{a=r.read()}catch(r){return s(r)}return PerformPromiseThen(a,r=>{if(!typeIsObject(r))throw TypeError("The promise returned by the reader.read() method must fulfill with an object");if(r.done)ReadableStreamDefaultControllerClose(t._readableStreamController);else{let a=r.value;ReadableStreamDefaultControllerEnqueue(t._readableStreamController,a)}},void 0)},function(t){try{return promiseResolvedWith(r.cancel(t))}catch(r){return s(r)}},0)}function convertUnderlyingDefaultOrByteSource(r,t){assertDictionary(r,t);let a=null==r?void 0:r.autoAllocateChunkSize,o=null==r?void 0:r.cancel,l=null==r?void 0:r.pull,n=null==r?void 0:r.start,i=null==r?void 0:r.type;return{autoAllocateChunkSize:void 0===a?void 0:convertUnsignedLongLongWithEnforceRange(a,`${t} has member 'autoAllocateChunkSize' that`),cancel:void 0===o?void 0:convertUnderlyingSourceCancelCallback(o,r,`${t} has member 'cancel' that`),pull:void 0===l?void 0:convertUnderlyingSourcePullCallback(l,r,`${t} has member 'pull' that`),start:void 0===n?void 0:convertUnderlyingSourceStartCallback(n,r,`${t} has member 'start' that`),type:void 0===i?void 0:convertReadableStreamType(i,`${t} has member 'type' that`)}}function convertUnderlyingSourceCancelCallback(r,t,a){return assertFunction(r,a),a=>promiseCall(r,t,[a])}function convertUnderlyingSourcePullCallback(r,t,a){return assertFunction(r,a),a=>promiseCall(r,t,[a])}function convertUnderlyingSourceStartCallback(r,t,a){return assertFunction(r,a),a=>reflectCall(r,t,[a])}function convertReadableStreamType(r,t){if("bytes"!=(r=`${r}`))throw TypeError(`${t} '${r}' is not a valid enumeration value for ReadableStreamType`);return r}function convertIteratorOptions(r,t){assertDictionary(r,t);let a=null==r?void 0:r.preventCancel;return{preventCancel:!!a}}function convertPipeOptions(r,t){assertDictionary(r,t);let a=null==r?void 0:r.preventAbort,o=null==r?void 0:r.preventCancel,l=null==r?void 0:r.preventClose,n=null==r?void 0:r.signal;return void 0!==n&&assertAbortSignal(n,`${t} has member 'signal' that`),{preventAbort:!!a,preventCancel:!!o,preventClose:!!l,signal:n}}function assertAbortSignal(r,t){if(!isAbortSignal(r))throw TypeError(`${t} is not an AbortSignal.`)}function convertReadableWritablePair(r,t){assertDictionary(r,t);let a=null==r?void 0:r.readable;assertRequiredField(a,"readable","ReadableWritablePair"),assertReadableStream(a,`${t} has member 'readable' that`);let o=null==r?void 0:r.writable;return assertRequiredField(o,"writable","ReadableWritablePair"),assertWritableStream(o,`${t} has member 'writable' that`),{readable:a,writable:o}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),setFunctionName(ReadableStreamDefaultController.prototype.close,"close"),setFunctionName(ReadableStreamDefaultController.prototype.enqueue,"enqueue"),setFunctionName(ReadableStreamDefaultController.prototype.error,"error"),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableStreamDefaultController.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});let ReadableStream=class ReadableStream{constructor(r={},t={}){void 0===r?r=null:assertObject(r,"First parameter");let a=convertQueuingStrategy(t,"Second parameter"),o=convertUnderlyingDefaultOrByteSource(r,"First parameter");if(InitializeReadableStream(this),"bytes"===o.type){if(void 0!==a.size)throw RangeError("The strategy for a byte stream cannot have a size function");let r=ExtractHighWaterMark(a,0);SetUpReadableByteStreamControllerFromUnderlyingSource(this,o,r)}else{let r=ExtractSizeAlgorithm(a),t=ExtractHighWaterMark(a,1);SetUpReadableStreamDefaultControllerFromUnderlyingSource(this,o,t,r)}}get locked(){if(!IsReadableStream(this))throw streamBrandCheckException$1("locked");return IsReadableStreamLocked(this)}cancel(r){return IsReadableStream(this)?IsReadableStreamLocked(this)?s(TypeError("Cannot cancel a stream that already has a reader")):ReadableStreamCancel(this,r):s(streamBrandCheckException$1("cancel"))}getReader(r){if(!IsReadableStream(this))throw streamBrandCheckException$1("getReader");let t=convertReaderOptions(r,"First parameter");return void 0===t.mode?AcquireReadableStreamDefaultReader(this):new ReadableStreamBYOBReader(this)}pipeThrough(r,t={}){if(!IsReadableStream(this))throw streamBrandCheckException$1("pipeThrough");assertRequiredArgument(r,1,"pipeThrough");let a=convertReadableWritablePair(r,"First parameter"),o=convertPipeOptions(t,"Second parameter");if(IsReadableStreamLocked(this))throw TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(IsWritableStreamLocked(a.writable))throw TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");let l=ReadableStreamPipeTo(this,a.writable,o.preventClose,o.preventAbort,o.preventCancel,o.signal);return setPromiseIsHandledToTrue(l),a.readable}pipeTo(r,t={}){let a;if(!IsReadableStream(this))return s(streamBrandCheckException$1("pipeTo"));if(void 0===r)return s("Parameter 1 is required in 'pipeTo'.");if(!IsWritableStream(r))return s(TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));try{a=convertPipeOptions(t,"Second parameter")}catch(r){return s(r)}return IsReadableStreamLocked(this)?s(TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):IsWritableStreamLocked(r)?s(TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):ReadableStreamPipeTo(this,r,a.preventClose,a.preventAbort,a.preventCancel,a.signal)}tee(){if(!IsReadableStream(this))throw streamBrandCheckException$1("tee");let r=ReadableStreamTee(this);return CreateArrayFromList(r)}values(r){if(!IsReadableStream(this))throw streamBrandCheckException$1("values");let t=convertIteratorOptions(r,"First parameter");return AcquireReadableStreamAsyncIterator(this,t.preventCancel)}[g](r){return this.values(r)}static from(r){return ReadableStreamFrom(r)}};function CreateReadableStream(r,t,a,o=1,l=()=>1){let n=Object.create(ReadableStream.prototype);InitializeReadableStream(n);let i=Object.create(ReadableStreamDefaultController.prototype);return SetUpReadableStreamDefaultController(n,i,r,t,a,o,l),n}function CreateReadableByteStream(r,t,a){let o=Object.create(ReadableStream.prototype);InitializeReadableStream(o);let l=Object.create(ReadableByteStreamController.prototype);return SetUpReadableByteStreamController(o,l,r,t,a,0,void 0),o}function InitializeReadableStream(r){r._state="readable",r._reader=void 0,r._storedError=void 0,r._disturbed=!1}function IsReadableStream(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_readableStreamController"))&&r instanceof ReadableStream}function IsReadableStreamLocked(r){return void 0!==r._reader}function ReadableStreamCancel(r,t){if(r._disturbed=!0,"closed"===r._state)return promiseResolvedWith(void 0);if("errored"===r._state)return s(r._storedError);ReadableStreamClose(r);let a=r._reader;if(void 0!==a&&IsReadableStreamBYOBReader(a)){let r=a._readIntoRequests;a._readIntoRequests=new SimpleQueue,r.forEach(r=>{r._closeSteps(void 0)})}let o=r._readableStreamController[c](t);return PerformPromiseThen(o,noop,void 0)}function ReadableStreamClose(r){r._state="closed";let t=r._reader;if(void 0!==t&&(defaultReaderClosedPromiseResolve(t),IsReadableStreamDefaultReader(t))){let r=t._readRequests;t._readRequests=new SimpleQueue,r.forEach(r=>{r._closeSteps()})}}function ReadableStreamError(r,t){r._state="errored",r._storedError=t;let a=r._reader;void 0!==a&&(defaultReaderClosedPromiseReject(a,t),IsReadableStreamDefaultReader(a)?ReadableStreamDefaultReaderErrorReadRequests(a,t):ReadableStreamBYOBReaderErrorReadIntoRequests(a,t))}function streamBrandCheckException$1(r){return TypeError(`ReadableStream.prototype.${r} can only be used on a ReadableStream`)}function convertQueuingStrategyInit(r,t){assertDictionary(r,t);let a=null==r?void 0:r.highWaterMark;return assertRequiredField(a,"highWaterMark","QueuingStrategyInit"),{highWaterMark:convertUnrestrictedDouble(a)}}Object.defineProperties(ReadableStream,{from:{enumerable:!0}}),Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),setFunctionName(ReadableStream.from,"from"),setFunctionName(ReadableStream.prototype.cancel,"cancel"),setFunctionName(ReadableStream.prototype.getReader,"getReader"),setFunctionName(ReadableStream.prototype.pipeThrough,"pipeThrough"),setFunctionName(ReadableStream.prototype.pipeTo,"pipeTo"),setFunctionName(ReadableStream.prototype.tee,"tee"),setFunctionName(ReadableStream.prototype.values,"values"),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ReadableStream.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:!0}),Object.defineProperty(ReadableStream.prototype,g,{value:ReadableStream.prototype.values,writable:!0,configurable:!0});let byteLengthSizeFunction=r=>r.byteLength;setFunctionName(byteLengthSizeFunction,"size");let ByteLengthQueuingStrategy=class ByteLengthQueuingStrategy{constructor(r){assertRequiredArgument(r,1,"ByteLengthQueuingStrategy"),r=convertQueuingStrategyInit(r,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=r.highWaterMark}get highWaterMark(){if(!IsByteLengthQueuingStrategy(this))throw byteLengthBrandCheckException("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!IsByteLengthQueuingStrategy(this))throw byteLengthBrandCheckException("size");return byteLengthSizeFunction}};function byteLengthBrandCheckException(r){return TypeError(`ByteLengthQueuingStrategy.prototype.${r} can only be used on a ByteLengthQueuingStrategy`)}function IsByteLengthQueuingStrategy(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_byteLengthQueuingStrategyHighWaterMark"))&&r instanceof ByteLengthQueuingStrategy}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(ByteLengthQueuingStrategy.prototype,Symbol.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});let countSizeFunction=()=>1;setFunctionName(countSizeFunction,"size");let CountQueuingStrategy=class CountQueuingStrategy{constructor(r){assertRequiredArgument(r,1,"CountQueuingStrategy"),r=convertQueuingStrategyInit(r,"First parameter"),this._countQueuingStrategyHighWaterMark=r.highWaterMark}get highWaterMark(){if(!IsCountQueuingStrategy(this))throw countBrandCheckException("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!IsCountQueuingStrategy(this))throw countBrandCheckException("size");return countSizeFunction}};function countBrandCheckException(r){return TypeError(`CountQueuingStrategy.prototype.${r} can only be used on a CountQueuingStrategy`)}function IsCountQueuingStrategy(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_countQueuingStrategyHighWaterMark"))&&r instanceof CountQueuingStrategy}function convertTransformer(r,t){assertDictionary(r,t);let a=null==r?void 0:r.cancel,o=null==r?void 0:r.flush,l=null==r?void 0:r.readableType,n=null==r?void 0:r.start,i=null==r?void 0:r.transform,s=null==r?void 0:r.writableType;return{cancel:void 0===a?void 0:convertTransformerCancelCallback(a,r,`${t} has member 'cancel' that`),flush:void 0===o?void 0:convertTransformerFlushCallback(o,r,`${t} has member 'flush' that`),readableType:l,start:void 0===n?void 0:convertTransformerStartCallback(n,r,`${t} has member 'start' that`),transform:void 0===i?void 0:convertTransformerTransformCallback(i,r,`${t} has member 'transform' that`),writableType:s}}function convertTransformerFlushCallback(r,t,a){return assertFunction(r,a),a=>promiseCall(r,t,[a])}function convertTransformerStartCallback(r,t,a){return assertFunction(r,a),a=>reflectCall(r,t,[a])}function convertTransformerTransformCallback(r,t,a){return assertFunction(r,a),(a,o)=>promiseCall(r,t,[a,o])}function convertTransformerCancelCallback(r,t,a){return assertFunction(r,a),a=>promiseCall(r,t,[a])}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(CountQueuingStrategy.prototype,Symbol.toStringTag,{value:"CountQueuingStrategy",configurable:!0});let TransformStream=class TransformStream{constructor(r={},t={},a={}){let o;void 0===r&&(r=null);let l=convertQueuingStrategy(t,"Second parameter"),n=convertQueuingStrategy(a,"Third parameter"),i=convertTransformer(r,"First parameter");if(void 0!==i.readableType)throw RangeError("Invalid readableType specified");if(void 0!==i.writableType)throw RangeError("Invalid writableType specified");let s=ExtractHighWaterMark(n,0),u=ExtractSizeAlgorithm(n),d=ExtractHighWaterMark(l,1),c=ExtractSizeAlgorithm(l),m=newPromise(r=>{o=r});InitializeTransformStream(this,m,d,c,s,u),SetUpTransformStreamDefaultControllerFromTransformer(this,i),void 0!==i.start?o(i.start(this._transformStreamController)):o(void 0)}get readable(){if(!IsTransformStream(this))throw streamBrandCheckException("readable");return this._readable}get writable(){if(!IsTransformStream(this))throw streamBrandCheckException("writable");return this._writable}};function InitializeTransformStream(r,t,a,o,l,n){function startAlgorithm(){return t}function writeAlgorithm(t){return TransformStreamDefaultSinkWriteAlgorithm(r,t)}function abortAlgorithm(t){return TransformStreamDefaultSinkAbortAlgorithm(r,t)}function closeAlgorithm(){return TransformStreamDefaultSinkCloseAlgorithm(r)}function pullAlgorithm(){return TransformStreamDefaultSourcePullAlgorithm(r)}function cancelAlgorithm(t){return TransformStreamDefaultSourceCancelAlgorithm(r,t)}r._writable=CreateWritableStream(startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,a,o),r._readable=CreateReadableStream(startAlgorithm,pullAlgorithm,cancelAlgorithm,l,n),r._backpressure=void 0,r._backpressureChangePromise=void 0,r._backpressureChangePromise_resolve=void 0,TransformStreamSetBackpressure(r,!0),r._transformStreamController=void 0}function IsTransformStream(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_transformStreamController"))&&r instanceof TransformStream}function TransformStreamError(r,t){ReadableStreamDefaultControllerError(r._readable._readableStreamController,t),TransformStreamErrorWritableAndUnblockWrite(r,t)}function TransformStreamErrorWritableAndUnblockWrite(r,t){TransformStreamDefaultControllerClearAlgorithms(r._transformStreamController),WritableStreamDefaultControllerErrorIfNeeded(r._writable._writableStreamController,t),TransformStreamUnblockWrite(r)}function TransformStreamUnblockWrite(r){r._backpressure&&TransformStreamSetBackpressure(r,!1)}function TransformStreamSetBackpressure(r,t){void 0!==r._backpressureChangePromise&&r._backpressureChangePromise_resolve(),r._backpressureChangePromise=newPromise(t=>{r._backpressureChangePromise_resolve=t}),r._backpressure=t}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(TransformStream.prototype,Symbol.toStringTag,{value:"TransformStream",configurable:!0});let TransformStreamDefaultController=class TransformStreamDefaultController{constructor(){throw TypeError("Illegal constructor")}get desiredSize(){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("desiredSize");let r=this._controlledTransformStream._readable._readableStreamController;return ReadableStreamDefaultControllerGetDesiredSize(r)}enqueue(r){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("enqueue");TransformStreamDefaultControllerEnqueue(this,r)}error(r){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("error");TransformStreamDefaultControllerError(this,r)}terminate(){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("terminate");TransformStreamDefaultControllerTerminate(this)}};function IsTransformStreamDefaultController(r){return!!(typeIsObject(r)&&Object.prototype.hasOwnProperty.call(r,"_controlledTransformStream"))&&r instanceof TransformStreamDefaultController}function SetUpTransformStreamDefaultController(r,t,a,o,l){t._controlledTransformStream=r,r._transformStreamController=t,t._transformAlgorithm=a,t._flushAlgorithm=o,t._cancelAlgorithm=l,t._finishPromise=void 0,t._finishPromise_resolve=void 0,t._finishPromise_reject=void 0}function SetUpTransformStreamDefaultControllerFromTransformer(r,t){let a,o;let l=Object.create(TransformStreamDefaultController.prototype);a=void 0!==t.transform?r=>t.transform(r,l):r=>{try{return TransformStreamDefaultControllerEnqueue(l,r),promiseResolvedWith(void 0)}catch(r){return s(r)}},o=void 0!==t.flush?()=>t.flush(l):()=>promiseResolvedWith(void 0),SetUpTransformStreamDefaultController(r,l,a,o,void 0!==t.cancel?r=>t.cancel(r):()=>promiseResolvedWith(void 0))}function TransformStreamDefaultControllerClearAlgorithms(r){r._transformAlgorithm=void 0,r._flushAlgorithm=void 0,r._cancelAlgorithm=void 0}function TransformStreamDefaultControllerEnqueue(r,t){let a=r._controlledTransformStream,o=a._readable._readableStreamController;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(o))throw TypeError("Readable side is not in a state that permits enqueue");try{ReadableStreamDefaultControllerEnqueue(o,t)}catch(r){throw TransformStreamErrorWritableAndUnblockWrite(a,r),a._readable._storedError}let l=ReadableStreamDefaultControllerHasBackpressure(o);l!==a._backpressure&&TransformStreamSetBackpressure(a,!0)}function TransformStreamDefaultControllerError(r,t){TransformStreamError(r._controlledTransformStream,t)}function TransformStreamDefaultControllerPerformTransform(r,t){let a=r._transformAlgorithm(t);return PerformPromiseThen(a,void 0,t=>{throw TransformStreamError(r._controlledTransformStream,t),t})}function TransformStreamDefaultControllerTerminate(r){let t=r._controlledTransformStream,a=t._readable._readableStreamController;ReadableStreamDefaultControllerClose(a);let o=TypeError("TransformStream terminated");TransformStreamErrorWritableAndUnblockWrite(t,o)}function TransformStreamDefaultSinkWriteAlgorithm(r,t){let a=r._transformStreamController;if(r._backpressure){let o=r._backpressureChangePromise;return PerformPromiseThen(o,()=>{let o=r._writable,l=o._state;if("erroring"===l)throw o._storedError;return TransformStreamDefaultControllerPerformTransform(a,t)},void 0)}return TransformStreamDefaultControllerPerformTransform(a,t)}function TransformStreamDefaultSinkAbortAlgorithm(r,t){let a=r._transformStreamController;if(void 0!==a._finishPromise)return a._finishPromise;let o=r._readable;a._finishPromise=newPromise((r,t)=>{a._finishPromise_resolve=r,a._finishPromise_reject=t});let l=a._cancelAlgorithm(t);return TransformStreamDefaultControllerClearAlgorithms(a),uponPromise(l,()=>("errored"===o._state?defaultControllerFinishPromiseReject(a,o._storedError):(ReadableStreamDefaultControllerError(o._readableStreamController,t),defaultControllerFinishPromiseResolve(a)),null),r=>(ReadableStreamDefaultControllerError(o._readableStreamController,r),defaultControllerFinishPromiseReject(a,r),null)),a._finishPromise}function TransformStreamDefaultSinkCloseAlgorithm(r){let t=r._transformStreamController;if(void 0!==t._finishPromise)return t._finishPromise;let a=r._readable;t._finishPromise=newPromise((r,a)=>{t._finishPromise_resolve=r,t._finishPromise_reject=a});let o=t._flushAlgorithm();return TransformStreamDefaultControllerClearAlgorithms(t),uponPromise(o,()=>("errored"===a._state?defaultControllerFinishPromiseReject(t,a._storedError):(ReadableStreamDefaultControllerClose(a._readableStreamController),defaultControllerFinishPromiseResolve(t)),null),r=>(ReadableStreamDefaultControllerError(a._readableStreamController,r),defaultControllerFinishPromiseReject(t,r),null)),t._finishPromise}function TransformStreamDefaultSourcePullAlgorithm(r){return TransformStreamSetBackpressure(r,!1),r._backpressureChangePromise}function TransformStreamDefaultSourceCancelAlgorithm(r,t){let a=r._transformStreamController;if(void 0!==a._finishPromise)return a._finishPromise;let o=r._writable;a._finishPromise=newPromise((r,t)=>{a._finishPromise_resolve=r,a._finishPromise_reject=t});let l=a._cancelAlgorithm(t);return TransformStreamDefaultControllerClearAlgorithms(a),uponPromise(l,()=>("errored"===o._state?defaultControllerFinishPromiseReject(a,o._storedError):(WritableStreamDefaultControllerErrorIfNeeded(o._writableStreamController,t),TransformStreamUnblockWrite(r),defaultControllerFinishPromiseResolve(a)),null),t=>(WritableStreamDefaultControllerErrorIfNeeded(o._writableStreamController,t),TransformStreamUnblockWrite(r),defaultControllerFinishPromiseReject(a,t),null)),a._finishPromise}function defaultControllerBrandCheckException(r){return TypeError(`TransformStreamDefaultController.prototype.${r} can only be used on a TransformStreamDefaultController`)}function defaultControllerFinishPromiseResolve(r){void 0!==r._finishPromise_resolve&&(r._finishPromise_resolve(),r._finishPromise_resolve=void 0,r._finishPromise_reject=void 0)}function defaultControllerFinishPromiseReject(r,t){void 0!==r._finishPromise_reject&&(setPromiseIsHandledToTrue(r._finishPromise),r._finishPromise_reject(t),r._finishPromise_resolve=void 0,r._finishPromise_reject=void 0)}function streamBrandCheckException(r){return TypeError(`TransformStream.prototype.${r} can only be used on a TransformStream`)}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),setFunctionName(TransformStreamDefaultController.prototype.enqueue,"enqueue"),setFunctionName(TransformStreamDefaultController.prototype.error,"error"),setFunctionName(TransformStreamDefaultController.prototype.terminate,"terminate"),"symbol"==typeof Symbol.toStringTag&&Object.defineProperty(TransformStreamDefaultController.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:!0}),r.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy,r.CountQueuingStrategy=CountQueuingStrategy,r.ReadableByteStreamController=ReadableByteStreamController,r.ReadableStream=ReadableStream,r.ReadableStreamBYOBReader=ReadableStreamBYOBReader,r.ReadableStreamBYOBRequest=ReadableStreamBYOBRequest,r.ReadableStreamDefaultController=ReadableStreamDefaultController,r.ReadableStreamDefaultReader=ReadableStreamDefaultReader,r.TransformStream=TransformStream,r.TransformStreamDefaultController=TransformStreamDefaultController,r.WritableStream=WritableStream,r.WritableStreamDefaultController=WritableStreamDefaultController,r.WritableStreamDefaultWriter=WritableStreamDefaultWriter})(t)},1718:(r,t,a)=>{if(!globalThis.ReadableStream)try{let r=a(7742),{emitWarning:t}=r;try{r.emitWarning=()=>{},Object.assign(globalThis,a(2477)),r.emitWarning=t}catch(a){throw r.emitWarning=t,a}}catch(r){Object.assign(globalThis,a(7650))}try{let{Blob:r}=a(4300);r&&!r.prototype.stream&&(r.prototype.stream=function(r){let t=0,a=this;return new ReadableStream({type:"bytes",async pull(r){let o=a.slice(t,Math.min(a.size,t+65536)),l=await o.arrayBuffer();t+=l.byteLength,r.enqueue(new Uint8Array(l)),t===a.size&&r.close()}})})}catch(r){}},7389:(r,t,a)=>{"use strict";a.d(t,{Z:()=>n});var o=a(3968);let l=class extends o.Z{#e;#r;constructor(r,t,a={}){if(arguments.length<2)throw TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);super(r,a),this.#e=0,this.#r="",null===a&&(a={});let o=void 0===a.lastModified?Date.now():Number(a.lastModified);Number.isNaN(o)||(this.#e=o),this.#r=String(t)}get name(){return this.#r}get lastModified(){return this.#e}get[Symbol.toStringTag](){return"File"}static[Symbol.hasInstance](r){return!!r&&r instanceof o.Z&&/^(File)$/.test(r[Symbol.toStringTag])}},n=l},5945:(r,t,a)=>{"use strict";a.d(t,{$B:()=>i.Z,RA:()=>fileFromSync,SX:()=>blobFromSync,e2:()=>fileFrom,t6:()=>s.Z,xB:()=>blobFrom});var o=a(7561),l=a(9411),n=a(1865),i=a(7389),s=a(3968);let{stat:u}=o.promises,blobFromSync=(r,t)=>fromBlob((0,o.statSync)(r),r,t),blobFrom=(r,t)=>u(r).then(a=>fromBlob(a,r,t)),fileFrom=(r,t)=>u(r).then(a=>fromFile(a,r,t)),fileFromSync=(r,t)=>fromFile((0,o.statSync)(r),r,t),fromBlob=(r,t,a="")=>new s.Z([new BlobDataItem({path:t,size:r.size,lastModified:r.mtimeMs,start:0})],{type:a}),fromFile=(r,t,a="")=>new i.Z([new BlobDataItem({path:t,size:r.size,lastModified:r.mtimeMs,start:0})],(0,l.basename)(t),{type:a,lastModified:r.mtimeMs});let BlobDataItem=class BlobDataItem{#t;#a;constructor(r){this.#t=r.path,this.#a=r.start,this.size=r.size,this.lastModified=r.lastModified}slice(r,t){return new BlobDataItem({path:this.#t,lastModified:this.lastModified,size:t-r,start:this.#a+r})}async *stream(){let{mtimeMs:r}=await u(this.#t);if(r>this.lastModified)throw new n("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.","NotReadableError");yield*(0,o.createReadStream)(this.#t,{start:this.#a,end:this.#a+this.size-1})}get[Symbol.toStringTag](){return"Blob"}}},3968:(r,t,a)=>{"use strict";async function*toIterator(r,t=!0){for(let a of r)if("stream"in a)yield*a.stream();else if(ArrayBuffer.isView(a)){if(t){let r=a.byteOffset,t=a.byteOffset+a.byteLength;for(;r!==t;){let o=Math.min(t-r,65536),l=a.buffer.slice(r,r+o);r+=l.byteLength,yield new Uint8Array(l)}}else yield a}else{let r=0;for(;r!==a.size;){let t=a.slice(r,Math.min(a.size,r+65536)),o=await t.arrayBuffer();r+=o.byteLength,yield new Uint8Array(o)}}}a.d(t,{Z:()=>l}),a(1718);let o=class Blob{#o;#l;#n;#i;constructor(r=[],t={}){if(this.#o=[],this.#l="",this.#n=0,this.#i="transparent","object"!=typeof r||null===r)throw TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");if("function"!=typeof r[Symbol.iterator])throw TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");if("object"!=typeof t&&"function"!=typeof t)throw TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");null===t&&(t={});let a=new TextEncoder;for(let t of r){let r;r=ArrayBuffer.isView(t)?new Uint8Array(t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)):t instanceof ArrayBuffer?new Uint8Array(t.slice(0)):t instanceof Blob?t:a.encode(`${t}`),this.#n+=ArrayBuffer.isView(r)?r.byteLength:r.size,this.#o.push(r)}this.#i=`${void 0===t.endings?"transparent":t.endings}`;let o=void 0===t.type?"":String(t.type);this.#l=/^[\x20-\x7E]*$/.test(o)?o:""}get size(){return this.#n}get type(){return this.#l}async text(){let r=new TextDecoder,t="";for await(let a of toIterator(this.#o,!1))t+=r.decode(a,{stream:!0});return t+r.decode()}async arrayBuffer(){let r=new Uint8Array(this.size),t=0;for await(let a of toIterator(this.#o,!1))r.set(a,t),t+=a.length;return r.buffer}stream(){let r=toIterator(this.#o,!0);return new globalThis.ReadableStream({type:"bytes",async pull(t){let a=await r.next();a.done?t.close():t.enqueue(a.value)},async cancel(){await r.return()}})}slice(r=0,t=this.size,a=""){let{size:o}=this,l=r<0?Math.max(o+r,0):Math.min(r,o),n=t<0?Math.max(o+t,0):Math.min(t,o),i=Math.max(n-l,0),s=this.#o,u=[],d=0;for(let r of s){if(d>=i)break;let t=ArrayBuffer.isView(r)?r.byteLength:r.size;if(l&&t<=l)l-=t,n-=t;else{let a;ArrayBuffer.isView(r)?d+=(a=r.subarray(l,Math.min(t,n))).byteLength:d+=(a=r.slice(l,Math.min(t,n))).size,n-=t,u.push(a),l=0}}let c=new Blob([],{type:String(a).toLowerCase()});return c.#n=i,c.#o=u,c}get[Symbol.toStringTag](){return"Blob"}static[Symbol.hasInstance](r){return r&&"object"==typeof r&&"function"==typeof r.constructor&&("function"==typeof r.stream||"function"==typeof r.arrayBuffer)&&/^(Blob|File)$/.test(r[Symbol.toStringTag])}};Object.defineProperties(o.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}});let l=o},5461:(r,t,a)=>{"use strict";a.d(t,{Ct:()=>c,au:()=>formDataToBlob});var o=a(3968),l=a(7389),{toStringTag:n,iterator:i,hasInstance:s}=Symbol,u=Math.random,d="append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","),f=(r,t,a)=>(r+="",/^(Blob|File)$/.test(t&&t[n])?[(a=void 0!==a?a+"":"File"==t[n]?t.name:"blob",r),t.name!==a||"blob"==t[n]?new l.Z([t],a,t):t]:[r,t+""]),e=(r,t)=>(t?r:r.replace(/\r?\n|\r/g,"\r\n")).replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22"),x=(r,t,a)=>{if(t.length<a)throw TypeError(`Failed to execute '${r}' on 'FormData': ${a} arguments required, but only ${t.length} present.`)};let c=class{#s;constructor(...r){if(this.#s=[],r.length)throw TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.")}get[n](){return"FormData"}[i](){return this.entries()}static[s](r){return r&&"object"==typeof r&&"FormData"===r[n]&&!d.some(t=>"function"!=typeof r[t])}append(...r){x("append",arguments,2),this.#s.push(f(...r))}delete(r){x("delete",arguments,1),r+="",this.#s=this.#s.filter(([t])=>t!==r)}get(r){x("get",arguments,1),r+="";for(var t=this.#s,a=t.length,o=0;o<a;o++)if(t[o][0]===r)return t[o][1];return null}getAll(r,t){return x("getAll",arguments,1),t=[],r+="",this.#s.forEach(a=>a[0]===r&&t.push(a[1])),t}has(r){return x("has",arguments,1),r+="",this.#s.some(t=>t[0]===r)}forEach(r,t){for(var[a,o]of(x("forEach",arguments,1),this))r.call(t,o,a,this)}set(...r){x("set",arguments,2);var t=[],a=!0;r=f(...r),this.#s.forEach(o=>{o[0]===r[0]?a&&(a=!t.push(r)):t.push(o)}),a&&t.push(r),this.#s=t}*entries(){yield*this.#s}*keys(){for(var[r]of this)yield r}*values(){for(var[,r]of this)yield r}};function formDataToBlob(r,t=o.Z){var a=`${u()}${u()}`.replace(/\./g,"").slice(-28).padStart(32,"-"),l=[],n=`--${a}\r
Content-Disposition: form-data; name="`;return r.forEach((r,t)=>"string"==typeof r?l.push(n+e(t)+`"\r
\r
${r.replace(/\r(?!\n)|(?<!\r)\n/g,"\r\n")}\r
`):l.push(n+e(t)+`"; filename="${e(r.name,1)}"\r
Content-Type: ${r.type||"application/octet-stream"}\r
\r
`,r,"\r\n")),l.push(`--${a}--`),new t(l,{type:"multipart/form-data; boundary="+a})}},7676:(r,t,a)=>{"use strict";a.r(t),a.d(t,{AbortError:()=>AbortError,Blob:()=>T.t6,FetchError:()=>FetchError,File:()=>T.$B,FormData:()=>m.Ct,Headers:()=>Headers,Request:()=>Request,Response:()=>Response,blobFrom:()=>T.xB,blobFromSync:()=>T.SX,default:()=>fetch,fileFrom:()=>T.e2,fileFromSync:()=>T.RA,isRedirect:()=>isRedirect});var o=a(8849),l=a(2286),n=a(5628),i=a(4492),s=a(2254);function dataUriToBuffer(r){if(!/^data:/i.test(r))throw TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');r=r.replace(/\r?\n/g,"");let t=r.indexOf(",");if(-1===t||t<=4)throw TypeError("malformed data: URI");let a=r.substring(5,t).split(";"),o="",l=!1,n=a[0]||"text/plain",i=n;for(let r=1;r<a.length;r++)"base64"===a[r]?l=!0:a[r]&&(i+=`;${a[r]}`,0===a[r].indexOf("charset=")&&(o=a[r].substring(8)));a[0]||o.length||(i+=";charset=US-ASCII",o="US-ASCII");let s=l?"base64":"ascii",u=unescape(r.substring(t+1)),d=Buffer.from(u,s);return d.type=n,d.typeFull=i,d.charset=o,d}let u=dataUriToBuffer;var d=a(7261),c=a(3968),m=a(5461);let FetchBaseError=class FetchBaseError extends Error{constructor(r,t){super(r),Error.captureStackTrace(this,this.constructor),this.type=t}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}};let FetchError=class FetchError extends FetchBaseError{constructor(r,t,a){super(r,t),a&&(this.code=this.errno=a.code,this.erroredSysCall=a.syscall)}};let b=Symbol.toStringTag,isURLSearchParameters=r=>"object"==typeof r&&"function"==typeof r.append&&"function"==typeof r.delete&&"function"==typeof r.get&&"function"==typeof r.getAll&&"function"==typeof r.has&&"function"==typeof r.set&&"function"==typeof r.sort&&"URLSearchParams"===r[b],isBlob=r=>r&&"object"==typeof r&&"function"==typeof r.arrayBuffer&&"string"==typeof r.type&&"function"==typeof r.stream&&"function"==typeof r.constructor&&/^(Blob|File)$/.test(r[b]),isAbortSignal=r=>"object"==typeof r&&("AbortSignal"===r[b]||"EventTarget"===r[b]),isDomainOrSubdomain=(r,t)=>{let a=new URL(t).hostname,o=new URL(r).hostname;return a===o||a.endsWith(`.${o}`)},isSameProtocol=(r,t)=>{let a=new URL(t).protocol,o=new URL(r).protocol;return a===o},h=(0,d.promisify)(i.pipeline),p=Symbol("Body internals");let Body=class Body{constructor(r,{size:t=0}={}){let a=null;null===r?r=null:isURLSearchParameters(r)?r=s.Buffer.from(r.toString()):isBlob(r)||s.Buffer.isBuffer(r)||(d.types.isAnyArrayBuffer(r)?r=s.Buffer.from(r):ArrayBuffer.isView(r)?r=s.Buffer.from(r.buffer,r.byteOffset,r.byteLength):r instanceof i||(r instanceof m.Ct?a=(r=(0,m.au)(r)).type.split("=")[1]:r=s.Buffer.from(String(r))));let o=r;s.Buffer.isBuffer(r)?o=i.Readable.from(r):isBlob(r)&&(o=i.Readable.from(r.stream())),this[p]={body:r,stream:o,boundary:a,disturbed:!1,error:null},this.size=t,r instanceof i&&r.on("error",r=>{let t=r instanceof FetchBaseError?r:new FetchError(`Invalid response body while trying to fetch ${this.url}: ${r.message}`,"system",r);this[p].error=t})}get body(){return this[p].stream}get bodyUsed(){return this[p].disturbed}async arrayBuffer(){let{buffer:r,byteOffset:t,byteLength:a}=await consumeBody(this);return r.slice(t,t+a)}async formData(){let r=this.headers.get("content-type");if(r.startsWith("application/x-www-form-urlencoded")){let r=new m.Ct,t=new URLSearchParams(await this.text());for(let[a,o]of t)r.append(a,o);return r}let{toFormData:t}=await a.e(727).then(a.bind(a,8727));return t(this.body,r)}async blob(){let r=this.headers&&this.headers.get("content-type")||this[p].body&&this[p].body.type||"",t=await this.arrayBuffer();return new c.Z([t],{type:r})}async json(){let r=await this.text();return JSON.parse(r)}async text(){let r=await consumeBody(this);return new TextDecoder().decode(r)}buffer(){return consumeBody(this)}};async function consumeBody(r){if(r[p].disturbed)throw TypeError(`body used already for: ${r.url}`);if(r[p].disturbed=!0,r[p].error)throw r[p].error;let{body:t}=r;if(null===t||!(t instanceof i))return s.Buffer.alloc(0);let a=[],o=0;try{for await(let l of t){if(r.size>0&&o+l.length>r.size){let a=new FetchError(`content size at ${r.url} over limit: ${r.size}`,"max-size");throw t.destroy(a),a}o+=l.length,a.push(l)}}catch(a){let t=a instanceof FetchBaseError?a:new FetchError(`Invalid response body while trying to fetch ${r.url}: ${a.message}`,"system",a);throw t}if(!0===t.readableEnded||!0===t._readableState.ended)try{if(a.every(r=>"string"==typeof r))return s.Buffer.from(a.join(""));return s.Buffer.concat(a,o)}catch(t){throw new FetchError(`Could not create Buffer from response body for ${r.url}: ${t.message}`,"system",t)}else throw new FetchError(`Premature close of server response while trying to fetch ${r.url}`)}Body.prototype.buffer=(0,d.deprecate)(Body.prototype.buffer,"Please use 'response.arrayBuffer()' instead of 'response.buffer()'","node-fetch#buffer"),Object.defineProperties(Body.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0},data:{get:(0,d.deprecate)(()=>{},"data doesn't exist, use json(), text(), arrayBuffer(), or body instead","https://github.com/node-fetch/node-fetch/issues/1000 (response)")}});let clone=(r,t)=>{let a,o;let{body:l}=r[p];if(r.bodyUsed)throw Error("cannot clone body after it is used");return l instanceof i&&"function"!=typeof l.getBoundary&&(a=new i.PassThrough({highWaterMark:t}),o=new i.PassThrough({highWaterMark:t}),l.pipe(a),l.pipe(o),r[p].stream=a,l=o),l},S=(0,d.deprecate)(r=>r.getBoundary(),"form-data doesn't follow the spec and requires special treatment. Use alternative package","https://github.com/node-fetch/node-fetch/issues/1167"),extractContentType=(r,t)=>null===r?null:"string"==typeof r?"text/plain;charset=UTF-8":isURLSearchParameters(r)?"application/x-www-form-urlencoded;charset=UTF-8":isBlob(r)?r.type||null:s.Buffer.isBuffer(r)||d.types.isAnyArrayBuffer(r)||ArrayBuffer.isView(r)?null:r instanceof m.Ct?`multipart/form-data; boundary=${t[p].boundary}`:r&&"function"==typeof r.getBoundary?`multipart/form-data;boundary=${S(r)}`:r instanceof i?null:"text/plain;charset=UTF-8",getTotalBytes=r=>{let{body:t}=r[p];return null===t?0:isBlob(t)?t.size:s.Buffer.isBuffer(t)?t.length:t&&"function"==typeof t.getLengthSync&&t.hasKnownLength&&t.hasKnownLength()?t.getLengthSync():null},writeToStream=async(r,{body:t})=>{null===t?r.end():await h(t,r)},y="function"==typeof o.validateHeaderName?o.validateHeaderName:r=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(r)){let t=TypeError(`Header name must be a valid HTTP token [${r}]`);throw Object.defineProperty(t,"code",{value:"ERR_INVALID_HTTP_TOKEN"}),t}},R="function"==typeof o.validateHeaderValue?o.validateHeaderValue:(r,t)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(t)){let t=TypeError(`Invalid character in header content ["${r}"]`);throw Object.defineProperty(t,"code",{value:"ERR_INVALID_CHAR"}),t}};let Headers=class Headers extends URLSearchParams{constructor(r){let t=[];if(r instanceof Headers){let a=r.raw();for(let[r,o]of Object.entries(a))t.push(...o.map(t=>[r,t]))}else if(null==r);else if("object"!=typeof r||d.types.isBoxedPrimitive(r))throw TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");else{let a=r[Symbol.iterator];if(null==a)t.push(...Object.entries(r));else{if("function"!=typeof a)throw TypeError("Header pairs must be iterable");t=[...r].map(r=>{if("object"!=typeof r||d.types.isBoxedPrimitive(r))throw TypeError("Each header pair must be an iterable object");return[...r]}).map(r=>{if(2!==r.length)throw TypeError("Each header pair must be a name/value tuple");return[...r]})}}return super(t=t.length>0?t.map(([r,t])=>(y(r),R(r,String(t)),[String(r).toLowerCase(),String(t)])):void 0),new Proxy(this,{get(r,t,a){switch(t){case"append":case"set":return(a,o)=>(y(a),R(a,String(o)),URLSearchParams.prototype[t].call(r,String(a).toLowerCase(),String(o)));case"delete":case"has":case"getAll":return a=>(y(a),URLSearchParams.prototype[t].call(r,String(a).toLowerCase()));case"keys":return()=>(r.sort(),new Set(URLSearchParams.prototype.keys.call(r)).keys());default:return Reflect.get(r,t,a)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(r){let t=this.getAll(r);if(0===t.length)return null;let a=t.join(", ");return/^content-encoding$/i.test(r)&&(a=a.toLowerCase()),a}forEach(r,t){for(let a of this.keys())Reflect.apply(r,t,[this.get(a),a,this])}*values(){for(let r of this.keys())yield this.get(r)}*entries(){for(let r of this.keys())yield[r,this.get(r)]}[Symbol.iterator](){return this.entries()}raw(){return[...this.keys()].reduce((r,t)=>(r[t]=this.getAll(t),r),{})}[Symbol.for("nodejs.util.inspect.custom")](){return[...this.keys()].reduce((r,t)=>{let a=this.getAll(t);return"host"===t?r[t]=a[0]:r[t]=a.length>1?a:a[0],r},{})}};function fromRawHeaders(r=[]){return new Headers(r.reduce((r,t,a,o)=>(a%2==0&&r.push(o.slice(a,a+2)),r),[]).filter(([r,t])=>{try{return y(r),R(r,String(t)),!0}catch{return!1}}))}Object.defineProperties(Headers.prototype,["get","entries","forEach","values"].reduce((r,t)=>(r[t]={enumerable:!0},r),{}));let g=new Set([301,302,303,307,308]),isRedirect=r=>g.has(r),C=Symbol("Response internals");let Response=class Response extends Body{constructor(r=null,t={}){super(r,t);let a=null!=t.status?t.status:200,o=new Headers(t.headers);if(null!==r&&!o.has("Content-Type")){let t=extractContentType(r,this);t&&o.append("Content-Type",t)}this[C]={type:"default",url:t.url,status:a,statusText:t.statusText||"",headers:o,counter:t.counter,highWaterMark:t.highWaterMark}}get type(){return this[C].type}get url(){return this[C].url||""}get status(){return this[C].status}get ok(){return this[C].status>=200&&this[C].status<300}get redirected(){return this[C].counter>0}get statusText(){return this[C].statusText}get headers(){return this[C].headers}get highWaterMark(){return this[C].highWaterMark}clone(){return new Response(clone(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size,highWaterMark:this.highWaterMark})}static redirect(r,t=302){if(!isRedirect(t))throw RangeError('Failed to execute "redirect" on "response": Invalid status code');return new Response(null,{headers:{location:new URL(r).toString()},status:t})}static error(){let r=new Response(null,{status:0,statusText:""});return r[C].type="error",r}static json(r,t={}){let a=JSON.stringify(r);if(void 0===a)throw TypeError("data is not JSON serializable");let o=new Headers(t&&t.headers);return o.has("content-type")||o.set("content-type","application/json"),new Response(a,{...t,headers:o})}get[Symbol.toStringTag](){return"Response"}};Object.defineProperties(Response.prototype,{type:{enumerable:!0},url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},redirected:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}});var _=a(1041);let getSearch=r=>{if(r.search)return r.search;let t=r.href.length-1,a=r.hash||("#"===r.href[t]?"#":"");return"?"===r.href[t-a.length]?"?":""};var v=a(7503);function stripURLForUseAsAReferrer(r,t=!1){return null==r?"no-referrer":(r=new URL(r),/^(about|blob|data):$/.test(r.protocol))?"no-referrer":(r.username="",r.password="",r.hash="",t&&(r.pathname="",r.search=""),r)}let w=new Set(["","no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]);function validateReferrerPolicy(r){if(!w.has(r))throw TypeError(`Invalid referrerPolicy: ${r}`);return r}function isOriginPotentiallyTrustworthy(r){if(/^(http|ws)s:$/.test(r.protocol))return!0;let t=r.host.replace(/(^\[)|(]$)/g,""),a=(0,v.isIP)(t);return!!(4===a&&/^127\./.test(t)||6===a&&/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(t))||!("localhost"===r.host||r.host.endsWith(".localhost"))&&"file:"===r.protocol}function isUrlPotentiallyTrustworthy(r){return!!(/^about:(blank|srcdoc)$/.test(r)||"data:"===r.protocol||/^(blob|filesystem):$/.test(r.protocol))||isOriginPotentiallyTrustworthy(r)}function determineRequestsReferrer(r,{referrerURLCallback:t,referrerOriginCallback:a}={}){if("no-referrer"===r.referrer||""===r.referrerPolicy)return null;let o=r.referrerPolicy;if("about:client"===r.referrer)return"no-referrer";let l=r.referrer,n=stripURLForUseAsAReferrer(l),i=stripURLForUseAsAReferrer(l,!0);n.toString().length>4096&&(n=i),t&&(n=t(n)),a&&(i=a(i));let s=new URL(r.url);switch(o){case"no-referrer":return"no-referrer";case"origin":return i;case"unsafe-url":return n;case"strict-origin":if(isUrlPotentiallyTrustworthy(n)&&!isUrlPotentiallyTrustworthy(s))return"no-referrer";return i.toString();case"strict-origin-when-cross-origin":if(n.origin===s.origin)return n;if(isUrlPotentiallyTrustworthy(n)&&!isUrlPotentiallyTrustworthy(s))return"no-referrer";return i;case"same-origin":if(n.origin===s.origin)return n;return"no-referrer";case"origin-when-cross-origin":if(n.origin===s.origin)return n;return i;case"no-referrer-when-downgrade":if(isUrlPotentiallyTrustworthy(n)&&!isUrlPotentiallyTrustworthy(s))return"no-referrer";return n;default:throw TypeError(`Invalid referrerPolicy: ${o}`)}}function parseReferrerPolicyFromHeader(r){let t=(r.get("referrer-policy")||"").split(/[,\s]+/),a="";for(let r of t)r&&w.has(r)&&(a=r);return a}let B=Symbol("Request internals"),isRequest=r=>"object"==typeof r&&"object"==typeof r[B],P=(0,d.deprecate)(()=>{},".data is not a valid RequestInit property, use .body instead","https://github.com/node-fetch/node-fetch/issues/1000 (request)");let Request=class Request extends Body{constructor(r,t={}){let a;if(isRequest(r)?a=new URL(r.url):(a=new URL(r),r={}),""!==a.username||""!==a.password)throw TypeError(`${a} is an url with embedded credentials.`);let o=t.method||r.method||"GET";if(/^(delete|get|head|options|post|put)$/i.test(o)&&(o=o.toUpperCase()),!isRequest(t)&&"data"in t&&P(),(null!=t.body||isRequest(r)&&null!==r.body)&&("GET"===o||"HEAD"===o))throw TypeError("Request with GET/HEAD method cannot have body");let l=t.body?t.body:isRequest(r)&&null!==r.body?clone(r):null;super(l,{size:t.size||r.size||0});let n=new Headers(t.headers||r.headers||{});if(null!==l&&!n.has("Content-Type")){let r=extractContentType(l,this);r&&n.set("Content-Type",r)}let i=isRequest(r)?r.signal:null;if("signal"in t&&(i=t.signal),null!=i&&!isAbortSignal(i))throw TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");let s=null==t.referrer?r.referrer:t.referrer;if(""===s)s="no-referrer";else if(s){let r=new URL(s);s=/^about:(\/\/)?client$/.test(r)?"client":r}else s=void 0;this[B]={method:o,redirect:t.redirect||r.redirect||"follow",headers:n,parsedURL:a,signal:i,referrer:s},this.follow=void 0===t.follow?void 0===r.follow?20:r.follow:t.follow,this.compress=void 0===t.compress?void 0===r.compress||r.compress:t.compress,this.counter=t.counter||r.counter||0,this.agent=t.agent||r.agent,this.highWaterMark=t.highWaterMark||r.highWaterMark||16384,this.insecureHTTPParser=t.insecureHTTPParser||r.insecureHTTPParser||!1,this.referrerPolicy=t.referrerPolicy||r.referrerPolicy||""}get method(){return this[B].method}get url(){return(0,_.format)(this[B].parsedURL)}get headers(){return this[B].headers}get redirect(){return this[B].redirect}get signal(){return this[B].signal}get referrer(){return"no-referrer"===this[B].referrer?"":"client"===this[B].referrer?"about:client":this[B].referrer?this[B].referrer.toString():void 0}get referrerPolicy(){return this[B].referrerPolicy}set referrerPolicy(r){this[B].referrerPolicy=validateReferrerPolicy(r)}clone(){return new Request(this)}get[Symbol.toStringTag](){return"Request"}};Object.defineProperties(Request.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0},signal:{enumerable:!0},referrer:{enumerable:!0},referrerPolicy:{enumerable:!0}});let getNodeRequestOptions=r=>{let{parsedURL:t}=r[B],a=new Headers(r[B].headers);a.has("Accept")||a.set("Accept","*/*");let o=null;if(null===r.body&&/^(post|put)$/i.test(r.method)&&(o="0"),null!==r.body){let t=getTotalBytes(r);"number"!=typeof t||Number.isNaN(t)||(o=String(t))}o&&a.set("Content-Length",o),""===r.referrerPolicy&&(r.referrerPolicy="strict-origin-when-cross-origin"),r.referrer&&"no-referrer"!==r.referrer?r[B].referrer=determineRequestsReferrer(r):r[B].referrer="no-referrer",r[B].referrer instanceof URL&&a.set("Referer",r.referrer),a.has("User-Agent")||a.set("User-Agent","node-fetch"),r.compress&&!a.has("Accept-Encoding")&&a.set("Accept-Encoding","gzip, deflate, br");let{agent:l}=r;"function"==typeof l&&(l=l(t));let n=getSearch(t),i={path:t.pathname+n,method:r.method,headers:a[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:r.insecureHTTPParser,agent:l};return{parsedURL:t,options:i}};let AbortError=class AbortError extends FetchBaseError{constructor(r,t="aborted"){super(r,t)}};var T=a(5945);let W=new Set(["data:","http:","https:"]);async function fetch(r,t){return new Promise((a,s)=>{let d=new Request(r,t),{parsedURL:c,options:m}=getNodeRequestOptions(d);if(!W.has(c.protocol))throw TypeError(`node-fetch cannot load ${r}. URL scheme "${c.protocol.replace(/:$/,"")}" is not supported.`);if("data:"===c.protocol){let r=u(d.url),t=new Response(r,{headers:{"Content-Type":r.typeFull}});a(t);return}let b=("https:"===c.protocol?l:o).request,{signal:h}=d,p=null,abort=()=>{let r=new AbortError("The operation was aborted.");s(r),d.body&&d.body instanceof i.Readable&&d.body.destroy(r),p&&p.body&&p.body.emit("error",r)};if(h&&h.aborted){abort();return}let abortAndFinalize=()=>{abort(),finalize()},S=b(c.toString(),m);h&&h.addEventListener("abort",abortAndFinalize);let finalize=()=>{S.abort(),h&&h.removeEventListener("abort",abortAndFinalize)};S.on("error",r=>{s(new FetchError(`request to ${d.url} failed, reason: ${r.message}`,"system",r)),finalize()}),fixResponseChunkedTransferBadEnding(S,r=>{p&&p.body&&p.body.destroy(r)}),process.version<"v14"&&S.on("socket",r=>{let t;r.prependListener("end",()=>{t=r._eventsCount}),r.prependListener("close",a=>{if(p&&t<r._eventsCount&&!a){let r=Error("Premature close");r.code="ERR_STREAM_PREMATURE_CLOSE",p.body.emit("error",r)}})}),S.on("response",r=>{S.setTimeout(0);let o=fromRawHeaders(r.rawHeaders);if(isRedirect(r.statusCode)){let l=o.get("Location"),n=null;try{n=null===l?null:new URL(l,d.url)}catch{if("manual"!==d.redirect){s(new FetchError(`uri requested responds with an invalid redirect URL: ${l}`,"invalid-redirect")),finalize();return}}switch(d.redirect){case"error":s(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${d.url}`,"no-redirect")),finalize();return;case"manual":break;case"follow":{if(null===n)break;if(d.counter>=d.follow){s(new FetchError(`maximum redirect reached at: ${d.url}`,"max-redirect")),finalize();return}let l={headers:new Headers(d.headers),follow:d.follow,counter:d.counter+1,agent:d.agent,compress:d.compress,method:d.method,body:clone(d),signal:d.signal,size:d.size,referrer:d.referrer,referrerPolicy:d.referrerPolicy};if(!isDomainOrSubdomain(d.url,n)||!isSameProtocol(d.url,n))for(let r of["authorization","www-authenticate","cookie","cookie2"])l.headers.delete(r);if(303!==r.statusCode&&d.body&&t.body instanceof i.Readable){s(new FetchError("Cannot follow redirect with body being a readable stream","unsupported-redirect")),finalize();return}(303===r.statusCode||(301===r.statusCode||302===r.statusCode)&&"POST"===d.method)&&(l.method="GET",l.body=void 0,l.headers.delete("content-length"));let u=parseReferrerPolicyFromHeader(o);u&&(l.referrerPolicy=u),a(fetch(new Request(n,l))),finalize();return}default:return s(TypeError(`Redirect option '${d.redirect}' is not a valid value of RequestRedirect`))}}h&&r.once("end",()=>{h.removeEventListener("abort",abortAndFinalize)});let l=(0,i.pipeline)(r,new i.PassThrough,r=>{r&&s(r)});process.version<"v12.10"&&r.on("aborted",abortAndFinalize);let u={url:d.url,status:r.statusCode,statusText:r.statusMessage,headers:o,size:d.size,counter:d.counter,highWaterMark:d.highWaterMark},c=o.get("Content-Encoding");if(!d.compress||"HEAD"===d.method||null===c||204===r.statusCode||304===r.statusCode){a(p=new Response(l,u));return}let m={flush:n.Z_SYNC_FLUSH,finishFlush:n.Z_SYNC_FLUSH};if("gzip"===c||"x-gzip"===c){a(p=new Response(l=(0,i.pipeline)(l,n.createGunzip(m),r=>{r&&s(r)}),u));return}if("deflate"===c||"x-deflate"===c){let t=(0,i.pipeline)(r,new i.PassThrough,r=>{r&&s(r)});t.once("data",r=>{a(p=new Response(l=(15&r[0])==8?(0,i.pipeline)(l,n.createInflate(),r=>{r&&s(r)}):(0,i.pipeline)(l,n.createInflateRaw(),r=>{r&&s(r)}),u))}),t.once("end",()=>{p||a(p=new Response(l,u))});return}if("br"===c){a(p=new Response(l=(0,i.pipeline)(l,n.createBrotliDecompress(),r=>{r&&s(r)}),u));return}a(p=new Response(l,u))}),writeToStream(S,d).catch(s)})}function fixResponseChunkedTransferBadEnding(r,t){let a;let o=s.Buffer.from("0\r\n\r\n"),l=!1,n=!1;r.on("response",r=>{let{headers:t}=r;l="chunked"===t["transfer-encoding"]&&!t["content-length"]}),r.on("socket",i=>{let onSocketClose=()=>{if(l&&!n){let r=Error("Premature close");r.code="ERR_STREAM_PREMATURE_CLOSE",t(r)}},onData=r=>{(n=0===s.Buffer.compare(r.slice(-5),o))||!a||(n=0===s.Buffer.compare(a.slice(-3),o.slice(0,3))&&0===s.Buffer.compare(r.slice(-2),o.slice(3))),a=r};i.prependListener("close",onSocketClose),i.on("data",onData),r.on("close",()=>{i.removeListener("close",onSocketClose),i.removeListener("data",onData)})})}}};